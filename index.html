<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Jvaeyhcd的技术博客</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/javeyhcd" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Jvaeyhcd" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/06/iOS中造成dealloc不调用的原因/" class="post-title-link">iOS中造成dealloc不调用的原因</a></h2><div class="post-time">Apr 6, 2016</div><div class="post-content"><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;&#10;    [_mapView release];&#10;    [super dealloc];&#10;&#125;&#10;&#10;//&#24182;&#19988;&#22312;&#30028;&#38754;&#23558;&#35201;&#26174;&#31034;&#30340;&#26102;&#20505;&#35774;&#32622;&#20195;&#29702;&#65292;&#23558;&#35201;&#28040;&#22833;&#30340;&#26102;&#20505;&#21462;&#28040;&#20195;&#29702;&#10;- (void)viewWillAppear:(BOOL)animated &#123;&#10;    _mapView.delegate = self;&#10;&#125;&#10;&#10;- (void)viewWillDisappear:(BOOL)animated &#123;&#10;    _mapView.delegate = nil;&#10;&#125;</span><br></pre></td></tr></table></figure></p></div><a href="/2016/04/06/iOS中造成dealloc不调用的原因/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/05/关于UItableView的复用/" class="post-title-link">关于UItableView的复用</a></h2><div class="post-time">Apr 5, 2016</div><div class="post-content"><p>UITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。</p>
<h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。</p></div><a href="/2016/04/05/关于UItableView的复用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/30/关于iOS多线程小记/" class="post-title-link">关于iOS多线程小记</a></h2><div class="post-time">Mar 30, 2016</div><div class="post-content"><p>这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。</p>
<h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：</p>
<ul>
<li>进程间不能共享内存，但线程间共享内存非常容易。</li>
<li>系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。</li>
</ul></div><a href="/2016/03/30/关于iOS多线程小记/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/28/iOS上完美编译FFmpeg/" class="post-title-link">iOS上完美编译FFmpeg</a></h2><div class="post-time">Mar 28, 2016</div><div class="post-content"><p>最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture arm64:&#10;  &#34;_avcodec_close&#34;, referenced from:&#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&#10;  &#34;_av_init_packet&#34;, referenced from:&#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&#38;, int&#38;) in H264Decoder.o&#10;  &#34;_av_malloc&#34;, referenced from:&#10;      CH264Decoder::CreateYUVTab_16() in H264Decoder.o&#10;  &#34;_av_free&#34;, referenced from:&#10;      CH264Decoder::DeleteYUVTab() in H264Decoder.o&#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&#10;  &#34;_av_register_all&#34;, referenced from:&#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&#10;  &#34;_avcodec_find_decoder&#34;, referenced from:&#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&#10;  &#34;_avcodec_decode_video2&#34;, referenced from:&#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&#38;, int&#38;) in H264Decoder.o&#10;  &#34;_avcodec_open2&#34;, referenced from:&#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&#10;  &#34;_avcodec_alloc_context3&#34;, referenced from:&#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&#10;  &#34;_avcodec_alloc_frame&#34;, referenced from:&#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&#10;ld: symbol(s) not found for architecture arm64&#10;clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure></p></div><a href="/2016/03/28/iOS上完美编译FFmpeg/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/26/iOS-UIWebView简单使用/" class="post-title-link">iOS UIWebView简单使用</a></h2><div class="post-time">Mar 26, 2016</div><div class="post-content"><p>UIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。</p>
<p>下面我想简单记录一下UIWebView的简单使用。</p>
<ol>
<li><p>创建UIWebView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGRect bouds = [[UIScreen manScreen]applicationFrame];  &#10;UIWebView* webView = [[UIWebView alloc]initWithFrame:bounds];</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置相关属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.scalespageToFit = YES;&#9;    //&#33258;&#21160;&#23545;&#39029;&#38754;&#36827;&#34892;&#32553;&#25918;&#20197;&#36866;&#24212;&#23631;&#24149;  &#10;webView.detectsPhoneNumbers = YES;  //&#33258;&#21160;&#26816;&#27979;&#32593;&#39029;&#19978;&#30340;&#30005;&#35805;&#21495;&#30721;&#65292;&#21333;&#20987;&#21487;&#20197;&#25320;&#25171;</span><br></pre></td></tr></table></figure>
</li>
</ol></div><a href="/2016/03/26/iOS-UIWebView简单使用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/23/Objective-C常用关键字的使用与区别/" class="post-title-link">Objective-C常用关键字的使用与区别</a></h2><div class="post-time">Mar 23, 2016</div><div class="post-content"><p>虽然接触iOS已经很久了，但是对于Objective-C中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@propperty (?,?) ?*!;&#10;...............&#10;............&#10;.........&#10;......</span><br></pre></td></tr></table></figure></p>
<p>就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。<br>所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。</p>
<p>OC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。<br>这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）</p></div><a href="/2016/03/23/Objective-C常用关键字的使用与区别/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/17/iOS几种不同传值方式/" class="post-title-link">iOS几种不同传值方式</a></h2><div class="post-time">Mar 17, 2016</div><div class="post-content"><p>关于iOS的传值方式我所知道的一共有一下6种方式：</p>
<ul>
<li>属性传值</li>
<li>代理传值</li>
<li>block传值</li>
<li>单例传值</li>
<li>通知传值</li>
<li>NSUserDefault保存数据传值</li>
</ul>
<p>以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。</p></div><a href="/2016/03/17/iOS几种不同传值方式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/05/App-Store上线完整流程/" class="post-title-link">App Store上线完整流程</a></h2><div class="post-time">Mar 5, 2016</div><div class="post-content"><p>经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。</p>
<h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><p>在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。</p></div><a href="/2016/03/05/App-Store上线完整流程/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/05/RESideMenu在所有界面都会侧滑的问题解决办法/" class="post-title-link">RESideMenu在所有界面都会侧滑的问题解决办法</a></h2><div class="post-time">Mar 5, 2016</div><div class="post-content"><blockquote>
<p>RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。</p>
</blockquote></div><a href="/2016/03/05/RESideMenu在所有界面都会侧滑的问题解决办法/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/24/Block正确使用避免Cycle-Retain和Crash/" class="post-title-link">Block正确使用避免Cycle Retain和Crash</a></h2><div class="post-time">Feb 24, 2016</div><div class="post-content"><blockquote>
<p>本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下<strong>block不会增加引用计数，但ARC会，ARC下必须用</strong>weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样</p>
</blockquote>
<h6>Block简介</h6>

<p>Block作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于Objective-C在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。</p>
<p>可以这样理解，Block其实包含两个部分内容</p>
<ul>
<li>Block执行的代码，这是在编译的时候已经生成好的；</li>
<li>一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。</li>
</ul>
<p>Block与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。</p></div><a href="/2016/02/24/Block正确使用避免Cycle-Retain和Crash/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 <a href="http://www.jvaeyhcd.cc">Jvaeyhcd</a> | Powered by Hexo</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>