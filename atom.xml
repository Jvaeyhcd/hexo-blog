<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jvaeyhcd&#39;s Note</title>
  <subtitle>My Coding Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jvaeyhcd.cc/"/>
  <updated>2016-05-24T05:45:09.000Z</updated>
  <id>http://www.jvaeyhcd.cc/</id>
  
  <author>
    <name>Jvaeyhcd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识ReactiveCocoa响应式编程</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/24/%E5%88%9D%E8%AF%86ReactiveCocoa%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/24/初识ReactiveCocoa响应式编程/</id>
    <published>2016-05-24T05:02:01.000Z</published>
    <updated>2016-05-24T05:45:09.000Z</updated>
    
    <content type="html">&lt;p&gt;参考文章&lt;br&gt;&lt;a href=&quot;http://www.itiger.me/?p=38&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用ReactiveCocoa实现iOS平台响应式编程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa与Functional Reactive Programming&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/87ef6720a096&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最快让你上手ReactiveCocoa之基础篇&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2014/07/reactiveCocoa-cocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;花瓣网李忠：ReactiveCocoa是Cocoa的未来&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa 讨论会&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;参考文章&lt;br&gt;&lt;a href=&quot;http://www.itiger.me/?p=38&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用ReactiveCocoa实现iOS平台响应式编程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://limboy.me/
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://www.jvaeyhcd.cc/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins构建iOS持续集成自动打包</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/21/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BAiOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/21/使用Jenkins构建iOS持续集成自动打包/</id>
    <published>2016-05-21T07:48:50.000Z</published>
    <updated>2016-05-21T07:55:25.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用持续集成&quot;&gt;&lt;a href=&quot;#为什么使用持续集成&quot; class=&quot;headerlink&quot; title=&quot;为什么使用持续集成&quot;&gt;&lt;/a&gt;为什么使用持续集成&lt;/h3&gt;&lt;p&gt;1、减少重复繁琐的打包过程&lt;br&gt;2、任何时间、任何地点测试都可以获取到新包&lt;br&gt;3、增强项目的可见性&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;参考文档：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/c69deb29720d#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://rannie.github.io/ios/2014/12/29/xcodebuild-jenkins-ci.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用 Xcodebuild + Jenkins + Apache 做 iOS 持续集成&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用持续集成&quot;&gt;&lt;a href=&quot;#为什么使用持续集成&quot; class=&quot;headerlink&quot; title=&quot;为什么使用持续集成&quot;&gt;&lt;/a&gt;为什么使用持续集成&lt;/h3&gt;&lt;p&gt;1、减少重复繁琐的打包过程&lt;br&gt;2、任何时间、任何地点测试都可以获取到新包&lt;br&gt;3、增强项目的可见性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://www.jvaeyhcd.cc/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>关闭iOS系统自动更新提示的方法</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/16/%E5%85%B3%E9%97%ADiOS%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/16/关闭iOS系统自动更新提示的方法/</id>
    <published>2016-05-16T02:16:25.000Z</published>
    <updated>2016-05-16T02:53:02.000Z</updated>
    
    <content type="html">&lt;p&gt;一直以来都被iOS的自动更新困扰，每次苹果推出了最新版本的iOS系统都会提示自动更新，真的很烦。并且公司的测试机不可能全都是一个版本的系统，不然很多不同iOS版本系统的bug根本无法测出来，所以为了保持测试机系统的多样性，我想保持一部分手机系统永不更新，让我自己的手机保持最新系统就行了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h3&gt;&lt;p&gt;经过一段时间的试验，有如下几个对应方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 - 通用 - 用量 - 管理存储空间 - 找到更新包，然后删除它&lt;/li&gt;
&lt;li&gt;设置 - iTunes&amp;amp;App Stores, 找到Updates，关闭&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果以上两个方案还不管用，直接放大招：&lt;br&gt;在手机上打开safari，地址栏输入:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://oldcat.me/web/NOOTA9.mobileconfig&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后回车&lt;br&gt;按照要求安装此provision文件即可，然后重启。&lt;/p&gt;
&lt;img src=&quot;/2016/05/16/关闭iOS系统自动更新提示的方法/thumb_IMG_0889_1024.jpg&quot; alt=&quot;安装provision文件&quot; title=&quot;安装provision文件&quot;&gt;
&lt;p&gt;重启后打开设置 - 通用 - 软件更新 有惊喜&lt;/p&gt;
&lt;img src=&quot;/2016/05/16/关闭iOS系统自动更新提示的方法/thumb_IMG_0890_1024.jpg&quot; alt=&quot;结果图&quot; title=&quot;结果图&quot;&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都被iOS的自动更新困扰，每次苹果推出了最新版本的iOS系统都会提示自动更新，真的很烦。并且公司的测试机不可能全都是一个版本的系统，不然很多不同iOS版本系统的bug根本无法测出来，所以为了保持测试机系统的多样性，我想保持一部分手机系统永不更新，让我自己的手机保持最新系统就行了。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.jvaeyhcd.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="iOS系统" scheme="http://www.jvaeyhcd.cc/tags/iOS%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C过滤NSString中的HTML标签</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/04/Objective-C%E8%BF%87%E6%BB%A4NSString%E4%B8%AD%E7%9A%84HTML%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/04/Objective-C过滤NSString中的HTML标签/</id>
    <published>2016-05-04T03:17:29.000Z</published>
    <updated>2016-05-04T03:32:15.000Z</updated>
    
    <content type="html">&lt;p&gt;开发过程中常常会遇到这样一个情况：对于后台编辑的一些文本都是使用富文本的形式进行编辑的，我们在使用接口区请求数据的时候，请求到的数据是带HTML标签的富文本形式，但是我们前台是使用UIlabel去显示的，这个时候就需要去掉NSString的HTML标签。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;对于这种常用的一些方法，我们一般会创建一个NSString的Category去实现。关于去掉NSString中HTML标签的实现方法我在网上找到了两种实现方式：&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h3&gt;&lt;p&gt;用NSScanner扫描来处理&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;NSString+Jvaeyhcd.h&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;Foundation/Foundation.h&amp;#62;&amp;#10;&amp;#10;@interface NSString (Jvaeyhcd)&amp;#10;&amp;#10;- (NSString *)removeHTML;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NSString+Jvaeyhcd.m&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)removeHTML &amp;#123;&amp;#10;    &amp;#10;    NSScanner *theScanner;&amp;#10;    NSString *text = nil;&amp;#10;    &amp;#10;    theScanner = [NSScanner scannerWithString:self];&amp;#10;&amp;#10;    while ([theScanner isAtEnd] == NO) &amp;#123;&amp;#10;        // find start of tag&amp;#10;        [theScanner scanUpToString:@&amp;#34;&amp;#60;&amp;#34; intoString:NULL] ;&amp;#10;        // find end of tag&amp;#10;        [theScanner scanUpToString:@&amp;#34;&amp;#62;&amp;#34; intoString:&amp;#38;text] ;&amp;#10;        &amp;#10;        // replace the found tag with a space&amp;#10;        &amp;#10;        //(you can filter multi-spaces out later if you wish)&amp;#10;        &amp;#10;        self = [self stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&amp;#34;%@&amp;#62;&amp;#34;, text] withString:@&amp;#34; &amp;#34;];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法二&quot;&gt;&lt;a href=&quot;#方法二&quot; class=&quot;headerlink&quot; title=&quot;方法二&quot;&gt;&lt;/a&gt;方法二&lt;/h3&gt;&lt;p&gt;用NSString自带的Seprated自截断方法&lt;/p&gt;
&lt;p&gt;NSString+Jvaeyhcd.h&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;Foundation/Foundation.h&amp;#62;&amp;#10;&amp;#10;@interface NSString (Jvaeyhcd)&amp;#10;&amp;#10;- (NSString *)removeHTML2;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NSString+Jvaeyhcd.m&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)removeHTML2 &amp;#123;&amp;#10;    NSArray *components = [self componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&amp;#34;&amp;#60;&amp;#62;&amp;#34;]];&amp;#10;    NSMutableArray *componentsToKeep = [NSMutableArray array];&amp;#10;    &amp;#10;    for (int i = 0; i &amp;#60; [components count]; i = i + 2) &amp;#123;&amp;#10;        [componentsToKeep addObject:[components objectAtIndex:i]];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    NSString *plainText = [componentsToKeep componentsJoinedByString:@&amp;#34;&amp;#34;];&amp;#10;    &amp;#10;    return plainText;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中常常会遇到这样一个情况：对于后台编辑的一些文本都是使用富文本的形式进行编辑的，我们在使用接口区请求数据的时候，请求到的数据是带HTML标签的富文本形式，但是我们前台是使用UIlabel去显示的，这个时候就需要去掉NSString的HTML标签。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;对于这种常用的一些方法，我们一般会创建一个NSString的Category去实现。关于去掉NSString中HTML标签的实现方法我在网上找到了两种实现方式：&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h3&gt;&lt;p&gt;用NSScanner扫描来处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://www.jvaeyhcd.cc/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记之基础部分</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/29/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/29/Swift学习笔记之基础部分/</id>
    <published>2016-04-29T02:07:32.000Z</published>
    <updated>2016-04-29T08:57:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文所有知识都来至于网上以及官方的学习资料，本文不做任何商业用途，只是自己的一个学习笔记，如有侵权请及时告知我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言(传说以后还可以用于开始Android应用)。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的（如果没有 C 或者 Objective-C 相关开发经验也没有关系，大家都说Swift比较通俗易懂更加容易上手）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Swift包含了C 和Objective-C上所有的数据类型，&lt;code&gt;Int&lt;/code&gt;表示整型值；&lt;code&gt;Double&lt;/code&gt;和&lt;code&gt;Float&lt;/code&gt;表示浮点型值；&lt;code&gt;Bool&lt;/code&gt;是布尔型值；&lt;code&gt;String&lt;/code&gt;是字符串型值。此外Swift还提供了三个基本的集合类型，&lt;code&gt;Array&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt;和&lt;code&gt;Dictionary&lt;/code&gt;。&lt;br&gt;除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。&lt;/p&gt;
&lt;p&gt;Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用&lt;code&gt;nil&lt;/code&gt;，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的nil指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。&lt;/p&gt;
&lt;p&gt;Swift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个String，类型安全会阻止你不小心传入一个&lt;code&gt;Int&lt;/code&gt;。你可以在开发阶段尽早发现并修正错误。&lt;/p&gt;
&lt;h2 id=&quot;常量和变量&quot;&gt;&lt;a href=&quot;#常量和变量&quot; class=&quot;headerlink&quot; title=&quot;常量和变量&quot;&gt;&lt;/a&gt;常量和变量&lt;/h2&gt;&lt;p&gt;常量的值一旦设定就不能改变，而变量的值可以随意更改。&lt;/p&gt;
&lt;h2 id=&quot;声明常量和变量&quot;&gt;&lt;a href=&quot;#声明常量和变量&quot; class=&quot;headerlink&quot; title=&quot;声明常量和变量&quot;&gt;&lt;/a&gt;声明常量和变量&lt;/h2&gt;&lt;p&gt;常量和变量必须在使用前声明，用&lt;code&gt;let&lt;/code&gt;来声明常量，用&lt;code&gt;var&lt;/code&gt;来声明变量。下面的例子展示了如何用常量和变量&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let maxNumberOfLoginTimes = 10&amp;#10;var currentLoginTimes = 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两行代码可以理解为：&lt;br&gt;&lt;code&gt;maxNumberOfLoginTimes&lt;/code&gt;声明为一个常量，它的值是10并且不可再被改变，&lt;code&gt;currentLoginAttempt&lt;/code&gt;申明为一个初始值为0的变量。&lt;br&gt;我们可以在一行中声明多个常量或者多个变量，用逗号隔开：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var x = 0.0, y = 0.0&amp;#10;let a = 1, b = 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果你的代码中有不需要改变的值，请使用&lt;code&gt;let&lt;/code&gt;关键字将它声明为常量。只将需要改变的值声明为变量。与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let languageName = &amp;#34;Swift&amp;#34;&amp;#10;languageName = &amp;#34;Swift++&amp;#34;&amp;#10;// &amp;#36825;&amp;#20250;&amp;#25253;&amp;#32534;&amp;#35793;&amp;#26102;&amp;#38169;&amp;#35823; - languageName &amp;#19981;&amp;#21487;&amp;#25913;&amp;#21464;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;类型标注&quot;&gt;&lt;a href=&quot;#类型标注&quot; class=&quot;headerlink&quot; title=&quot;类型标注&quot;&gt;&lt;/a&gt;类型标注&lt;/h2&gt;&lt;p&gt;当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。&lt;br&gt;这个例子给&lt;code&gt;welcomeMessage&lt;/code&gt;变量添加了类型标注，表示这个变量可以存储&lt;code&gt;String&lt;/code&gt;类型的值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var welcomeMessage: String&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：&lt;br&gt;“声明一个类型为&lt;code&gt;String&lt;/code&gt;，名字为&lt;code&gt;welcomeMessage&lt;/code&gt;的变量。”&lt;br&gt;“类型为&lt;code&gt;String&lt;/code&gt;”的意思是“可以存储任意&lt;code&gt;String&lt;/code&gt;类型的值。”&lt;br&gt;&lt;code&gt;welcomeMessage&lt;/code&gt;变量现在可以被设置成任意字符串：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;welcomeMessage = &amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var red, green, blue: Double&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给&lt;code&gt;welcomeMessage&lt;/code&gt;赋初始值，所以变量&lt;code&gt;welcomeMessage&lt;/code&gt;的类型是通过一个类型标注指定的，而不是通过初始值推断的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常量和变量的命名&quot;&gt;&lt;a href=&quot;#常量和变量的命名&quot; class=&quot;headerlink&quot; title=&quot;常量和变量的命名&quot;&gt;&lt;/a&gt;常量和变量的命名&lt;/h2&gt;&lt;p&gt;你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let &amp;#960; = 3.14159&amp;#10;let &amp;#20320;&amp;#22909; = &amp;#34;&amp;#20320;&amp;#22909;&amp;#19990;&amp;#30028;&amp;#34;&amp;#10;let &amp;#128054;&amp;#128046; = &amp;#34;dogcow&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。&lt;/p&gt;
&lt;p&gt;一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;输出常量和变量&quot;&gt;&lt;a href=&quot;#输出常量和变量&quot; class=&quot;headerlink&quot; title=&quot;输出常量和变量&quot;&gt;&lt;/a&gt;输出常量和变量&lt;/h2&gt;&lt;p&gt;你可以用&lt;code&gt;print(_:separator:terminator:)&lt;/code&gt;函数来输出当前常量或变量的值:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var friendlyWelcome = &amp;#34;Bonjour!&amp;#34;&amp;#10;print(friendlyWelcome)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;Bonjour!&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print(_:separator:terminator:)&lt;/code&gt;是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，&lt;code&gt;print(_:separator:terminator:)&lt;/code&gt;将会输出内容到“console”面板上。separator和terminator参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给terminator参数–例如，&lt;code&gt;print(someValue, terminator:&amp;quot;&amp;quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;#34;The current value of friendlyWelcome is \(friendlyWelcome)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The current value of friendlyWelcome is Bonjour!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h2&gt;&lt;p&gt;请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。&lt;br&gt;与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* &amp;#36825;&amp;#26159;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322;&amp;#30340;&amp;#24320;&amp;#22836;&amp;#10;/* &amp;#36825;&amp;#26159;&amp;#31532;&amp;#20108;&amp;#20010;&amp;#34987;&amp;#23884;&amp;#22871;&amp;#30340;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322; */&amp;#10;&amp;#36825;&amp;#26159;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322;&amp;#30340;&amp;#32467;&amp;#23614; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。&lt;br&gt;当然Swift的单行注释和多行注释和C语言的类似。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#36825;&amp;#26159;&amp;#19968;&amp;#20010;&amp;#21333;&amp;#34892;&amp;#27880;&amp;#37322;&amp;#10;/* &amp;#36825;&amp;#26159;&amp;#19968;&amp;#20010;,&amp;#10;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;分号&quot;&gt;&lt;a href=&quot;#分号&quot; class=&quot;headerlink&quot; title=&quot;分号&quot;&gt;&lt;/a&gt;分号&lt;/h2&gt;&lt;p&gt;与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let cat = &amp;#34;&amp;#128049;&amp;#34;; print(cat)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;&amp;#128049;&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;整数&quot;&gt;&lt;a href=&quot;#整数&quot; class=&quot;headerlink&quot; title=&quot;整数&quot;&gt;&lt;/a&gt;整数&lt;/h2&gt;&lt;p&gt;整数就是没有小数部分的数字，比如42和-23。整数可以是有符号（正、负、零）或者无符号（正、零）。&lt;/p&gt;
&lt;p&gt;Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是&lt;code&gt;UInt8&lt;/code&gt;，32位有符号整数类型是&lt;code&gt;Int32&lt;/code&gt;。就像 Swift 的其他类型一样，整数类型采用大写命名法。&lt;/p&gt;
&lt;h2 id=&quot;整数范围&quot;&gt;&lt;a href=&quot;#整数范围&quot; class=&quot;headerlink&quot; title=&quot;整数范围&quot;&gt;&lt;/a&gt;整数范围&lt;/h2&gt;&lt;p&gt;你可以访问不同整数类型的&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;属性来获取对应类型的最小值和最大值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let minValue = UInt8.min  // minValue &amp;#20026; 0&amp;#65292;&amp;#26159; UInt8 &amp;#31867;&amp;#22411;&amp;#10;let maxValue = UInt8.max  // maxValue &amp;#20026; 255&amp;#65292;&amp;#26159; UInt8 &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;所传回值的类型，正是其所对的整数类型(如上例&lt;code&gt;UInt8&lt;/code&gt;, 所传回的类型是&lt;code&gt;UInt8&lt;/code&gt;)，可用在表达式中相同类型值旁。&lt;/p&gt;
&lt;h2 id=&quot;Int&quot;&gt;&lt;a href=&quot;#Int&quot; class=&quot;headerlink&quot; title=&quot;Int&quot;&gt;&lt;/a&gt;Int&lt;/h2&gt;&lt;p&gt;一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在32位平台上，&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Int32&lt;/code&gt;长度相同。&lt;/li&gt;
&lt;li&gt;在64位平台上，&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Int64&lt;/code&gt;长度相同。&lt;br&gt;除非你需要特定长度的整数，一般来说使用&lt;code&gt;Int&lt;/code&gt;就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，&lt;code&gt;Int&lt;/code&gt;可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UInt&quot;&gt;&lt;a href=&quot;#UInt&quot; class=&quot;headerlink&quot; title=&quot;UInt&quot;&gt;&lt;/a&gt;UInt&lt;/h2&gt;&lt;p&gt;Swift 也提供了一个特殊的无符号类型&lt;code&gt;UInt&lt;/code&gt;，长度与当前平台的原生字长相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在32位平台上，&lt;code&gt;UInt&lt;/code&gt;和&lt;code&gt;UInt32&lt;/code&gt;长度相同。&lt;/li&gt;
&lt;li&gt;在64位平台上，&lt;code&gt;UInt&lt;/code&gt;和&lt;code&gt;UInt64&lt;/code&gt;长度相同。&lt;blockquote&gt;
&lt;p&gt;注意：尽量不要使用&lt;code&gt;UInt&lt;/code&gt;，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用&lt;code&gt;Int&lt;/code&gt;，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;浮点数&quot;&gt;&lt;a href=&quot;#浮点数&quot; class=&quot;headerlink&quot; title=&quot;浮点数&quot;&gt;&lt;/a&gt;浮点数&lt;/h2&gt;&lt;p&gt;浮点数是有小数部分的数字，比如&lt;code&gt;3.14159&lt;/code&gt;，&lt;code&gt;0.1&lt;/code&gt;和&lt;code&gt;-273.15&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浮点类型比整数类型表示的范围更大，可以存储比&lt;code&gt;Int&lt;/code&gt;类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Double&lt;/code&gt;表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Float&lt;/code&gt;表示32位浮点数。精度要求不高的话可以使用此类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类型安全和类型推断&quot;&gt;&lt;a href=&quot;#类型安全和类型推断&quot; class=&quot;headerlink&quot; title=&quot;类型安全和类型推断&quot;&gt;&lt;/a&gt;类型安全和类型推断&lt;/h2&gt;&lt;p&gt;Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个&lt;code&gt;String&lt;/code&gt;，你绝对不可能不小心传进去一个&lt;code&gt;Int&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。&lt;/p&gt;
&lt;p&gt;当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。&lt;/p&gt;
&lt;p&gt;因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。&lt;/p&gt;
&lt;p&gt;当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如&lt;code&gt;42&lt;/code&gt;和&lt;code&gt;3.14159&lt;/code&gt;。）&lt;/p&gt;
&lt;p&gt;例如，如果你给一个新常量赋值&lt;code&gt;42&lt;/code&gt;并且没有标明类型，Swift 可以推断出常量类型是Int，因为你给它赋的初始值看起来像一个整数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let meaningOfLife = 42&amp;#10;// meaningOfLife &amp;#20250;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Int &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是&lt;code&gt;Double&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let pi = 3.14159&amp;#10;// pi &amp;#20250;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Double &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当推断浮点数的类型时，Swift 总是会选择&lt;code&gt;Double&lt;/code&gt;而不是&lt;code&gt;Float&lt;/code&gt;。&lt;br&gt;如果表达式中同时出现了整数和浮点数，会被推断为&lt;code&gt;Double&lt;/code&gt;类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let anotherPi = 3 + 0.14159&amp;#10;// anotherPi &amp;#20250;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Double &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原始值&lt;code&gt;3&lt;/code&gt;没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为&lt;code&gt;Double&lt;/code&gt;类型。&lt;/p&gt;
&lt;h2 id=&quot;数值型字面量&quot;&gt;&lt;a href=&quot;#数值型字面量&quot; class=&quot;headerlink&quot; title=&quot;数值型字面量&quot;&gt;&lt;/a&gt;数值型字面量&lt;/h2&gt;&lt;p&gt;整数字面量可以被写作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个十进制数，没有前缀&lt;/li&gt;
&lt;li&gt;一个二进制数，前缀是&lt;code&gt;0b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个八进制数，前缀是&lt;code&gt;0o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个十六进制数，前缀是&lt;code&gt;0x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的所有整数字面量的十进制值都是16:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let decimalInteger = 16&amp;#10;let binaryInteger = 0b10000       // &amp;#20108;&amp;#36827;&amp;#21046;&amp;#30340;16&amp;#10;let octalInteger = 0o20           // &amp;#20843;&amp;#36827;&amp;#21046;&amp;#30340;16&amp;#10;let hexadecimalInteger = 0x10     // &amp;#21313;&amp;#20845;&amp;#36827;&amp;#21046;&amp;#30340;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是&lt;code&gt;0x&lt;/code&gt;）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 &lt;code&gt;e&lt;/code&gt; 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 &lt;code&gt;p&lt;/code&gt; 来指定。&lt;br&gt;如果一个十进制数的指数为&lt;code&gt;exp&lt;/code&gt;，那这个数相当于基数和10^exp的乘积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1.25e2&lt;/code&gt; 表示 1.25 × 10^2，等于 &lt;code&gt;125.0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1.25e-2&lt;/code&gt; 表示 1.25 × 10^-2，等于 &lt;code&gt;0.0125&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个十六进制数的指数为&lt;code&gt;exp&lt;/code&gt;，那这个数相当于基数和2^exp的乘积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0xFp2&lt;/code&gt; 表示 15 × 2^2，等于 &lt;code&gt;60.0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0xFp-2&lt;/code&gt; 表示 15 × 2^-2，等于 &lt;code&gt;3.75&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的这些浮点字面量都等于十进制的&lt;code&gt;12.1875&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let decimalDouble = 12.1875&amp;#10;let exponentDouble = 1.21875e1&amp;#10;let hexadecimalDouble = 0xC.3p0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let paddedDouble = 000123.456&amp;#10;let oneMillion = 1_000_000&amp;#10;let justOverOneMillion = 1_000_000.000_000_1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;数值型类型转换&quot;&gt;&lt;a href=&quot;#数值型类型转换&quot; class=&quot;headerlink&quot; title=&quot;数值型类型转换&quot;&gt;&lt;/a&gt;数值型类型转换&lt;/h2&gt;&lt;p&gt;通常来讲，即使代码中的整数常量和变量已知非负，也请使用&lt;code&gt;Int&lt;/code&gt;类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。&lt;/p&gt;
&lt;p&gt;只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。&lt;/p&gt;
&lt;h2 id=&quot;整数转换&quot;&gt;&lt;a href=&quot;#整数转换&quot; class=&quot;headerlink&quot; title=&quot;整数转换&quot;&gt;&lt;/a&gt;整数转换&lt;/h2&gt;&lt;p&gt;不同整数类型的变量和常量可以存储不同范围的数字。&lt;code&gt;Int8&lt;/code&gt;类型的常量或者变量可以存储的数字范围是-128~127，而&lt;code&gt;UInt8&lt;/code&gt;类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let cannotBeNegative: UInt8 = -1&amp;#10;// UInt8 &amp;#31867;&amp;#22411;&amp;#19981;&amp;#33021;&amp;#23384;&amp;#20648;&amp;#36127;&amp;#25968;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#10;let tooBig: Int8 = Int8.max + 1&amp;#10;// Int8 &amp;#31867;&amp;#22411;&amp;#19981;&amp;#33021;&amp;#23384;&amp;#20648;&amp;#36229;&amp;#36807;&amp;#26368;&amp;#22823;&amp;#20540;&amp;#30340;&amp;#25968;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#20250;&amp;#25253;&amp;#38169;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。&lt;/p&gt;
&lt;p&gt;要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量&lt;code&gt;twoThousand&lt;/code&gt;是&lt;code&gt;UInt16&lt;/code&gt;类型，然而常量&lt;code&gt;one&lt;/code&gt;是&lt;code&gt;UInt8&lt;/code&gt;类型。它们不能直接相加，因为它们类型不同。所以要调用&lt;code&gt;UInt16(one)&lt;/code&gt;来创建一个新的&lt;code&gt;UInt16&lt;/code&gt;数字并用&lt;code&gt;one&lt;/code&gt;的值来初始化，然后使用这个新数字来计算：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let twoThousand: UInt16 = 2_000&amp;#10;let one: UInt8 = 1&amp;#10;let twoThousandAndOne = twoThousand + UInt16(one)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在两个数字的类型都是&lt;code&gt;UInt16&lt;/code&gt;，可以进行相加。目标常量&lt;code&gt;twoThousandAndOne&lt;/code&gt;的类型被推断为&lt;code&gt;UInt16&lt;/code&gt;，因为它是两个&lt;code&gt;UInt16&lt;/code&gt;值的和。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SomeType(ofInitialValue)&lt;/code&gt;是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，&lt;code&gt;UInt16&lt;/code&gt;有一个构造器，可以接受一个&lt;code&gt;UInt8&lt;/code&gt;类型的值，所以这个构造器可以用现有的&lt;code&gt;UInt8&lt;/code&gt;来创建一个新的&lt;code&gt;UInt16&lt;/code&gt;。注意，你并不能传入任意类型的值，只能传入&lt;code&gt;UInt16&lt;/code&gt;内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）。&lt;/p&gt;
&lt;h2 id=&quot;整数和浮点数转换&quot;&gt;&lt;a href=&quot;#整数和浮点数转换&quot; class=&quot;headerlink&quot; title=&quot;整数和浮点数转换&quot;&gt;&lt;/a&gt;整数和浮点数转换&lt;/h2&gt;&lt;p&gt;整数和浮点数的转换必须显式指定类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let three = 3&amp;#10;let pointOneFourOneFiveNine = 0.14159&amp;#10;let pi = Double(three) + pointOneFourOneFiveNine&amp;#10;// pi &amp;#31561;&amp;#20110; 3.14159&amp;#65292;&amp;#25152;&amp;#20197;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Double &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中，常量&lt;code&gt;three&lt;/code&gt;的值被用来创建一个&lt;code&gt;Double&lt;/code&gt;类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。&lt;br&gt;浮点数到整数的反向转换同样行，整数类型可以用&lt;code&gt;Double&lt;/code&gt;或者&lt;code&gt;Float&lt;/code&gt;类型来初始化：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let integerPi = Int(pi)&amp;#10;// integerPi &amp;#31561;&amp;#20110; 3&amp;#65292;&amp;#25152;&amp;#20197;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Int &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说&lt;code&gt;4.75&lt;/code&gt;会变成&lt;code&gt;4&lt;/code&gt;，&lt;code&gt;-3.9&lt;/code&gt;会变成&lt;code&gt;-3&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：结合数字类常量和变量不同于结合数字类字面量。字面量&lt;code&gt;3&lt;/code&gt;可以直接和字面量&lt;code&gt;0.14159&lt;/code&gt;相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;类型别名&quot;&gt;&lt;a href=&quot;#类型别名&quot; class=&quot;headerlink&quot; title=&quot;类型别名&quot;&gt;&lt;/a&gt;类型别名&lt;/h2&gt;&lt;p&gt;类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用&lt;code&gt;typealias&lt;/code&gt;关键字来定义类型别名。&lt;/p&gt;
&lt;p&gt;当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typealias AudioSample = UInt16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var maxAmplitudeFound = AudioSample.min&amp;#10;// maxAmplitudeFound &amp;#29616;&amp;#22312;&amp;#26159; 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;本例中，&lt;code&gt;AudioSample&lt;/code&gt;被定义为&lt;code&gt;UInt16&lt;/code&gt;的一个别名。因为它是别名，&lt;code&gt;AudioSample.min&lt;/code&gt;实际上是&lt;code&gt;UInt16.min&lt;/code&gt;，所以会给&lt;code&gt;maxAmplitudeFound&lt;/code&gt;赋一个初值&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;headerlink&quot; title=&quot;布尔值&quot;&gt;&lt;/a&gt;布尔值&lt;/h2&gt;&lt;p&gt;Swift 有一个基本的布尔（Boolean）类型，叫做&lt;code&gt;Bool&lt;/code&gt;。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let orangesAreOrange = true&amp;#10;let turnipsAreDelicious = false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;orangesAreOrange&lt;/code&gt;和&lt;code&gt;turnipsAreDelicious&lt;/code&gt;的类型会被推断为&lt;code&gt;Bool&lt;/code&gt;，因为它们的初值是布尔字面量。就像之前提到的&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Double&lt;/code&gt;一样，如果你创建变量的时候给它们赋值&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;，那你不需要将常量或者变量声明为&lt;code&gt;Bool&lt;/code&gt;类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。&lt;br&gt;当你编写条件语句比如&lt;code&gt;if&lt;/code&gt;语句的时候，布尔值非常有用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if turnipsAreDelicious &amp;#123;&amp;#10;    print(&amp;#34;Mmm, tasty turnips!&amp;#34;)&amp;#10;&amp;#125; else &amp;#123;&amp;#10;    print(&amp;#34;Eww, turnips are horrible.&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;Eww, turnips are horrible.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你在需要使用&lt;code&gt;Bool&lt;/code&gt;类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let i = 1&amp;#10;if i &amp;#123;&amp;#10;    // &amp;#36825;&amp;#20010;&amp;#20363;&amp;#23376;&amp;#19981;&amp;#20250;&amp;#36890;&amp;#36807;&amp;#32534;&amp;#35793;&amp;#65292;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然而，下面的例子是合法的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let i = 1&amp;#10;if i == 1 &amp;#123;&amp;#10;    // &amp;#36825;&amp;#20010;&amp;#20363;&amp;#23376;&amp;#20250;&amp;#32534;&amp;#35793;&amp;#25104;&amp;#21151;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i == 1&lt;/code&gt;的比较结果是&lt;code&gt;Bool&lt;/code&gt;类型，所以第二个例子可以通过类型检查。&lt;/p&gt;
&lt;p&gt;和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。&lt;/p&gt;
&lt;h2 id=&quot;元组&quot;&gt;&lt;a href=&quot;#元组&quot; class=&quot;headerlink&quot; title=&quot;元组&quot;&gt;&lt;/a&gt;元组&lt;/h2&gt;&lt;p&gt;元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。&lt;/p&gt;
&lt;p&gt;下面这个例子中，&lt;code&gt;(404, &amp;quot;Not Found&amp;quot;)&lt;/code&gt;是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个&lt;code&gt;404 Not Found&lt;/code&gt;状态码。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let http404Error = (404, &amp;#34;Not Found&amp;#34;)&amp;#10;// http404Error &amp;#30340;&amp;#31867;&amp;#22411;&amp;#26159; (Int, String)&amp;#65292;&amp;#20540;&amp;#26159; (404, &amp;#34;Not Found&amp;#34;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(404, &amp;quot;Not Found&amp;quot;)&lt;/code&gt;元组把一个&lt;code&gt;Int&lt;/code&gt;值和一个&lt;code&gt;String&lt;/code&gt;值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为&lt;code&gt;(Int, String)&lt;/code&gt;的元组”。&lt;br&gt;你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为&lt;code&gt;(Int, Int, Int)&lt;/code&gt;或者&lt;code&gt;(String, Bool)&lt;/code&gt;或者其他任何你想要的组合的元组。&lt;br&gt;你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let (statusCode, statusMessage) = http404Error&amp;#10;print(&amp;#34;The status code is \(statusCode)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 404&amp;#34;&amp;#10;print(&amp;#34;The status message is \(statusMessage)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status message is Not Found&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（&lt;code&gt;_&lt;/code&gt;）标记：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let (justTheStatusCode, _) = http404Error&amp;#10;print(&amp;#34;The status code is \(justTheStatusCode)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 404&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;#34;The status code is \(http404Error.0)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 404&amp;#34;&amp;#10;print(&amp;#34;The status message is \(http404Error.1)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status message is Not Found&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以在定义元组的时候给单个元素命名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let http200Status = (statusCode: 200, description: &amp;#34;OK&amp;#34;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;给元组中的元素命名后，你可以通过名字来获取这些元素的值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;#34;The status code is \(http200Status.statusCode)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 200&amp;#34;&amp;#10;print(&amp;#34;The status message is \(http200Status.description)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status message is OK&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个&lt;code&gt;(Int, String)&lt;/code&gt;元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可选类型&quot;&gt;&lt;a href=&quot;#可选类型&quot; class=&quot;headerlink&quot; title=&quot;可选类型&quot;&gt;&lt;/a&gt;可选类型&lt;/h2&gt;&lt;p&gt;使用可选类型（optionals）来处理值可能缺失的情况。&lt;br&gt;来看一个例子。Swift 的&lt;code&gt;Int&lt;/code&gt;类型有一种构造器，作用是将一个&lt;code&gt;String&lt;/code&gt;值转换成一个&lt;code&gt;Int&lt;/code&gt;值。然而，并不是所有的字符串都可以转换成一个整数。字符串&lt;code&gt;&amp;quot;123&amp;quot;&lt;/code&gt;可以被转换成数字&lt;code&gt;123&lt;/code&gt;，但是字符串&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;不行。&lt;/p&gt;
&lt;p&gt;下面的例子使用这种构造器来尝试将一个&lt;code&gt;String&lt;/code&gt;转换成&lt;code&gt;Int&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let possibleNumber = &amp;#34;123&amp;#34;&amp;#10;let convertedNumber = Int(possibleNumber)&amp;#10;// convertedNumber &amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026;&amp;#31867;&amp;#22411; &amp;#34;Int?&amp;#34;&amp;#65292; &amp;#25110;&amp;#32773;&amp;#31867;&amp;#22411; &amp;#34;optional Int&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为该构造器可能会失败，所以它返回一个可选类型（optional）&lt;code&gt;Int&lt;/code&gt;，而不是一个&lt;code&gt;Int&lt;/code&gt;。一个可选的&lt;code&gt;Int&lt;/code&gt;被写作&lt;code&gt;Int?&lt;/code&gt;而不是&lt;code&gt;Int&lt;/code&gt;。问号暗示包含的值是可选类型，也就是说可能包含&lt;code&gt;Int&lt;/code&gt;值也可能不包含值。（不能包含其他任何值比如&lt;code&gt;Bool&lt;/code&gt;值或者&lt;code&gt;String&lt;/code&gt;值。只能是    &lt;code&gt;Int&lt;/code&gt;或者什么都没有。）&lt;/p&gt;
&lt;h2 id=&quot;nil&quot;&gt;&lt;a href=&quot;#nil&quot; class=&quot;headerlink&quot; title=&quot;nil&quot;&gt;&lt;/a&gt;nil&lt;/h2&gt;&lt;p&gt;你可以给可选变量赋值为&lt;code&gt;nil&lt;/code&gt;来表示它没有值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var serverResponseCode: Int? = 404&amp;#10;// serverResponseCode &amp;#21253;&amp;#21547;&amp;#19968;&amp;#20010;&amp;#21487;&amp;#36873;&amp;#30340; Int &amp;#20540; 404&amp;#10;serverResponseCode = nil&amp;#10;// serverResponseCode &amp;#29616;&amp;#22312;&amp;#19981;&amp;#21253;&amp;#21547;&amp;#20540;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;nil&lt;/code&gt;不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为&lt;code&gt;nil&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var surveyAnswer: String?&amp;#10;// surveyAnswer &amp;#34987;&amp;#33258;&amp;#21160;&amp;#35774;&amp;#32622;&amp;#20026; nil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：Swift 的&lt;code&gt;nil&lt;/code&gt;和 Objective-C 中的&lt;code&gt;nil&lt;/code&gt;并不一样。在 Objective-C 中，&lt;code&gt;nil&lt;/code&gt;是一个指向不存在对象的指针。在 Swift 中，&lt;code&gt;nil&lt;/code&gt;不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为&lt;code&gt;nil&lt;/code&gt;，不只是对象类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;if-语句以及强制解析&quot;&gt;&lt;a href=&quot;#if-语句以及强制解析&quot; class=&quot;headerlink&quot; title=&quot;if 语句以及强制解析&quot;&gt;&lt;/a&gt;if 语句以及强制解析&lt;/h2&gt;&lt;p&gt;你可以使用&lt;code&gt;if&lt;/code&gt;语句和&lt;code&gt;nil&lt;/code&gt;比较来判断一个可选值是否包含值。你可以使用“相等”(&lt;code&gt;==&lt;/code&gt;)或“不等”(&lt;code&gt;!=&lt;/code&gt;)来执行比较。&lt;/p&gt;
&lt;p&gt;如果可选类型有值，它将不等于&lt;code&gt;nil&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if convertedNumber != nil &amp;#123;&amp;#10;    print(&amp;#34;convertedNumber contains some integer value.&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;convertedNumber contains some integer value.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（&lt;code&gt;!&lt;/code&gt;）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if convertedNumber != nil &amp;#123;&amp;#10;    print(&amp;#34;convertedNumber has an integer value of \(convertedNumber!).&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;convertedNumber has an integer value of 123.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：使用&lt;code&gt;!&lt;/code&gt;来获取一个不存在的可选值会导致运行时错误。使用&lt;code&gt;!&lt;/code&gt;来强制解析值之前，一定要确定可选包含一个非&lt;code&gt;nil&lt;/code&gt;的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可选绑定&quot;&gt;&lt;a href=&quot;#可选绑定&quot; class=&quot;headerlink&quot; title=&quot;可选绑定&quot;&gt;&lt;/a&gt;可选绑定&lt;/h2&gt;&lt;p&gt;使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;while&lt;/code&gt;语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。&lt;/p&gt;
&lt;p&gt;像下面这样在&lt;code&gt;if&lt;/code&gt;语句中写一个可选绑定：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let constantName = someOptional &amp;#123;&amp;#10;    statements&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以像上面这样使用可选绑定来重写&lt;code&gt;possibleNumber&lt;/code&gt;这个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let actualNumber = Int(possibleNumber) &amp;#123;&amp;#10;    print(&amp;#34;\&amp;#39;\(possibleNumber)\&amp;#39; has an integer value of \(actualNumber)&amp;#34;)&amp;#10;&amp;#125; else &amp;#123;&amp;#10;    print(&amp;#34;\&amp;#39;\(possibleNumber)\&amp;#39; could not be converted to an integer&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;&amp;#39;123&amp;#39; has an integer value of 123&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码可以被理解为：“如果&lt;code&gt;Int(possibleNumber)&lt;/code&gt;返回的可选&lt;code&gt;Int&lt;/code&gt;包含一个值，创建一个叫做&lt;code&gt;actualNumber&lt;/code&gt;的新常量并将可选包含的值赋给它。”&lt;/p&gt;
&lt;p&gt;如果转换成功，&lt;code&gt;actualNumber&lt;/code&gt;常量可以在&lt;code&gt;if&lt;/code&gt;语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，&lt;code&gt;actualNumber&lt;/code&gt;只被用来输出转换结果。&lt;/p&gt;
&lt;p&gt;你可以在可选绑定中使用常量和变量。如果你想在&lt;code&gt;if&lt;/code&gt;语句的第一个分支中操作&lt;code&gt;actualNumber&lt;/code&gt;的值，你可以改成&lt;code&gt;if var actualNumber&lt;/code&gt;，这样可选类型包含的值就会被赋给一个变量而非常量。&lt;/p&gt;
&lt;p&gt;你可以包含多个可选绑定在&lt;code&gt;if&lt;/code&gt;语句中，并使用&lt;code&gt;where&lt;/code&gt;子句做布尔值判断。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let firstNumber = Int(&amp;#34;4&amp;#34;), secondNumber = Int(&amp;#34;42&amp;#34;) where firstNumber &amp;#60; secondNumber &amp;#123;&amp;#10;    print(&amp;#34;\(firstNumber) &amp;#60; \(secondNumber)&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// prints &amp;#34;4 &amp;#60; 42&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;隐式解析可选类型&quot;&gt;&lt;a href=&quot;#隐式解析可选类型&quot; class=&quot;headerlink&quot; title=&quot;隐式解析可选类型&quot;&gt;&lt;/a&gt;隐式解析可选类型&lt;/h2&gt;&lt;p&gt;如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过if语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。&lt;/p&gt;
&lt;p&gt;有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型&lt;em&gt;总会&lt;/em&gt;有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。&lt;/p&gt;
&lt;p&gt;这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（&lt;code&gt;String?&lt;/code&gt;）改成感叹号（&lt;code&gt;String!&lt;/code&gt;）来声明一个隐式解析可选类型。&lt;/p&gt;
&lt;p&gt;当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。&lt;/p&gt;
&lt;p&gt;一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型&lt;code&gt;String&lt;/code&gt;和隐式解析可选类型&lt;code&gt;String&lt;/code&gt;之间的区别：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let possibleString: String? = &amp;#34;An optional string.&amp;#34;&amp;#10;let forcedString: String = possibleString! // &amp;#38656;&amp;#35201;&amp;#24778;&amp;#21497;&amp;#21495;&amp;#26469;&amp;#33719;&amp;#21462;&amp;#20540;&amp;#10;&amp;#10;let assumedString: String! = &amp;#34;An implicitly unwrapped optional string.&amp;#34;&amp;#10;let implicitString: String = assumedString  // &amp;#19981;&amp;#38656;&amp;#35201;&amp;#24863;&amp;#21497;&amp;#21495;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if assumedString != nil &amp;#123;&amp;#10;    print(assumedString)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;An implicitly unwrapped optional string.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let definiteString = assumedString &amp;#123;&amp;#10;    print(definiteString)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;An implicitly unwrapped optional string.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果一个变量之后可能变成&lt;code&gt;nil&lt;/code&gt;的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是&lt;code&gt;nil&lt;/code&gt;的话，请使用普通可选类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h2&gt;&lt;p&gt;你可以使用错误处理（error handling）来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func canThrowAnError() throws &amp;#123;&amp;#10;    // &amp;#36825;&amp;#20010;&amp;#20989;&amp;#25968;&amp;#26377;&amp;#21487;&amp;#33021;&amp;#25243;&amp;#20986;&amp;#38169;&amp;#35823;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个函数可以通过在声明中添加&lt;code&gt;throws&lt;/code&gt;关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置&lt;code&gt;try&lt;/code&gt;关键词。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;do &amp;#123;&amp;#10;    try canThrowAnError()&amp;#10;    // &amp;#27809;&amp;#26377;&amp;#38169;&amp;#35823;&amp;#28040;&amp;#24687;&amp;#25243;&amp;#20986;&amp;#10;&amp;#125; catch &amp;#123;&amp;#10;    // &amp;#26377;&amp;#19968;&amp;#20010;&amp;#38169;&amp;#35823;&amp;#28040;&amp;#24687;&amp;#25243;&amp;#20986;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;do&lt;/code&gt;语句创建了一个新的包含作用域,使得错误能被传播到一个或多个&lt;code&gt;catch&lt;/code&gt;从句。&lt;br&gt;这里有一个错误处理如何用来应对不同错误条件的例子。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func makeASandwich() throws &amp;#123;&amp;#10;    // ...&amp;#10;&amp;#125;&amp;#10;&amp;#10;do &amp;#123;&amp;#10;    try makeASandwich()&amp;#10;    eatASandwich()&amp;#10;&amp;#125; catch Error.OutOfCleanDishes &amp;#123;&amp;#10;    washDishes()&amp;#10;&amp;#125; catch Error.MissingIngredients(let ingredients) &amp;#123;&amp;#10;    buyGroceries(ingredients)&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在此例中，&lt;code&gt;makeASandwich()&lt;/code&gt;（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为&lt;code&gt;makeASandwich()&lt;/code&gt;抛出错误，函数调用被包裹在&lt;code&gt;try&lt;/code&gt;表达式中。将函数包裹在一个&lt;code&gt;do&lt;/code&gt;语句中,任何被抛出的错误会被传播到提供的&lt;code&gt;catch&lt;/code&gt;从句中。&lt;/p&gt;
&lt;p&gt;如果没有错误被抛出, &lt;code&gt;eatASandwich()&lt;/code&gt;函数会被调用。如果一个匹配&lt;code&gt;Error.OutOfCleanDishes&lt;/code&gt;的错误被抛出,&lt;code&gt;washDishes&lt;/code&gt;函数会被调用。如果一个匹配&lt;code&gt;Error.MissingIngredients&lt;/code&gt;的错误被抛出，&lt;code&gt;buyGroceries(_:)&lt;/code&gt;函数会随着被&lt;code&gt;catch&lt;/code&gt;所捕捉到的关联值[&lt;code&gt;String&lt;/code&gt;]被调用。&lt;/p&gt;
&lt;h2 id=&quot;断言&quot;&gt;&lt;a href=&quot;#断言&quot; class=&quot;headerlink&quot; title=&quot;断言&quot;&gt;&lt;/a&gt;断言&lt;/h2&gt;&lt;p&gt;可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个断言（assertion）来结束代码运行并通过调试来找到值缺失的原因。&lt;/p&gt;
&lt;h2 id=&quot;使用断言进行调试&quot;&gt;&lt;a href=&quot;#使用断言进行调试&quot; class=&quot;headerlink&quot; title=&quot;使用断言进行调试&quot;&gt;&lt;/a&gt;使用断言进行调试&lt;/h2&gt;&lt;p&gt;断言会在运行时判断一个逻辑条件是否为&lt;code&gt;true&lt;/code&gt;。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为&lt;code&gt;true&lt;/code&gt;，代码运行会继续进行；如果条件判断为&lt;code&gt;false&lt;/code&gt;，代码执行结束，你的应用被终止。&lt;/p&gt;
&lt;p&gt;如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。&lt;/p&gt;
&lt;p&gt;你可以使用全局&lt;code&gt;assert(_:_file:line:)&lt;/code&gt;函数来写一个断言。向这个函数传入一个结果为&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;的表达式以及一条信息，当表达式的结果为&lt;code&gt;false&lt;/code&gt;的时候这条信息会被显示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let age = -3&amp;#10;assert(age &amp;#62;= 0, &amp;#34;A person&amp;#39;s age cannot be less than zero&amp;#34;)&amp;#10;// &amp;#22240;&amp;#20026; age &amp;#60; 0&amp;#65292;&amp;#25152;&amp;#20197;&amp;#26029;&amp;#35328;&amp;#20250;&amp;#35302;&amp;#21457;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，只有&lt;code&gt;age &amp;gt;= 0&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;的时候，即&lt;code&gt;age&lt;/code&gt;的值非负的时候，代码才会继续执行。如果&lt;code&gt;age&lt;/code&gt;的值是负数，就像代码中那样，&lt;code&gt;age &amp;gt;= 0为false&lt;/code&gt;，断言被触发，终止应用。&lt;/p&gt;
&lt;p&gt;如果不需要断言信息，可以省略，就像这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;assert(age &amp;#62;= 0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;何时使用断言&quot;&gt;&lt;a href=&quot;#何时使用断言&quot; class=&quot;headerlink&quot; title=&quot;何时使用断言&quot;&gt;&lt;/a&gt;何时使用断言&lt;/h2&gt;&lt;p&gt;当条件可能为假时使用断言，但是最终一定要&lt;em&gt;保证&lt;/em&gt;条件为真，这样你的代码才能继续运行。断言的适用情景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。&lt;/li&gt;
&lt;li&gt;需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。&lt;/li&gt;
&lt;li&gt;一个可选值现在是&lt;code&gt;nil&lt;/code&gt;，但是后面的代码运行需要一个非&lt;code&gt;nil&lt;/code&gt;值。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所有知识都来至于网上以及官方的学习资料，本文不做任何商业用途，只是自己的一个学习笔记，如有侵权请及时告知我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言(传说以后还可以用于开始Android应用)。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的（如果没有 C 或者 Objective-C 相关开发经验也没有关系，大家都说Swift比较通俗易懂更加容易上手）。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift学习笔记" scheme="http://www.jvaeyhcd.cc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Mac基础：如何让Finder显示隐藏文件和文件夹</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/28/Mac%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9Finder%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/</id>
    <published>2016-04-28T01:43:25.000Z</published>
    <updated>2016-04-28T07:27:34.000Z</updated>
    
    <content type="html">&lt;p&gt;有些人中喜欢折腾一些奇怪的东西（比如说我），使用git已经很长一段时间了，但是最近才发现在Finder中找不到.git的文件夹。原来这个东西是被隐藏了，那么现在问题来了，我要将隐藏的文件或者文件夹显示出来应该如何做呢？&lt;/p&gt;
&lt;h2 id=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;a href=&quot;#让Finder显示隐藏文件和文件夹&quot; class=&quot;headerlink&quot; title=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;/a&gt;让Finder显示隐藏文件和文件夹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;b&gt;第一步：&lt;/b&gt;打开「终端」应用程序（我推荐使用&lt;a href=&quot;https://www.iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iTerm&lt;/a&gt;,他比Mac自带终端好用很多）。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;第二步：&lt;/b&gt;输入如下命令，如图一所示：&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/bash.png&quot; alt=&quot;图一&quot; title=&quot;图一&quot;&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles -boolean &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//OS X Mountain Lion 和早期版本命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;第三步：&lt;/b&gt;按下「Return」键确认。&lt;br&gt;现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。如图二所示：&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/finder.png&quot; alt=&quot;图二&quot; title=&quot;图二&quot;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;让Finder隐藏隐藏文件和文件夹&quot;&gt;&lt;a href=&quot;#让Finder隐藏隐藏文件和文件夹&quot; class=&quot;headerlink&quot; title=&quot;让Finder隐藏隐藏文件和文件夹&quot;&gt;&lt;/a&gt;让Finder隐藏隐藏文件和文件夹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只需要一步&lt;br&gt;如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成（图三）即可。&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/show.png&quot; alt=&quot;图三&quot; title=&quot;图三&quot;&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles -boolean &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//OS X Mountain Lion 和早期版本命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles FALSE ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后看到的效果如图四所示：&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/hidefinder.png&quot; alt=&quot;图四&quot; title=&quot;图四&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;有些人中喜欢折腾一些奇怪的东西（比如说我），使用git已经很长一段时间了，但是最近才发现在Finder中找不到.git的文件夹。原来这个东西是被隐藏了，那么现在问题来了，我要将隐藏的文件或者文件夹显示出来应该如何做呢？&lt;/p&gt;
&lt;h2 id=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;a href=&quot;#让Finder显示隐藏文件和文件夹&quot; class=&quot;headerlink&quot; title=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;/a&gt;让Finder显示隐藏文件和文件夹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;b&gt;第一步：&lt;/b&gt;打开「终端」应用程序（我推荐使用&lt;a href=&quot;https://www.iterm2.com/&quot;&gt;iTerm&lt;/a&gt;,他比Mac自带终端好用很多）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mac基础" scheme="http://www.jvaeyhcd.cc/categories/Mac%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Mac" scheme="http://www.jvaeyhcd.cc/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Failed to Locate or Generate Matchin Signing Assets</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/</id>
    <published>2016-04-18T08:58:38.000Z</published>
    <updated>2016-04-27T11:33:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;刚开始还是好好的，突然就出现了标题的提示错误，首先签名是正确的，App ID也没有被占用的，但是在导出ipa的时候一直出现“Failed to locate or generate matchin signing assets”的提示信息。我也是醉得不行，有时能成功，有时不行，不知道苹果在搞什么鬼（不管他在搞什么，出现问题，还是不要一味的去抱怨，找解决办法才是真的）。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/problem.png&quot; alt=&quot;问题详情&quot; title=&quot;问题详情&quot;&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;如何解决&quot;&gt;&lt;a href=&quot;#如何解决&quot; class=&quot;headerlink&quot; title=&quot;如何解决&quot;&gt;&lt;/a&gt;如何解决&lt;/h2&gt;&lt;p&gt;还是Google大法好，一下就找到了解决办法。&lt;/p&gt;
&lt;p&gt;以下是我在网上找到了解决办法的详细步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先创建一个文件夹，名字就叫Payload，&lt;a style=&quot;color:#4cc190&quot;&gt;一定要是Payload&lt;/a&gt;（如果你不信，可以换一个名字试试）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后在Organizer中然后把 archive 出来的那个在 finder 打开。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/export.png&quot; alt=&quot;Organizer中显示&quot; title=&quot;Organizer中显示&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后点击显示包内容。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/show_in_finder.png&quot; alt=&quot;在Finder中显示&quot; title=&quot;在Finder中显示&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把app 和 dsym 那两个文件拷贝到 Payload文件夹中。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/product.png&quot; alt=&quot;product文件目录&quot; title=&quot;product文件目录&quot;&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/dSYMs.png&quot; alt=&quot;dSYMs文件目录&quot; title=&quot;dSYMs文件目录&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后对Payload压缩&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/zip.png&quot; alt=&quot;Payload压缩&quot; title=&quot;Payload压缩&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后将Playload.zip的后缀名改成ipa即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的方法完全可以解决无法导出ipa的问题，但是导出ipa比export出来的包要大一些。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;刚开始还是好好的，突然就出现了标题的提示错误，首先签名是正确的，App ID也没有被占用的，但是在导出ipa的时候一直出现“Failed to locate or generate matchin signing assets”的提示信息。我也是醉得不行，有时能成功，有时不行，不知道苹果在搞什么鬼（不管他在搞什么，出现问题，还是不要一味的去抱怨，找解决办法才是真的）。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/problem.png&quot; alt=&quot;问题详情&quot; title=&quot;问题详情&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift开源项目汇总</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/11/Swift%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/11/Swift开源项目汇总/</id>
    <published>2016-04-11T07:06:52.000Z</published>
    <updated>2016-05-21T07:32:52.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;拥有着苹果先天生态优势的Swift自发布以来，各种优秀的开源项目便层出不穷。我站在个人的角度，将Swift开源项目做了一个甄别、筛选，从工具、存储、网络、界面、框架到Demo以及完整应用等，满满的干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然现在对Swift还停留在入门水平，但是还是觉得有必要去网上收集一些优秀的Swift开源项目。&lt;/p&gt;
&lt;h2 id=&quot;界面类&quot;&gt;&lt;a href=&quot;#界面类&quot; class=&quot;headerlink&quot; title=&quot;界面类&quot;&gt;&lt;/a&gt;界面类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/raulriera/TextFieldEffects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TextFieldEffects&lt;/a&gt;&lt;br&gt;你不觉得标准的UITextField有一点无聊吗？我也是——所以对TextFieldEffects说hello吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/FahimF/FloatLabelFields&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FloatLabelFields&lt;/a&gt;&lt;br&gt;带浮动标签的输入框&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MortimerGoro/MGSwipeTableCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MGSwipeTableCell&lt;/a&gt;&lt;br&gt;另一个UI组件，在很多app里都常见，苹果应该考虑在iOS标准库里加入类似的东西。可滑动的table cell，这是这个pod最好的描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/lexrus/LTMorphingLabel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LTMorphingLabel&lt;/a&gt;&lt;br&gt;有超赞特效效果的Label&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ephread/Instructions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Instructions&lt;/a&gt;&lt;br&gt;操作指引框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mamaral/Onboard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Onboard&lt;/a&gt;&lt;br&gt;启动导航界面，很方便的集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapKit&lt;/a&gt;&lt;br&gt;Swift布局框架 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;工具类&quot;&gt;&lt;a href=&quot;#工具类&quot; class=&quot;headerlink&quot; title=&quot;工具类&quot;&gt;&lt;/a&gt;工具类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nickoneill/PermissionScope&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PermissionScope&lt;/a&gt;&lt;br&gt;用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—&amp;gt;更多活跃用户-&amp;gt;更高的留存率-&amp;gt;数据更好-&amp;gt;下载率更高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Quick/Quick&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Quick&lt;/a&gt;&lt;br&gt;Swift里的单元测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/saturngod/IAPHelper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IAPHelper&lt;/a&gt;&lt;br&gt;app内购带给我们很多陈词滥调的代码，用这个库就不需要了，把最有关交易金钱的普遍的任务从iOS用户到你的（或者你的公司的）钱包简单包装起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SwiftyJSON/SwiftyJSON&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwiftyJSON&lt;/a&gt;&lt;br&gt;GitHub上最为开发者认可的JSON解析类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ankurp/Dollar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dollar&lt;/a&gt;&lt;br&gt;Swift版Lo-Dash(或underscore)函数式工具库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/DaveWoodCom/XCGLogger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XCGLogger&lt;/a&gt;&lt;br&gt;功能完整的日志管理类库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mattt/Surge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Surge&lt;/a&gt;&lt;br&gt;基于苹果Accelerate高性能计算框架封装库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/duemunk/Async&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Async&lt;/a&gt;&lt;br&gt;简洁的后台执行代码封装库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ArtSabintsev/Siren&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Siren&lt;/a&gt;&lt;br&gt;当应用更新时，通知用户并提供App Store链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Thomvis/BrightFutures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BrightFutures&lt;/a&gt;&lt;br&gt;漫长或复杂计算由独立线程异步来完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tadija/AEXML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AEXML&lt;/a&gt;&lt;br&gt;简单又易于的XML解析类及示例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/andreamazz/AMScrollingNavbar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AMScrollingNavbar&lt;/a&gt;&lt;br&gt;swift语言编写 上下滑动时动态隐藏标题栏&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;存储类&quot;&gt;&lt;a href=&quot;#存储类&quot; class=&quot;headerlink&quot; title=&quot;存储类&quot;&gt;&lt;/a&gt;存储类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stephencelis/SQLite.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SQLite.swift&lt;/a&gt;&lt;br&gt;swift版本简单、轻量，使用上最SQL的SQLite封装库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;网络类&quot;&gt;&lt;a href=&quot;#网络类&quot; class=&quot;headerlink&quot; title=&quot;网络类&quot;&gt;&lt;/a&gt;网络类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Alamofire/Alamofire&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alamofire&lt;/a&gt;&lt;br&gt;AFNetworking网络基础库Swift语言版&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/RxSwiftCommunity/RxAlamofire&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RxAlamofire&lt;/a&gt;&lt;br&gt;对 Alamofire的封装，很是强大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础工具类以及Category&quot;&gt;&lt;a href=&quot;#基础工具类以及Category&quot; class=&quot;headerlink&quot; title=&quot;基础工具类以及Category&quot;&gt;&lt;/a&gt;基础工具类以及Category&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/FabrizioBrancati/BFKit-Swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BFKit Swift版本&lt;/a&gt;&lt;br&gt;国外的一个大神写的很好用的分类，比较齐全&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;图片类&quot;&gt;&lt;a href=&quot;#图片类&quot; class=&quot;headerlink&quot; title=&quot;图片类&quot;&gt;&lt;/a&gt;图片类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Alamofire/AlamofireImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AlamofireImage&lt;/a&gt;&lt;br&gt;swift版本的SDWebImage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kaishin/ImageScout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageScout&lt;/a&gt;&lt;br&gt;最小网络代价获得图片大小及类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/indragiek/DominantColor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DominantColor&lt;/a&gt;&lt;br&gt;提取图片主色示例项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gavinbunney/Toucan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Toucan&lt;/a&gt;&lt;br&gt;小而美的图片变换及处理类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kaishin/gifu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gifu&lt;/a&gt;&lt;br&gt;高性能GIF显示类库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Haneke/HanekeSwift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HanekeSwift&lt;/a&gt;&lt;br&gt;轻量带缓存高性能图片加载组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;框架类&quot;&gt;&lt;a href=&quot;#框架类&quot; class=&quot;headerlink&quot; title=&quot;框架类&quot;&gt;&lt;/a&gt;框架类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa&lt;/a&gt;&lt;br&gt;ReactiveCocoa带给我们一种完全不同的编程方式/结构，基于值的信号和流。这是完全的头脑风暴，首先你需要忘记你曾经学习的来理解它是如何工作的。这不是一个简单的任务，但是是有回报的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MengTo/Spring&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/robb/Cartography&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cartography&lt;/a&gt;&lt;br&gt;基于代码级的自动布局封装框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mutualmobile/MMWormhole&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MMWormhole&lt;/a&gt;&lt;br&gt;iOS扩展与宿主应用的通讯框架&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;示例项目&quot;&gt;&lt;a href=&quot;#示例项目&quot; class=&quot;headerlink&quot; title=&quot;示例项目&quot;&gt;&lt;/a&gt;示例项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ochococo/Design-Patterns-In-Swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Design-Patterns-In-Swift&lt;/a&gt;&lt;br&gt;如何使用常用设计模式及示例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/robb/hamburger-button&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hamburger-button&lt;/a&gt;&lt;br&gt;无论设计还是代码，都进行了精雕细琢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;完整项目&quot;&gt;&lt;a href=&quot;#完整项目&quot; class=&quot;headerlink&quot; title=&quot;完整项目&quot;&gt;&lt;/a&gt;完整项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tnantoka/edhita&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;edhita&lt;/a&gt;&lt;br&gt;支持Markdown, HTML预览的文本编辑器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mozilla/firefox-ios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;firefox-ios&lt;/a&gt;&lt;br&gt;来自Mozilla开发团队大型纯Swift项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JakeLin/SwiftWeather&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwiftWeather&lt;/a&gt;&lt;br&gt;清新淡雅持续改进天气预报项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;拥有着苹果先天生态优势的Swift自发布以来，各种优秀的开源项目便层出不穷。我站在个人的角度，将Swift开源项目做了一个甄别、筛选，从工具、存储、网络、界面、框架到Demo以及完整应用等，满满的干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然现在对Swift还停留在入门水平，但是还是觉得有必要去网上收集一些优秀的Swift开源项目。&lt;/p&gt;
&lt;h2 id=&quot;界面类&quot;&gt;&lt;a href=&quot;#界面类&quot; class=&quot;headerlink&quot; title=&quot;界面类&quot;&gt;&lt;/a&gt;界面类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/raulriera/TextFieldEffects&quot;&gt;TextFieldEffects&lt;/a&gt;&lt;br&gt;你不觉得标准的UITextField有一点无聊吗？我也是——所以对TextFieldEffects说hello吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/FahimF/FloatLabelFields&quot;&gt;FloatLabelFields&lt;/a&gt;&lt;br&gt;带浮动标签的输入框&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中造成dealloc不调用的原因</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/06/iOS%E4%B8%AD%E9%80%A0%E6%88%90dealloc%E4%B8%8D%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/06/iOS中造成dealloc不调用的原因/</id>
    <published>2016-04-06T04:18:32.000Z</published>
    <updated>2016-04-27T10:58:58.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc &amp;#123;&amp;#10;    [_mapView release];&amp;#10;    [super dealloc];&amp;#10;&amp;#125;&amp;#10;&amp;#10;//&amp;#24182;&amp;#19988;&amp;#22312;&amp;#30028;&amp;#38754;&amp;#23558;&amp;#35201;&amp;#26174;&amp;#31034;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#35774;&amp;#32622;&amp;#20195;&amp;#29702;&amp;#65292;&amp;#23558;&amp;#35201;&amp;#28040;&amp;#22833;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#21462;&amp;#28040;&amp;#20195;&amp;#29702;&amp;#10;- (void)viewWillAppear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)viewWillDisappear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = nil;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;以上给出的方法确实是对的，可以解决反复切换地图页面和地图上一级页面内存暴增造成的闪退问题。但是这里要说的不是这个问题，而是一个新的问题，我在dealloc中打了断点，但是dealloc根本就没有执行，所以mapView也就根本就没有释放，内存还是一样在暴增。为什么ViewController已经被pop了，而ViewController的dealloc方法却没有被调用？（按理说ViewController被pop的时候它的dealloc的方法应该被调用才对）。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;通过Google搜索终于在晚上找到了答案（大家就不要用百度，想要快速准确的找到自己想要的答案推荐大家用google）。造成ViewController不释放的原因可能有很多。遇到dealloc不调用的时候只需要检查您的ViewController中是否存在以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;ViewController中存在NSTimer&lt;/b&gt;&lt;/p&gt;
&lt;p&gt; 如果你的ViewController中有NSTimer，那么你就要注意了，因为当你调用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[NSTimer scheduledTimerWithTimeInterval:1.0 &amp;#10;                                 target:self &amp;#10;                               selector:@selector(updateTime:) &amp;#10;                               userInfo:nil &amp;#10;                                repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 时，这个&lt;a style=&quot;color: #FF00EE&quot;&gt;target:self&lt;/a&gt;就增加了ViewController的return count，如果你不将这个timer invalidate，将别想调用dealloc。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;ViewController中有关的代理&lt;/b&gt;&lt;/p&gt;
&lt;p&gt; 一个比较隐秘的因素，你去找找与这个类有关的代理，有没有强引用属性？比如一个代理的delegate应该是 assign 的现在是retain，(╯‵□′)╯︵┻━┻，就是这个，它会影响你不让你调用dealloc，不信，就试试吧。（这个我还没有遇到过）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;ViewController中有Block&lt;/b&gt;&lt;/p&gt;
&lt;p&gt; 这个就是我我上面不进入dealloc的真正原因，Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。&lt;br&gt; 例如你这个类叫OneViewController,有个属性是NSString *name; 如果你在block体中使用了self.name，那样子的话这个类就没法释放。&lt;br&gt; 要解决这个问题，MRC下只需&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block Viewcontroller *weakSelf = self;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; ARC下将&lt;strong&gt;block 换为 &lt;/strong&gt;weak&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前我所知道的就以上三种情况，如果有什么错误的地方或者还存在的一些情况，欢迎大家来补充。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc &amp;#123;&amp;#10;    [_mapView release];&amp;#10;    [super dealloc];&amp;#10;&amp;#125;&amp;#10;&amp;#10;//&amp;#24182;&amp;#19988;&amp;#22312;&amp;#30028;&amp;#38754;&amp;#23558;&amp;#35201;&amp;#26174;&amp;#31034;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#35774;&amp;#32622;&amp;#20195;&amp;#29702;&amp;#65292;&amp;#23558;&amp;#35201;&amp;#28040;&amp;#22833;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#21462;&amp;#28040;&amp;#20195;&amp;#29702;&amp;#10;- (void)viewWillAppear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)viewWillDisappear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = nil;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于UItableView的复用</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/05/%E5%85%B3%E4%BA%8EUItableView%E7%9A%84%E5%A4%8D%E7%94%A8/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/05/关于UItableView的复用/</id>
    <published>2016-04-05T01:26:44.000Z</published>
    <updated>2016-04-27T11:00:19.000Z</updated>
    
    <content type="html">&lt;p&gt;UITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;关于UItableView的复用机制大概是这样的：假设一个UItableView要加载10000条数据，但是一个屏幕最大只能展示3条数据（这里屏幕最多能展示的数据条数是根据UItableViewCell的高度来定的）。然后当你向上滑动，想要查看更多的内容，那么肯定需要一个cell放在已经存在的内容下边。这个时候并不会重新去创建一个UItableViewCell放在下面，而是根据cellIdetifier去内存池中拿到与之对应的UItableViewCell。&lt;/p&gt;
&lt;h2 id=&quot;复用方式&quot;&gt;&lt;a href=&quot;#复用方式&quot; class=&quot;headerlink&quot; title=&quot;复用方式&quot;&gt;&lt;/a&gt;复用方式&lt;/h2&gt;&lt;p&gt;UItableView的复用方式有如下四种方式实现&lt;/p&gt;
&lt;p&gt;方式一:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UITableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];  &amp;#10;if (!cell) &amp;#123;&amp;#10;&amp;#9;cell=[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方式二:UItableViewCell是xib写的&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XXXTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  &amp;#10;if (nil == cell) &amp;#123;  &amp;#10;    cell = [[[NSBundle mainBundle]loadNibNamed:@&amp;#34;XXXTableViewCell&amp;#34; owner:self options:nil]lastObject];  &amp;#10;    cell.selectionStyle=UITableViewCellSelectionStyleNone;  &amp;#10;    [tableView registerNib:[UINib nibWithNibName:@&amp;#34;XXXTableViewCell&amp;#34; bundle:[NSBundle mainBundle]] forCellReuseIdentifier:cellIdentifier];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方式三:在xib中identifier属性必须写上cellIdentifier ,对应代码中的cellIdentifier&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XXTableViewCell *cell;  &amp;#10;cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  &amp;#10;if (nil == cell) &amp;#123;  &amp;#10;    cell= [[[NSBundle mainBundle] loadNibNamed:@&amp;#34;XXTableViewCell&amp;#34; owner:nil options:nil] lastObject];  &amp;#10;&amp;#125;  &amp;#10;return cell;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方式四：先register cell，然后复用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - &amp;#21021;&amp;#22987;&amp;#21270;&amp;#25511;&amp;#20214;&amp;#10;&amp;#10;- (UITableView *)tableView&amp;#10;&amp;#123;&amp;#10;    if (!_tableView) &amp;#123;&amp;#10;        _tableView = [[UITableView alloc]initWithFrame:self.frame style:UITableViewStylePlain];&amp;#10;        _tableView.backgroundColor = kMainBgColor;&amp;#10;        _tableView.dataSource = self;&amp;#10;        _tableView.delegate = self;&amp;#10;        _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;&amp;#10;        [_tableView registerClass:[XXXCell_iPhone class] forCellReuseIdentifier:kCellIdentifier_XXXCell];&amp;#10;        _tableView.tableFooterView = self.loadingFooterView;&amp;#10;    &amp;#125;&amp;#10;    return _tableView;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&amp;#10;&amp;#123;&amp;#10;&amp;#9;//&amp;#22797;&amp;#29992;&amp;#10;    XXXCell_iPhone *cell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier_XXXCell forIndexPath:indexPath];&amp;#10;    cell.type = self.type;&amp;#10;    [cell setExpressOrder:[_list safeObjectAtIndex:indexPath.row] needTopView:indexPath.row == 0];&amp;#10;    return cell;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://www.jvaeyhcd.cc/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.jvaeyhcd.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于iOS多线程小记</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/30/%E5%85%B3%E4%BA%8EiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%8F%E8%AE%B0/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/30/关于iOS多线程小记/</id>
    <published>2016-03-30T03:42:06.000Z</published>
    <updated>2016-04-27T11:12:17.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程间不能共享内存，但线程间共享内存非常容易。&lt;/li&gt;
&lt;li&gt;系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在实际开发过程中多线程是非常有用的，假如用户点击界面上某个按钮的时候，该按钮需要执行的任务需要耗时很长，如果我们直接在UI线程中完成这个任务，在该任务执行完成返回之前，UI线程被该任务阻塞，将无法再相应用户的其它操作。在这段时间内用户对界面上的任何操作将不会被相应（除非按Home键返回），这并不是我们希望看到的结果。一般这个时候我们能够想到的办法就是将耗时的操作放到非UI线程（开启一个线程）中完成，这样UI线程就不会被阻塞，应用也就不会失去相应。&lt;/p&gt;
&lt;p&gt;iOS系统大致提供了如下3种实现多线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSThread&lt;/li&gt;
&lt;li&gt;NSOperation和NSOperationQueue&lt;/li&gt;
&lt;li&gt;GCD(Grand Central Dispatch)&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程间不能共享内存，但线程间共享内存非常容易。&lt;/li&gt;
&lt;li&gt;系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://www.jvaeyhcd.cc/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.jvaeyhcd.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS上完美编译FFmpeg</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/28/iOS%E4%B8%8A%E5%AE%8C%E7%BE%8E%E7%BC%96%E8%AF%91FFmpeg/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/28/iOS上完美编译FFmpeg/</id>
    <published>2016-03-28T13:50:00.000Z</published>
    <updated>2016-04-27T11:01:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Undefined symbols for architecture arm64:&amp;#10;  &amp;#34;_avcodec_close&amp;#34;, referenced from:&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_init_packet&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_av_malloc&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CreateYUVTab_16() in H264Decoder.o&amp;#10;  &amp;#34;_av_free&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DeleteYUVTab() in H264Decoder.o&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_register_all&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_find_decoder&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_decode_video2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_open2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_context3&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_frame&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;ld: symbol(s) not found for architecture arm64&amp;#10;clang: error: linker command failed with exit code 1 (use -v to see invocation)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;解决办法，直接上图&lt;/p&gt;
&lt;img src=&quot;/2016/03/28/iOS上完美编译FFmpeg/1.png&quot; alt=&quot;解决办法&quot; title=&quot;解决办法&quot;&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Undefined symbols for architecture arm64:&amp;#10;  &amp;#34;_avcodec_close&amp;#34;, referenced from:&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_init_packet&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_av_malloc&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CreateYUVTab_16() in H264Decoder.o&amp;#10;  &amp;#34;_av_free&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DeleteYUVTab() in H264Decoder.o&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_register_all&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_find_decoder&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_decode_video2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_open2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_context3&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_frame&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;ld: symbol(s) not found for architecture arm64&amp;#10;clang: error: linker command failed with exit code 1 (use -v to see invocation)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS UIWebView简单使用</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/26/iOS-UIWebView%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/26/iOS-UIWebView简单使用/</id>
    <published>2016-03-26T07:44:12.000Z</published>
    <updated>2016-03-26T08:51:41.000Z</updated>
    
    <content type="html">&lt;p&gt;UIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。&lt;/p&gt;
&lt;p&gt;下面我想简单记录一下UIWebView的简单使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建UIWebView&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGRect bouds = [[UIScreen manScreen]applicationFrame];  &amp;#10;UIWebView* webView = [[UIWebView alloc]initWithFrame:bounds];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;webView.scalespageToFit = YES;&amp;#9;    //&amp;#33258;&amp;#21160;&amp;#23545;&amp;#39029;&amp;#38754;&amp;#36827;&amp;#34892;&amp;#32553;&amp;#25918;&amp;#20197;&amp;#36866;&amp;#24212;&amp;#23631;&amp;#24149;  &amp;#10;webView.detectsPhoneNumbers = YES;  //&amp;#33258;&amp;#21160;&amp;#26816;&amp;#27979;&amp;#32593;&amp;#39029;&amp;#19978;&amp;#30340;&amp;#30005;&amp;#35805;&amp;#21495;&amp;#30721;&amp;#65292;&amp;#21333;&amp;#20987;&amp;#21487;&amp;#20197;&amp;#25320;&amp;#25171;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;显示UIWebView到UIViewController上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:webView];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加载内容&lt;/p&gt;
&lt;p&gt; 加载一个完整的网页的内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL* url = [NSURL URLWithString:@&amp;#34;http://www.youku.com&amp;#34;];//&amp;#21019;&amp;#24314;URL  &amp;#10;NSURLRequest* request = [NSURLRequest requestWithURL:url]; //&amp;#21019;&amp;#24314;NSURLRequest  &amp;#10;[webView loadRequest:request];                             //&amp;#21152;&amp;#36733;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 加载本地网页资源&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL* url = [NSURL   fileURLWithPath:filePath];          //&amp;#21019;&amp;#24314;URL  &amp;#10;NSURLRequest* request = [NSURLRequest requestWithURL:url];//&amp;#21019;&amp;#24314;NSURLRequest  &amp;#10;[webView loadRequest:request];                            //&amp;#21152;&amp;#36733;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 加载带标签的htmlString，你可以提供一个基础URL,来指导UIWebView对象如何跟随链加载远程资源&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.webContentView loadHTMLString:@&amp;#34;&amp;#60;a&amp;#62;hahhaha&amp;#60;/a&amp;#62;&amp;#34; baseURL:nil];//&amp;#26174;&amp;#31034;&amp;#24102;&amp;#26631;&amp;#31614;&amp;#30340;&amp;#23383;&amp;#31526;&amp;#20018;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导航&lt;/p&gt;
&lt;p&gt; UIWebView内部会管理浏览器的导航动作，通过goForward和goBack方法你可以控制前进与后退动作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[webView goBack];          //&amp;#21518;&amp;#36864;&amp;#10;[webView goForward];       //&amp;#21069;&amp;#36827;&amp;#10;[webView reload];          //&amp;#37325;&amp;#36733;  &amp;#10;[webView stopLoading];     //&amp;#21462;&amp;#28040;&amp;#36733;&amp;#20837;&amp;#20869;&amp;#23481;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UIWebViewDelegate委托代理&lt;/p&gt;
&lt;p&gt; UIWebViewDelegate的一组代理方法在特定时间会得到通知，要使用这些方法必须先设定webView的委托&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;webView.delegate = self;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 具体的一些委托方法有&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&amp;#10; *  &amp;#24403;&amp;#32593;&amp;#39029;&amp;#35270;&amp;#22270;&amp;#34987;&amp;#25351;&amp;#31034;&amp;#36733;&amp;#20837;&amp;#20869;&amp;#23481;&amp;#32780;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290;&amp;#24212;&amp;#24403;&amp;#36820;&amp;#22238;YES&amp;#65292;&amp;#36825;&amp;#26679;&amp;#20250;&amp;#36827;&amp;#34892;&amp;#21152;&amp;#36733;&amp;#10; *  &amp;#36890;&amp;#36807;&amp;#23548;&amp;#33322;&amp;#31867;&amp;#22411;&amp;#21442;&amp;#25968;&amp;#21487;&amp;#20197;&amp;#24471;&amp;#21040;&amp;#35831;&amp;#27714;&amp;#21457;&amp;#36215;&amp;#30340;&amp;#21407;&amp;#22240;&amp;#65292;&amp;#21487;&amp;#20197;&amp;#26159;&amp;#20197;&amp;#19979;&amp;#20219;&amp;#24847;&amp;#20540;&amp;#65306;&amp;#10; *  UIWebViewNavigationTypeLinkClicked&amp;#10; *  UIWebViewNavigationTypeFormSubmitted&amp;#10; *  UIWebViewNavigationTypeBackForward&amp;#10; *  UIWebViewNavigationTypeReload&amp;#10; *  UIWebViewNavigationTypeFormResubmitted&amp;#10; *  UIWebViewNavigationTypeOther&amp;#10; */&amp;#10;-(BOOL)webView:(UIWebView*)webView &amp;#10;shouldStartLoadWithRequest:(NSURLRequest*) reuqest &amp;#10;navigationType:(UIWebViewNavigationType)navigationType;  &amp;#10;&amp;#10;//&amp;#24403;&amp;#32593;&amp;#39029;&amp;#35270;&amp;#22270;&amp;#24050;&amp;#32463;&amp;#24320;&amp;#22987;&amp;#21152;&amp;#36733;&amp;#19968;&amp;#20010;&amp;#35831;&amp;#27714;&amp;#21518;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290;&amp;#10;-(void)webViewDidStartLoad:(UIWebView*)webView;&amp;#10;&amp;#10;//&amp;#24403;&amp;#32593;&amp;#39029;&amp;#35270;&amp;#22270;&amp;#32467;&amp;#26463;&amp;#21152;&amp;#36733;&amp;#19968;&amp;#20010;&amp;#35831;&amp;#27714;&amp;#20043;&amp;#21518;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290; &amp;#10;-(void)webViewDidFinishLoad:(UIWebView*)webView;&amp;#10;&amp;#10;//&amp;#24403;&amp;#22312;&amp;#35831;&amp;#27714;&amp;#21152;&amp;#36733;&amp;#20013;&amp;#21457;&amp;#29983;&amp;#38169;&amp;#35823;&amp;#26102;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290;&amp;#20250;&amp;#25552;&amp;#20379;&amp;#19968;&amp;#20010;NSSError&amp;#23545;&amp;#35937;&amp;#65292;&amp;#20197;&amp;#26631;&amp;#35782;&amp;#25152;&amp;#21457;&amp;#29983;&amp;#38169;&amp;#35823;&amp;#31867;&amp;#22411;&amp;#12290;&amp;#10;-(void)webView:(UIWebView*)webView  DidFailLoadWithError:(NSError*)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。&lt;/p&gt;
&lt;p&gt;下面我想简单记录一下UIWebView的简单使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建UIWebView&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGRect bouds = [[UIScreen manScreen]applicationFrame];  &amp;#10;UIWebView* webView = [[UIWebView alloc]initWithFrame:bounds];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;webView.scalespageToFit = YES;&amp;#9;    //&amp;#33258;&amp;#21160;&amp;#23545;&amp;#39029;&amp;#38754;&amp;#36827;&amp;#34892;&amp;#32553;&amp;#25918;&amp;#20197;&amp;#36866;&amp;#24212;&amp;#23631;&amp;#24149;  &amp;#10;webView.detectsPhoneNumbers = YES;  //&amp;#33258;&amp;#21160;&amp;#26816;&amp;#27979;&amp;#32593;&amp;#39029;&amp;#19978;&amp;#30340;&amp;#30005;&amp;#35805;&amp;#21495;&amp;#30721;&amp;#65292;&amp;#21333;&amp;#20987;&amp;#21487;&amp;#20197;&amp;#25320;&amp;#25171;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C常用关键字的使用与区别</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/23/Objective-C%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/23/Objective-C常用关键字的使用与区别/</id>
    <published>2016-03-23T02:17:12.000Z</published>
    <updated>2016-05-04T03:18:20.000Z</updated>
    
    <content type="html">&lt;p&gt;虽然接触iOS已经很久了，但是对于Objective-C中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@propperty (?,?) ?*!;&amp;#10;...............&amp;#10;............&amp;#10;.........&amp;#10;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。&lt;br&gt;所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。&lt;/p&gt;
&lt;p&gt;OC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。&lt;br&gt;这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;copy&lt;/strong&gt; 创建一个索引计数为1的对象,释放掉原来的对象。复制内容（深复制），如果调用copy的是数组，则为指针复制（浅复制），仅仅复制子元素的指针。copy常常用来修饰NSString，NSMutableArray和Block。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property  (nonatomic,copy) NSString  *title;&amp;#10;@property (nonatomic, copy) NSMutableArray *myArray;&amp;#10;@property (nonatomic, copy) void(^myBlock)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;assign&lt;/strong&gt; 简单的赋值，不会更改索引计数，主要是对基本数据类型使用。eg：（NSInteger，CGFloat和C语言的int,float, double,char等）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) int n;&amp;#10;@property (nonatomic, assign) BOOL isOK;&amp;#10;@property (nonatomic, assign) CGFloat width;&amp;#10;@property (nonatomic, assign) CGPoint height;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;retain&lt;/strong&gt;&lt;br&gt;释放旧的对象，将旧对象的值赋予输入对象并将输入对象的索引计数＋1，主要应用与NSObject与其子类中。 retain是指针复制（浅复制），引用计数加1，而不会导致内容被复制。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property  (nonatomic, retain) UIColor *myColor;&amp;#10;&amp;#10;- (void)setName:(NSString *)newName &amp;#123;&amp;#10;    [newName retain];&amp;#10;    [name release];  &amp;#10;    name = newName;  &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;strong&lt;/strong&gt;&lt;br&gt;相当于retain，strong在ARC环境下为默认属性类型。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,readwrite,strong) NSString *title;&amp;#10;@property (strong, nonatomic) UIViewController *viewController;&amp;#10;@property (nonatomic,  strong) id childObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;weak&lt;/strong&gt;&lt;br&gt;取代之前的assign，对象销毁之后会自动置为nil，防止野指针。&lt;br&gt;assign不能自动置为nil，需要手动置为nil。&lt;br&gt;delegate基本总是使用weak，以防止循环引用。特殊情况是，如果希望在dealloc中调用delegate的某些方法进行释放，此时如果使用weak将引起异常，因为此时已经是nil了，那么采用assign更为合适。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property  (weak, nonatomic) IBOutlet UIButton *myButton;//&amp;#22788;&amp;#20110;&amp;#26368;&amp;#39030;&amp;#23618;&amp;#30340;IBOutlet&amp;#24212;&amp;#35813;&amp;#20026;strong&amp;#10;@property (nonatomic, weak) id parentObject;&amp;#10;@property(nonatomic, readwrite, weak) id  &amp;#60;MyDelegate&amp;#62; delegate;&amp;#10;@property (nonatomic, weak) NSObject &amp;#60;SomeDelegate&amp;#62; *delegate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;readonly&lt;/strong&gt;&lt;br&gt;此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;readwrite&lt;/strong&gt;&lt;br&gt;此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用区别&quot;&gt;&lt;a href=&quot;#使用区别&quot; class=&quot;headerlink&quot; title=&quot;使用区别&quot;&gt;&lt;/a&gt;使用区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;copy和retain&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;copy其实是建立了一个相同的对象，而retain不是；&lt;/li&gt;
&lt;li&gt;copy是内容拷贝，retain是指针拷贝；&lt;/li&gt;
&lt;li&gt;copy是内容的拷贝 ,对于像NSString的确是这样，但是如果copy的是一个NSArray呢?这时只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”.&lt;/li&gt;
&lt;li&gt;copy的情况：NSString *newPt = [pt copy];&lt;br&gt;此时会在堆上重新开辟一段内存存放@”abc” 比如0X1122 内容为@”abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;assign与retain&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;assign: 简单赋值，不更改索引计数；&lt;/li&gt;
&lt;li&gt;assign的情况：NSString *newPt = [pt assing];&lt;br&gt;此时newPt和pt完全相同 地址都是0Xaaaa 内容为0X1111 即newPt只是pt的别名，对任何一个操作就等于对另一个操作， 因此retainCount不需要增加；&lt;/li&gt;
&lt;li&gt;assign就是直接赋值；&lt;/li&gt;
&lt;li&gt;retain使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收；&lt;/li&gt;
&lt;li&gt;retain的情况：NSString *newPt = [pt retain];&lt;br&gt;此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理”abc”所在的内存，因此 retainCount需要增加1；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;readonly与readwrite&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;readonly：只产生简单的getter,没有setter。&lt;/li&gt;
&lt;li&gt;readwrite：同时产生setter\getter方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nonatomic与atomic&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;nonatomic非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问；&lt;/li&gt;
&lt;li&gt;成员变量的@property属性时，默认为atomic，提供多线程安全。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果&lt;br&gt;weak and strong property (强引用和弱引用的区别)&lt;/li&gt;
&lt;li&gt;比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态，这样取到的东西会有问题，就是不完整的。当然如果不需要多线程支持的话，用nonatomic就够了，因为不涉及到线程锁的操作，所以它执行率相对快些。&lt;/li&gt;
&lt;li&gt;atomic的意思就是setter/getter这个函数，是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;weak与strong&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;weak 和 strong 属性只有在你打开ARC时才会被要求使用，这时你是不能使用retain release autorelease 操作的，因为ARC会自动为你做好这些操作，但是你需要在对象属性上使用weak 和strong,其中strong就相当于retain属性，而weak相当于assign。&lt;/li&gt;
&lt;li&gt;只有一种情况你需要使用weak（默认是strong），就是为了避免retain cycles（就是父类中含有子类{父类retain了子类}，子类中又调用了父类{子类又retain了父类}，这样都无法release）&lt;/li&gt;
&lt;li&gt;声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;虽然接触iOS已经很久了，但是对于Objective-C中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@propperty (?,?) ?*!;&amp;#10;...............&amp;#10;............&amp;#10;.........&amp;#10;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。&lt;br&gt;所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。&lt;/p&gt;
&lt;p&gt;OC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。&lt;br&gt;这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://www.jvaeyhcd.cc/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS几种不同传值方式</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/17/iOS%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/17/iOS几种不同传值方式/</id>
    <published>2016-03-17T07:17:32.000Z</published>
    <updated>2016-04-27T10:58:45.000Z</updated>
    
    <content type="html">&lt;p&gt;关于iOS的传值方式我所知道的一共有一下6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性传值&lt;/li&gt;
&lt;li&gt;代理传值&lt;/li&gt;
&lt;li&gt;block传值&lt;/li&gt;
&lt;li&gt;单例传值&lt;/li&gt;
&lt;li&gt;通知传值&lt;/li&gt;
&lt;li&gt;NSUserDefault保存数据传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h2&gt;&lt;p&gt;属性传值一般常用在页面中，从一个页面传值到另一个页面。例如从A页面跳转到B页面，如果需要将A页面中的某个值传递到B页面中，这个时候用到最简单的传值方式就是属性传值。&lt;/p&gt;
&lt;p&gt;下面是一个简单例子实现将AViewController中UItextFiled中的值传到BViewController中Label中。&lt;br&gt;AViewController.m中的代码如下：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;AViewController.h&amp;#34;&amp;#10;#import &amp;#34;BViewController.h&amp;#34;&amp;#10;&amp;#10;@interface AViewController ()&amp;#10;&amp;#10;//&amp;#23450;&amp;#20041;&amp;#36755;&amp;#20837;&amp;#26694;&amp;#10;@property (nonatomic, strong) UITextField *textField;&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation AViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;    [super viewDidLoad];&amp;#10;    // Do any additional setup after loading the view.&amp;#10;    &amp;#10;    [self.view addSubview:self.textField];&amp;#10;    //&amp;#23450;&amp;#20041;&amp;#28857;&amp;#20987;&amp;#36339;&amp;#36716;&amp;#30340;&amp;#25353;&amp;#38062;&amp;#10;    UIButton *pushBtn = [[UIButton alloc]initWithFrame:CGRectMake(20, 150, 100, 30)];&amp;#10;    pushBtn.titleLabel.font = [UIFont systemFontOfSize:12];&amp;#10;    [pushBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];&amp;#10;    [pushBtn setTitle:@&amp;#34;push&amp;#26174;&amp;#31034;&amp;#34; forState:UIControlStateNormal];&amp;#10;    [pushBtn setBackgroundColor:[UIColor yellowColor]];&amp;#10;    [pushBtn addTarget:self action:@selector(pushAction) forControlEvents:UIControlEventTouchUpInside];&amp;#10;    [self.view addSubview:pushBtn];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)pushAction &amp;#123;&amp;#10;    //&amp;#23450;&amp;#20041;&amp;#36339;&amp;#36716;&amp;#39029;&amp;#38754;&amp;#65292;&amp;#24182;&amp;#32473;B&amp;#39029;&amp;#38754;str&amp;#36171;&amp;#20540;&amp;#10;    BViewController *vc = [[BViewController alloc]init];&amp;#10;    vc.str = self.textField.text;&amp;#10;    [self.navigationController pushViewController:vc animated:YES];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;    [super didReceiveMemoryWarning];&amp;#10;    // Dispose of any resources that can be recreated.&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (UITextField *)textField &amp;#123;&amp;#10;    if (!_textField) &amp;#123;&amp;#10;        _textField = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 280, 30)];&amp;#10;        _textField.borderStyle = UITextBorderStyleRoundedRect;&amp;#10;    &amp;#125;&amp;#10;    return _textField;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;BViewController.h文件中，声明被赋值的属性&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;UIKit/UIKit.h&amp;#62;&amp;#10;&amp;#10;@interface BViewController : UIViewController&amp;#10;&amp;#10;@property (nonatomic, copy) NSString *str;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;BViewController.m中显示AViewController传递过来的属性值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;BViewController.h&amp;#34;&amp;#10;&amp;#10;@interface BViewController ()&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation BViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;    [super viewDidLoad];&amp;#10;    // Do any additional setup after loading the view.&amp;#10;    self.view.backgroundColor = [UIColor whiteColor];&amp;#10;    &amp;#10;    UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 100, 20)];&amp;#10;    label.font = [UIFont systemFontOfSize:14];&amp;#10;    label.textColor = [UIColor blackColor];&amp;#10;    //&amp;#26174;&amp;#31034;AViewController&amp;#20256;&amp;#36882;&amp;#36807;&amp;#26469;&amp;#30340;&amp;#20540;&amp;#10;    label.text = self.str;&amp;#10;    [self.view addSubview:label];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;    [super didReceiveMemoryWarning];&amp;#10;    // Dispose of any resources that can be recreated.&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS的传值方式我所知道的一共有一下6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性传值&lt;/li&gt;
&lt;li&gt;代理传值&lt;/li&gt;
&lt;li&gt;block传值&lt;/li&gt;
&lt;li&gt;单例传值&lt;/li&gt;
&lt;li&gt;通知传值&lt;/li&gt;
&lt;li&gt;NSUserDefault保存数据传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.jvaeyhcd.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>App Store上线完整流程</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/05/App-Store%E4%B8%8A%E7%BA%BF%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/05/App-Store上线完整流程/</id>
    <published>2016-03-05T09:25:33.000Z</published>
    <updated>2016-04-27T11:24:40.000Z</updated>
    
    <content type="html">&lt;p&gt;经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。&lt;/p&gt;
&lt;h2 id=&quot;预先准备&quot;&gt;&lt;a href=&quot;#预先准备&quot; class=&quot;headerlink&quot; title=&quot;预先准备&quot;&gt;&lt;/a&gt;预先准备&lt;/h2&gt;&lt;p&gt;在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Step-1-申请开发者帐号&quot;&gt;&lt;a href=&quot;#Step-1-申请开发者帐号&quot; class=&quot;headerlink&quot; title=&quot;Step 1:申请开发者帐号&quot;&gt;&lt;/a&gt;Step 1:申请开发者帐号&lt;/h3&gt;&lt;p&gt;如果您现在已有开发者帐号，那么恭喜您，您可以直接跳过此步骤直接进入下一步骤。苹果开发者帐号分为三种：个人开发者帐号、公司帐号、企业帐号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人帐号（Individual）:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：99美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：是&lt;/li&gt;
&lt;li&gt;最大uuid支持数：100&lt;/li&gt;
&lt;li&gt;协作人数：1人（开发者自己）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：“个人”开发者可以申请升级“公司”，可以通过拨打苹果公司客服电话（400 6701 855）来咨询和办理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 公司帐号（Company）: &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：99美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：是&lt;/li&gt;
&lt;li&gt;最大uuid支持数：100&lt;/li&gt;
&lt;li&gt;协作人数：多人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：允许多个开发者进行协作开发，比个人多一些帐号管理的设置，可设置多个Apple ID，分4种管理级别的权限。申请时需要填写公司的邓白氏编码（DUNS Number）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 企业帐号（Enterprise）: &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：299美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：否&lt;/li&gt;
&lt;li&gt;最大uuid支持数：不限制&lt;/li&gt;
&lt;li&gt;协作人数：多人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：需要注意的是，企业账号开发的应用不能上线App Store，适合那些不希望公开发布应用的企业。同样，申请时也需要公司的邓白氏编码（DUNS Number）。&lt;/p&gt;
&lt;h3 id=&quot;Step-2-App-ID（应用ID）&quot;&gt;&lt;a href=&quot;#Step-2-App-ID（应用ID）&quot; class=&quot;headerlink&quot; title=&quot;Step 2:App ID（应用ID）&quot;&gt;&lt;/a&gt;Step 2:App ID（应用ID）&lt;/h3&gt;&lt;p&gt;App ID是识别不同应用程序的唯一标示符。每个app都需要一个App ID或者app标识。目前有两种类型的App标识：一个是精确的App ID（explicit App ID），一个是通配符App ID（wildcard App ID）。使用通配符的App ID可以用来构建和安装多个程序。尽管通配符App ID非常方便，但是一个精确的App ID也是需要的，尤其是当App使用iCloud 或者使用其他iOS功能的时候，比如Game Center、Push Notifications或者IAP。如果你已经申请开发者帐号，接下你需要登录&lt;a href=&quot;https://developer.apple.com/membercenter/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/membercenter/。&lt;/a&gt;&lt;br&gt;登录成功后界面如下：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/developer_center.png&quot; alt=&quot;Developer页面&quot; title=&quot;Developer页面&quot;&gt;&lt;br&gt;点击“Certificates,Identifiers&amp;amp;Profiles”进入到&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/Identifiers.png&quot; alt=&quot;Identifiers&quot; title=&quot;Identifiers&quot;&gt;&lt;br&gt;选择Identifiers，然后点击“＋”注册你自己的应用的App Id&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_app_id.png&quot; alt=&quot;创建App ID&quot; title=&quot;创建App ID&quot;&gt;&lt;br&gt;以上两项设置好后，点击下一步，然后注册即可，这样一个App Id就创建好了。接下来需要设置开发证书。&lt;/p&gt;
&lt;h3 id=&quot;Step-3-Distribution-Certificate-发布证书&quot;&gt;&lt;a href=&quot;#Step-3-Distribution-Certificate-发布证书&quot; class=&quot;headerlink&quot; title=&quot;Step 3:Distribution Certificate(发布证书)&quot;&gt;&lt;/a&gt;Step 3:Distribution Certificate(发布证书)&lt;/h3&gt;&lt;p&gt;iOS应用都有一个安全证书用于验证开发者身份和签名。为了可以向App Store提交app，你需要创建一个iOS provisioning profile 。首先需要创建一个distribution certificate（发布证书），过程类似于创建一个development certificate（开发证书）。如果你已经在实体设备上测试你的App，那么你对创建development certificate就已经很熟悉了。&lt;/p&gt;
&lt;p&gt;首先选择Certificate,然后点击“＋”&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step1.png&quot; alt=&quot;创建Certificate证书第一步&quot; title=&quot;创建Certificate证书第一步&quot;&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step2.png&quot; alt=&quot;创建Certificate证书第二步&quot; title=&quot;创建Certificate证书第二步&quot;&gt;
&lt;p&gt;然后点击“下一步”来到如下界面：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step3.png&quot; alt=&quot;创建Certificate证书第三步&quot; title=&quot;创建Certificate证书第三步&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里需要上传一个.certSigningRequest文件来生成相应的证书。下面简单讲一下.certSigningRequest文件的生成方法：&lt;br&gt;首先打开“钥匙串访问”，在菜单中选择“钥匙串访问”-&amp;gt;“证书助理”-&amp;gt;“从证书颁发机构请求证书…”。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certSigningRequest_step1.png&quot; alt=&quot;创建.certSigningRequest文件&quot; title=&quot;创建.certSigningRequest文件&quot;&gt;&lt;br&gt;然后填写好相应的信息，注意：选择保存到磁盘。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certSigningRequest_step2.png&quot; alt=&quot;填写.certSigningRequest文件信息&quot; title=&quot;填写.certSigningRequest文件信息&quot;&gt;&lt;br&gt;点击继续，然后会生成一个.certSigningRequest文件。&lt;br&gt;然后选择生成的.certSigningRequest文件，点击下一步即可生成相应的证书。&lt;/p&gt;
&lt;h3 id=&quot;Step-4-Provisioning-Profile-配置文件&quot;&gt;&lt;a href=&quot;#Step-4-Provisioning-Profile-配置文件&quot; class=&quot;headerlink&quot; title=&quot;Step 4:Provisioning Profile(配置文件)&quot;&gt;&lt;/a&gt;Step 4:Provisioning Profile(配置文件)&lt;/h3&gt;&lt;p&gt;一旦你创建了App ID和distribution certificate，你可以创建一个iOS provisioning profile以方便在App Store中销售你的App。Provisioning Profile主要分为开发配置文件和发布配置文件，发布配置文件中又分App Store配置文件和Ad Hoc配置文件。App Store类型的Provisioning Profile顾名思义是用于发布到App Store的配置文件。Ad Hoc的Provisioning Profile配置文件是用于发布应用内的测试包的，在应用还没有上线的时候需要发ipa给客户安装的时候需要用到，只需要获取到客户手机的UDID然后生成相应的Ad Hoc类型的Provisioning Profile文件然后打包发布即可。&lt;br&gt;同样Provisioning Profile的创建方式如下：&lt;br&gt;选择“Provisioning Profiles”，然后点击“➕”创建Provisioning Profiles文件&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step1.png&quot; alt=&quot;创建Provisioning Profiles文件&quot; title=&quot;创建Provisioning Profiles文件&quot;&gt;
&lt;p&gt;选择相应的Provisioning Profiles文件类型&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step2.png&quot; alt=&quot;选择Provisioning Profiles文件类型&quot; title=&quot;选择Provisioning Profiles文件类型&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择您需要生成Provisioning Profiles文件的App ID&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step3.png&quot; alt=&quot;选择Provisioning Profiles文件的App ID&quot; title=&quot;选择Provisioning Profiles文件的App ID&quot;&gt;&lt;br&gt;选择相应的证书&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step4.png&quot; alt=&quot;选择相应的证书&quot; title=&quot;选择相应的证书&quot;&gt;&lt;br&gt;选择已注册的设备&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step5.png&quot; alt=&quot;选择已注册的设备&quot; title=&quot;选择已注册的设备&quot;&gt;&lt;br&gt;然后点击下一步即可生成Provisioning Profiles文件，点击下载，然后双击打开。&lt;/p&gt;
&lt;h3 id=&quot;Step-5-Build-Settings-生成设置&quot;&gt;&lt;a href=&quot;#Step-5-Build-Settings-生成设置&quot; class=&quot;headerlink&quot; title=&quot;Step 5:Build Settings(生成设置)&quot;&gt;&lt;/a&gt;Step 5:Build Settings(生成设置)&lt;/h3&gt;&lt;p&gt;配置App ID、distribution certificate 和provisioning profile已经完成，是时候配置Xcode中target的build settings了。在Xcode Project  Navigator的targets列表中选择一个target，打开顶部的Build Settings选项，然后更新一下Code Signing来跟之前创建的distribution provisioning profile相匹配。最近添加的provisioning profiles有时候不会立马就在build settings的Code Signing中看到，重启一下Xcode就可以解决这个问题。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/build_setting.png&quot; alt=&quot;Build Setting配置&quot; title=&quot;Build Setting配置&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Step-6-Deployment-Target-部署目标&quot;&gt;&lt;a href=&quot;#Step-6-Deployment-Target-部署目标&quot; class=&quot;headerlink&quot; title=&quot;Step 6:Deployment Target(部署目标)&quot;&gt;&lt;/a&gt;Step 6:Deployment Target(部署目标)&lt;/h3&gt;&lt;p&gt;所有配置都已配好后，就可以开始打包了生成ipa了。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/archive.png&quot; alt=&quot;开始打包&quot; title=&quot;开始打包&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;iTunes-Connect相关配置&quot;&gt;&lt;a href=&quot;#iTunes-Connect相关配置&quot; class=&quot;headerlink&quot; title=&quot;iTunes Connect相关配置&quot;&gt;&lt;/a&gt;iTunes Connect相关配置&lt;/h2&gt;&lt;h3 id=&quot;Step-1-创建“我的App”&quot;&gt;&lt;a href=&quot;#Step-1-创建“我的App”&quot; class=&quot;headerlink&quot; title=&quot;Step 1:创建“我的App”&quot;&gt;&lt;/a&gt;Step 1:创建“我的App”&lt;/h3&gt;&lt;p&gt;首先用你自己的开发者帐号登录到&lt;a href=&quot;https://itunesconnect.apple.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iTunes Connect&lt;/a&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step1.png&quot; alt=&quot;iTunes Connect&quot; title=&quot;iTunes Connect&quot;&gt;
&lt;p&gt;登录成功后点击“我的App”，然后点击“＋”-&amp;gt;“新建App”&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step2.png&quot; alt=&quot;在iTunes Connect上新建App&quot; title=&quot;在iTunes Connect上新建App&quot;&gt;&lt;br&gt;其中平台选择iOS，名称为你的app的名词，主要语言为你的app的主要语言，套装ID为之前创建的App ID，也就是Xcode工程中的Bundle ID。&lt;br&gt;点击下一步，创建成功后，选择你刚创建成功的应用，进行相关的设置。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step3.png&quot; alt=&quot;填写相关信息&quot; title=&quot;填写相关信息&quot;&gt;&lt;/p&gt;
&lt;p&gt;相关设置比较简单就不再多说。&lt;/p&gt;
&lt;h3 id=&quot;Step-2-打包上传到iTunes-Connect&quot;&gt;&lt;a href=&quot;#Step-2-打包上传到iTunes-Connect&quot; class=&quot;headerlink&quot; title=&quot;Step 2:打包上传到iTunes Connect&quot;&gt;&lt;/a&gt;Step 2:打包上传到iTunes Connect&lt;/h3&gt;&lt;p&gt;配置好了iTunes Connect的相关配置后，就可以将我们生成的ipa包上传到iTunes Connect上了。Xcode中配置完成后archive成功后Xcode会弹出如下界面：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/upload_itunes_connect.png&quot; alt=&quot;上传到iTunes Connect&quot; title=&quot;上传到iTunes Connect&quot;&gt;&lt;br&gt; 上传到iTunes Connect有两种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法一 &lt;/strong&gt;&lt;br&gt;直接点击上图的“Upload to App Store”按钮直接上传到App Store。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法二 &lt;/strong&gt;&lt;br&gt;先导出ipa，然后使用Application Loader上传到App Store。&lt;br&gt;点击“Export”，会弹出如下界面，选择导出的类型，这里要上传App Store，所以选择第一种。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/archive_step_1.png&quot; alt=&quot;导出ipa文件&quot; title=&quot;导出ipa文件&quot;&gt;&lt;br&gt;点击“下一步”，默认回去检查你的证书，如果没有什么问题一直下一步，最后会在桌面生成一个ipa的包。然后在Xcode中打开Application Loader。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_1.png&quot; alt=&quot;Application Loader&quot; title=&quot;Application Loader&quot;&gt;&lt;br&gt;用你自己的开发者帐号登录Application Loader，&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_login.png&quot; alt=&quot;Application Loader登录&quot; title=&quot;Application Loader登录&quot;&gt;&lt;br&gt;登录成功后选取你刚刚生成的ipa&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_step2.png&quot; alt=&quot;Application Loader上传&quot; title=&quot;Application Loader上传&quot;&gt;&lt;br&gt;然后上传提交到App Store。&lt;/p&gt;
&lt;h3 id=&quot;Step-3-提交给苹果审核&quot;&gt;&lt;a href=&quot;#Step-3-提交给苹果审核&quot; class=&quot;headerlink&quot; title=&quot;Step 3:提交给苹果审核&quot;&gt;&lt;/a&gt;Step 3:提交给苹果审核&lt;/h3&gt;&lt;p&gt;完成上面的步骤后，返回到iTunes Connect界面，选择你先前创建的App，在它的活动页面下可以看到所有已上传过的ipa版本。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step4.png&quot; alt=&quot;上传成功后&quot; title=&quot;上传成功后&quot;&gt;&lt;br&gt;选择App信息配置界面，找到“构建版本”，然后选择你刚刚上传的构建版本，然后提交审核即可&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step5.png&quot; alt=&quot;提交审核&quot; title=&quot;提交审核&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。&lt;/p&gt;
&lt;h2 id=&quot;预先准备&quot;&gt;&lt;a href=&quot;#预先准备&quot; class=&quot;headerlink&quot; title=&quot;预先准备&quot;&gt;&lt;/a&gt;预先准备&lt;/h2&gt;&lt;p&gt;在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://www.jvaeyhcd.cc/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App Store" scheme="http://www.jvaeyhcd.cc/tags/App-Store/"/>
    
  </entry>
  
  <entry>
    <title>RESideMenu在所有界面都会侧滑的问题解决办法</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/05/RESideMenu%E5%9C%A8%E6%89%80%E6%9C%89%E7%95%8C%E9%9D%A2%E9%83%BD%E4%BC%9A%E4%BE%A7%E6%BB%91%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/05/RESideMenu在所有界面都会侧滑的问题解决办法/</id>
    <published>2016-03-05T08:24:40.000Z</published>
    <updated>2016-03-05T09:11:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;奉上参考原文链接地址：&lt;a href=&quot;http://blog.csdn.net/icetime17/article/details/46883915&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/icetime17/article/details/46883915&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;RESideMenu基本用法&quot;&gt;&lt;a href=&quot;#RESideMenu基本用法&quot; class=&quot;headerlink&quot; title=&quot;RESideMenu基本用法&quot;&gt;&lt;/a&gt;RESideMenu基本用法&lt;/h2&gt;&lt;p&gt;首先创建window的rootViewController，在RootViewController引入并继承RESideMenu及其RESideMenuDelegate. &lt;/p&gt;
&lt;p&gt;具体相关代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;RESideMenu.h&amp;#34;&amp;#10;@interface RootViewController : RESideMenu &amp;#60;RESideMenuDelegate&amp;#62;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在RootViewController.m文件中设置好RESideMenu&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;RootViewController.h&amp;#34;&amp;#10;@interface RootViewController ()&amp;#10;@end&amp;#10;&amp;#10;@implementation RootViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;  [super viewDidLoad];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;  [super didReceiveMemoryWarning];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)awakeFromNib &amp;#123;&amp;#10;  self.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent;&amp;#10;  self.contentViewShadowColor = [UIColor blackColor];&amp;#10;  self.contentViewShadowOffset = CGSizeMake(0, 0);&amp;#10;  self.contentViewShadowOpacity = 0.6;&amp;#10;  self.contentViewShadowRadius = 12;&amp;#10;  self.contentViewShadowEnabled = NO;&amp;#10;&amp;#10;  self.contentViewController = [self.storyboard instantiateViewControllerWithIdentifier:@&amp;#34;ContentViewController&amp;#34;];&amp;#10;  self.leftMenuViewController = [self.storyboard instantiateViewControllerWithIdentifier:@&amp;#34;LeftMenuViewController&amp;#34;];&amp;#10;&amp;#10;  self.delegate = self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;#pragma mark - RESideMenu Delegate&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu willShowMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu didShowMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu willHideMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu didHideMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;遇到问题&quot;&gt;&lt;a href=&quot;#遇到问题&quot; class=&quot;headerlink&quot; title=&quot;遇到问题&quot;&gt;&lt;/a&gt;遇到问题&lt;/h2&gt;&lt;p&gt;在RESideMenu的使用过程中，发现所有的界面都加上了侧滑功能，并且iOS的滑动返回功能失效了。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;通过观察RESideMenu的源码发现，RESideMenu类中有一个BOOL属性panGestureEnabled, 可以将其视为侧滑效果的开关。以RESideMenu的panGestureEnabled属性为突破口，采用通知的方式来解决这个问题。&lt;br&gt;在RootViewController.m文件中加入如下代码：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&amp;#10;  [super viewDidLoad];&amp;#10;&amp;#10;  [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                           selector:@selector(disableRESideMenu)&amp;#10;                                               name:@&amp;#34;disableRESideMenu&amp;#34;&amp;#10;                                             object:nil];&amp;#10;  [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                           selector:@selector(enableRESideMenu) &amp;#10;                                               name:@&amp;#34;enableRESideMenu&amp;#34;&amp;#10;                                             object:nil];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)enableRESideMenu &amp;#123;&amp;#10;  self.panGestureEnabled = YES;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)disableRESideMenu &amp;#123;&amp;#10;  self.panGestureEnabled = NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在其他页面需要禁止侧滑的时候调用如下代码,发送通知&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#20851;&amp;#38381;&amp;#20391;&amp;#28369;&amp;#25928;&amp;#26524;&amp;#10;[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;#34;disableRESideMenu&amp;#34;&amp;#10;                                                            object:self&amp;#10;                                                          userInfo:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;相反在需要侧滑的地方调用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#24320;&amp;#21551;&amp;#20391;&amp;#28369;&amp;#25928;&amp;#26524;&amp;#10;[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;#34;enableRESideMenu&amp;#34;&amp;#10;                                                    object:self&amp;#10;                                                  userInfo:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Block正确使用避免Cycle Retain和Crash</title>
    <link href="http://www.jvaeyhcd.cc/2016/02/24/Block%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E9%81%BF%E5%85%8DCycle-Retain%E5%92%8CCrash/"/>
    <id>http://www.jvaeyhcd.cc/2016/02/24/Block正确使用避免Cycle-Retain和Crash/</id>
    <published>2016-02-24T01:28:26.000Z</published>
    <updated>2016-04-28T03:44:51.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下&lt;strong&gt;block不会增加引用计数，但ARC会，ARC下必须用&lt;/strong&gt;weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Block简介&quot;&gt;&lt;a href=&quot;#Block简介&quot; class=&quot;headerlink&quot; title=&quot;Block简介&quot;&gt;&lt;/a&gt;Block简介&lt;/h2&gt;&lt;p&gt;Block作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于Objective-C在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。&lt;/p&gt;
&lt;p&gt;可以这样理解，Block其实包含两个部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block执行的代码，这是在编译的时候已经生成好的；&lt;/li&gt;
&lt;li&gt;一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Block与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Block基本语法&quot;&gt;&lt;a href=&quot;#Block基本语法&quot; class=&quot;headerlink&quot; title=&quot;Block基本语法&quot;&gt;&lt;/a&gt;Block基本语法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#22768;&amp;#26126;&amp;#19968;&amp;#20010;Block&amp;#21464;&amp;#37327;&amp;#10;long (^sum) (int, int) = nil;&amp;#10;// sum&amp;#26159;&amp;#20010;Block&amp;#21464;&amp;#37327;&amp;#65292;&amp;#35813;Block&amp;#31867;&amp;#22411;&amp;#26377;&amp;#20004;&amp;#20010;int&amp;#22411;&amp;#21442;&amp;#25968;&amp;#65292;&amp;#36820;&amp;#22238;&amp;#31867;&amp;#22411;&amp;#26159;long&amp;#12290;&amp;#10;&amp;#10;// &amp;#23450;&amp;#20041;Block&amp;#24182;&amp;#36171;&amp;#32473;&amp;#21464;&amp;#37327;sum&amp;#10;sum = ^ long (int a, int b) &amp;#123;&amp;#10;  return a + b;&amp;#10;&amp;#125;;&amp;#10;&amp;#10;// &amp;#35843;&amp;#29992;Block&amp;#65306;&amp;#10;long s = sum(1, 2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义一个实例函数，该函数返回Block：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (long (^)(int, int)) sumBlock &amp;#123;&amp;#10;    int base = 100;&amp;#10;    return [[ ^ long (int a, int b) &amp;#123;&amp;#10;      return base + a + b;&amp;#10;    &amp;#125; copy] autorelease];&amp;#10;  &amp;#125;&amp;#10;&amp;#10;// &amp;#35843;&amp;#29992;Block&amp;#10;[self sumBlock](1,2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是不是感觉很怪？为了看的舒服，我们把Block类型typedef一下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef long (^BlkSum)(int, int);&amp;#10;&amp;#10;- (BlkSum) sumBlock &amp;#123;&amp;#10;    int base = 100;&amp;#10;    BlkSum blk = ^ long (int a, int b) &amp;#123;&amp;#10;      return base + a + b;&amp;#10;    &amp;#125;&amp;#10;    return [[blk copy] autorelease];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Block在内存中的位置&quot;&gt;&lt;a href=&quot;#Block在内存中的位置&quot; class=&quot;headerlink&quot; title=&quot;Block在内存中的位置&quot;&gt;&lt;/a&gt;Block在内存中的位置&lt;/h2&gt;&lt;p&gt;根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSGlobalBlock：类似函数，位于text段；&lt;/li&gt;
&lt;li&gt;NSStackBlock：位于栈内存，函数返回后Block将无效；&lt;/li&gt;
&lt;li&gt;NSMallocBlock：位于堆内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看下面一段代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BlkSum blk1 = ^ long (int a, int b) &amp;#123;&amp;#10;  return a + b;&amp;#10;&amp;#125;;&amp;#10;NSLog(@&amp;#34;blk1 = %@&amp;#34;, blk1);// blk1 = &amp;#60;__NSGlobalBlock__: 0x47d0&amp;#62;&amp;#10;&amp;#10;&amp;#10;int base = 100;&amp;#10;BlkSum blk2 = ^ long (int a, int b) &amp;#123;&amp;#10;  return base + a + b;&amp;#10;&amp;#125;;&amp;#10;NSLog(@&amp;#34;blk2 = %@&amp;#34;, blk2); // blk2 = &amp;#60;__NSStackBlock__: 0xbfffddf8&amp;#62;&amp;#10;&amp;#10;BlkSum blk3 = [[blk2 copy] autorelease];&amp;#10;NSLog(@&amp;#34;blk3 = %@&amp;#34;, blk3); // blk3 = &amp;#60;__NSMallocBlock__: 0x902fda0&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么blk1类型是NSGlobalBlock，而blk2类型是NSStackBlock？blk1和blk2的区别在于，blk1没有使用Block以外的任何外部变量，Block不需要建立局部变量值的快照，这使blk1与函数没有任何区别，从blk1所在内存地址0x47d0猜测编译器把blk1放到了text代码段。blk2与blk1唯一不同是的使用了局部变量base，在定义（注意是定义，不是运行）blk2时，局部变量base当前值被copy到栈上，作为常量供Block使用。执行下面代码，结果是203，而不是204。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int base = 100;&amp;#10;base += 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;    return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base++;&amp;#10;printf(&amp;#34;%ld&amp;#34;,sum(1,2));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Block内变量base是只读的，如果想在Block内改变base的值，在定义base时要用 &lt;strong&gt;block修饰：&lt;/strong&gt;block int base = 100;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block int base = 100;&amp;#10;base += 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;    base += 10;&amp;#10;    return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base++;&amp;#10;printf(&amp;#34;%ld\n&amp;#34;,sum(1,2));&amp;#10;printf(&amp;#34;%d\n&amp;#34;,base);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上方的代码输出将是214,211。Block中使用__block修饰的变量时，将取变量此刻运行时的值，而不是定义时的快照。这个例子中，执行sum(1,2)时，base将取base++之后的值，也就是201，再执行Blockbase+=10; base+a+b，运行结果是214。执行完Block时，base已经变成211了。&lt;/p&gt;
&lt;h2 id=&quot;Block的copy、retain、release操作&quot;&gt;&lt;a href=&quot;#Block的copy、retain、release操作&quot; class=&quot;headerlink&quot; title=&quot;Block的copy、retain、release操作&quot;&gt;&lt;/a&gt;Block的copy、retain、release操作&lt;/h2&gt;&lt;p&gt;不同于NSObjec的copy、retain、release操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block_copy与copy等效，Block_release与release等效；&lt;/li&gt;
&lt;li&gt;对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1；&lt;/li&gt;
&lt;li&gt;NSGlobalBlock：retain、copy、release操作都无效；&lt;/li&gt;
&lt;li&gt;NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象。&lt;/li&gt;
&lt;li&gt;NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain；&lt;/li&gt;
&lt;li&gt;尽量不要对Block使用retain操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Block对不同类型的变量的存取&quot;&gt;&lt;a href=&quot;#Block对不同类型的变量的存取&quot; class=&quot;headerlink&quot; title=&quot;Block对不同类型的变量的存取&quot;&gt;&lt;/a&gt;Block对不同类型的变量的存取&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 基本类型 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int base = 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;  // base++; &amp;#32534;&amp;#35793;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#21482;&amp;#35835;&amp;#10;  return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base = 0;&amp;#10;printf(&amp;#34;%ld\n&amp;#34;,sum(1,2)); // &amp;#36825;&amp;#37324;&amp;#36755;&amp;#20986;&amp;#26159;103&amp;#65292;&amp;#32780;&amp;#19981;&amp;#26159;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static变量、全局变量。如果把上个例子的base改成全局的、或static。Block就可以对他进行读写了。因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。&lt;br&gt;如下所示的一段代码输出结果是0 3 1，表明Block外部对base的更新会影响Block中的base的取值，同样Block对base的更新也会影响Block外部的base值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static int base = 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;  base++;&amp;#10;  return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base = 0;&amp;#10;printf(&amp;#34;%d\n&amp;#34;, base);&amp;#10;printf(&amp;#34;%ld\n&amp;#34;,sum(1,2)); // &amp;#36825;&amp;#37324;&amp;#36755;&amp;#20986;&amp;#26159;3&amp;#65292;&amp;#32780;&amp;#19981;&amp;#26159;103&amp;#10;printf(&amp;#34;%d\n&amp;#34;, base);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block变量，被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。Block被另一个Block使用时，另一个Block被copy到堆上时，被使用的Block也会被copy。但作为参数的Block是不会发生copy的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void foo() &amp;#123;&amp;#10;  int base = 100;&amp;#10;  BlkSum blk = ^ long (int a, int b) &amp;#123;&amp;#10;    return  base + a + b;&amp;#10;  &amp;#125;;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, blk); // &amp;#60;__NSStackBlock__: 0xbfffdb40&amp;#62;&amp;#10;  bar(blk);&amp;#10;&amp;#125;&amp;#10;&amp;#10;void bar(BlkSum sum_blk) &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;,sum_blk); // &amp;#19982;&amp;#19978;&amp;#38754;&amp;#19968;&amp;#26679;&amp;#65292;&amp;#35828;&amp;#26126;&amp;#20316;&amp;#20026;&amp;#21442;&amp;#25968;&amp;#20256;&amp;#36882;&amp;#26102;&amp;#65292;&amp;#24182;&amp;#19981;&amp;#20250;&amp;#21457;&amp;#29983;copy&amp;#10;&amp;#10;  void (^blk) (BlkSum) = ^ (BlkSum sum) &amp;#123;&amp;#10;    NSLog(@&amp;#34;%@&amp;#34;,sum);     // &amp;#26080;&amp;#35770;blk&amp;#22312;&amp;#22534;&amp;#19978;&amp;#36824;&amp;#26159;&amp;#26632;&amp;#19978;&amp;#65292;&amp;#20316;&amp;#20026;&amp;#21442;&amp;#25968;&amp;#30340;Block&amp;#19981;&amp;#20250;&amp;#21457;&amp;#29983;copy&amp;#12290;&amp;#10;    NSLog(@&amp;#34;%@&amp;#34;,sum_blk); // &amp;#24403;blk copy&amp;#21040;&amp;#22534;&amp;#19978;&amp;#26102;&amp;#65292;sum_blk&amp;#20063;&amp;#34987;copy&amp;#20102;&amp;#19968;&amp;#20998;&amp;#21040;&amp;#22534;&amp;#19978;&amp;#19978;&amp;#12290;&amp;#10;  &amp;#125;;&amp;#10;  blk(sum_blk); // blk&amp;#22312;&amp;#26632;&amp;#19978;&amp;#10;&amp;#10;  blk = [[blk copy] autorelease];&amp;#10;  blk(sum_blk); // blk&amp;#22312;&amp;#22534;&amp;#19978;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ObjC对象，不同于基本类型，Block会引起对象的引用计数变化。&lt;br&gt;先看下面代码&lt;br&gt;执行结果为1 1 1 2 1。&lt;br&gt;&lt;strong&gt;globalObj和&lt;/strong&gt;staticObj在内存中的位置是确定的，所以Block copy时不会retain对象。&lt;br&gt;_instanceObj在Block copy时也没有直接retain _instanceObj对象本身，但会retain self。所以在Block中可以直接读写_instanceObj变量。&lt;br&gt;localObj在Block copy时，系统自动retain对象，增加其引用计数。&lt;br&gt;blockObj在Block copy时也不会retain。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface MyClass : NSObject &amp;#123;&amp;#10;    NSObject* _instanceObj;&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;@implementation MyClass&amp;#10;&amp;#10;NSObject* __globalObj = nil;&amp;#10;&amp;#10;- (id) init &amp;#123;&amp;#10;    if (self = [super init]) &amp;#123;&amp;#10;        _instanceObj = [[NSObject alloc] init];&amp;#10;    &amp;#125;&amp;#10;    return self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void) test &amp;#123;&amp;#10;    static NSObject* __staticObj = nil;&amp;#10;    __globalObj = [[NSObject alloc] init];&amp;#10;    __staticObj = [[NSObject alloc] init];&amp;#10;&amp;#10;    NSObject* localObj = [[NSObject alloc] init];&amp;#10;    __block NSObject* blockObj = [[NSObject alloc] init];&amp;#10;&amp;#10;    typedef void (^MyBlock)(void) ;&amp;#10;    MyBlock aBlock = ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, __globalObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, __staticObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, _instanceObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, localObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, blockObj);&amp;#10;    &amp;#125;;&amp;#10;    aBlock = [[aBlock copy] autorelease];&amp;#10;    aBlock();&amp;#10;&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [__globalObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [__staticObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [_instanceObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [localObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [blockObj retainCount]);&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;int main(int argc, char *argv[]) &amp;#123;&amp;#10;    @autoreleasepool &amp;#123;&amp;#10;        MyClass* obj = [[[MyClass alloc] init] autorelease];&amp;#10;        [obj test];&amp;#10;        return 0;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非ObjC对象，如GCD队列dispatch_queue_t。Block copy时并不会自动增加他的引用计数，这点要非常小心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Block中使用的ObjC对象的行为&quot;&gt;&lt;a href=&quot;#Block中使用的ObjC对象的行为&quot; class=&quot;headerlink&quot; title=&quot;Block中使用的ObjC对象的行为&quot;&gt;&lt;/a&gt;Block中使用的ObjC对象的行为&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) void(^myBlock)(void);&amp;#10;&amp;#10;MyClass* obj = [[[MyClass alloc] init] autorelease];&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  [obj doSomething];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次。&lt;/p&gt;
&lt;h2 id=&quot;retain-cycle&quot;&gt;&lt;a href=&quot;#retain-cycle&quot; class=&quot;headerlink&quot; title=&quot;retain cycle&quot;&gt;&lt;/a&gt;retain cycle&lt;/h2&gt;&lt;p&gt;retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];&amp;#10;[request setCompletionBlock:^&amp;#123;&amp;#10;  NSString* string = [request responseString];&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |&amp;#10;---&amp;#62; |           | --------&amp;#62; |           |&amp;#10;     | retain 2  | &amp;#60;-------- | retain 1  |&amp;#10;     |           |           |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决这个问题的办法是使用弱引用打断retain cycle：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];&amp;#10;[request setCompletionBlock:^&amp;#123;&amp;#10;  NSString* string = [request responseString];&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |&amp;#10;----&amp;#62;|           | --------&amp;#62; |           |&amp;#10;     | retain 1  | &amp;#60; - - - - | retain 1  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;request被持有者释放后。request 的retainCount变成0,request被dealloc，request释放持有的Block，导致Block的retainCount变成0，也被销毁。这样这两个对象内存都被回收。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |&amp;#10;--X-&amp;#62;|           | ----X---&amp;#62; |           |&amp;#10;     | retain 0  | &amp;#60; - - - - | retain 0  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;与上面情况类似的陷阱：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.myBlock = ^ &amp;#123;&amp;#10;  [self doSomething];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里self和myBlock循环引用，解决办法同上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block MyClass* weakSelf = self;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  [weakSelf doSomething];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, retain) NSString* someVar;&amp;#10;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, _someVer);&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里在Block中虽然没直接使用self，但使用了成员变量。在Block中使用成员变量，retain的不是这个变量，而会retain self。解决办法也和上面一样。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, retain) NSString* someVar;&amp;#10;&amp;#10;__block MyClass* weakSelf = self;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, self.someVer);&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString* str = _someVer;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, str);&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;retain cycle不只发生在两个对象之间，也可能发生在多个对象之间，这样问题更复杂，更难发现&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassA* objA = [[[ClassA alloc] init] autorelease];&amp;#10;objA.myBlock = ^&amp;#123;&amp;#10;    [self doSomething];&amp;#10;&amp;#125;;&amp;#10;self.objA = objA;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+-----------+           +-----------+           +-----------+&amp;#10;|   self    |           |   objA    |           |   Block   |&amp;#10;|           | --------&amp;#62; |           | --------&amp;#62; |           |&amp;#10;| retain 1  |           | retain 1  |           | retain 1  |&amp;#10;|           |           |           |           |           |&amp;#10;+-----------+           +-----------+           +-----------+&amp;#10;     ^                                                |&amp;#10;     |                                                |&amp;#10;     +------------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法同样是用__block打破循环引用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassA* objA = [[[ClassA alloc] init] autorelease];&amp;#10;&amp;#10;MyClass* weakSelf = self;&amp;#10;objA.myBlock = ^&amp;#123;&amp;#10;  [weakSelf doSomething];&amp;#10;&amp;#125;;&amp;#10;self.objA = objA;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：MRC中&lt;strong&gt;block是不会引起retain；但在ARC中&lt;/strong&gt;block则会引起retain。ARC中应该使用&lt;strong&gt;weak或&lt;/strong&gt;unsafe_unretained弱引用。__weak只能在iOS5以后使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Block使用对象被提前释放&quot;&gt;&lt;a href=&quot;#Block使用对象被提前释放&quot; class=&quot;headerlink&quot; title=&quot;Block使用对象被提前释放&quot;&gt;&lt;/a&gt;Block使用对象被提前释放&lt;/h2&gt;&lt;p&gt;看下面例子，有这种情况，如果不只是request持有了Block，另一个对象也持有了Block。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |   objA&amp;#10;----&amp;#62;|           | --------&amp;#62; |           |&amp;#60;--------&amp;#10;     | retain 1  | &amp;#60; - - - - | retain 2  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时如果request 被持有者释放。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |   objA&amp;#10;--X-&amp;#62;|           | --------&amp;#62; |           |&amp;#60;--------&amp;#10;     | retain 0  | &amp;#60; - - - - | retain 1  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时request已被完全释放，但Block仍被objA持有，没有释放，如果这时触发了Block，在Block中将访问已经销毁的request，这将导致程序crash。为了避免这种情况，开发者必须要注意对象和Block的生命周期。&lt;/p&gt;
&lt;p&gt;另一个常见错误使用是，开发者担心retain cycle错误的使用__block。比如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block kkProducView* weakSelf = self;&amp;#10;dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;  weakSelf.xx = xx;&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将Block作为参数传给dispatch_async时，系统会将Block拷贝到堆上，如果Block中使用了实例变量，还将retain self，因为dispatch_async并不知道self会在什么时候被释放，为了确保系统调度执行Block中的任务时self没有被意外释放掉，dispatch_async必须自己retain一次self，任务完成后再release self。但这里使用__block，使dispatch_async没有增加self的引用计数，这使得在系统在调度执行Block之前，self可能已被销毁，但系统并不知道这个情况，导致Block被调度执行时self已经被释放导致crash。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// MyClass.m&amp;#10;- (void) test &amp;#123;&amp;#10;  __block MyClass* weakSelf = self;&amp;#10;  double delayInSeconds = 10.0;&amp;#10;  dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));&amp;#10;  dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&amp;#123;&amp;#10;    NSLog(@&amp;#34;%@&amp;#34;, weakSelf);&amp;#10;&amp;#125;);&amp;#10;&amp;#10;// other.m&amp;#10;MyClass* obj = [[[MyClass alloc] init] autorelease];&amp;#10;[obj test];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里用dispatch_after模拟了一个异步任务，10秒后执行Block。但执行Block的时候MyClass* obj已经被释放了，导致crash。解决办法是不要使用__block。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下&lt;strong&gt;block不会增加引用计数，但ARC会，ARC下必须用&lt;/strong&gt;weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Block简介&quot;&gt;&lt;a href=&quot;#Block简介&quot; class=&quot;headerlink&quot; title=&quot;Block简介&quot;&gt;&lt;/a&gt;Block简介&lt;/h2&gt;&lt;p&gt;Block作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于Objective-C在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。&lt;/p&gt;
&lt;p&gt;可以这样理解，Block其实包含两个部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block执行的代码，这是在编译的时候已经生成好的；&lt;/li&gt;
&lt;li&gt;一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Block与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Github上优秀的Objective-C项目简介</title>
    <link href="http://www.jvaeyhcd.cc/2016/02/20/Github%E4%B8%8A%E4%BC%98%E7%A7%80%E7%9A%84Objective-C%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.jvaeyhcd.cc/2016/02/20/Github上优秀的Objective-C项目简介/</id>
    <published>2016-02-20T09:15:47.000Z</published>
    <updated>2016-05-21T07:43:22.000Z</updated>
    
    <content type="html">&lt;p&gt;主要对当前Github排名靠前的项目做一个简单的简介，方便自己快速了解 Objective-C的一些优秀的开源框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;&lt;br&gt;作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gavinkwoe/BeeFramework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BeeFramework&lt;/a&gt;&lt;br&gt;BeeFramework是一个iOS应用开发框架，由国内开发者郭虹宇创立并且在Github上开源。经过一年多的发展，BeeFramework在Github上，得到了广泛关注，有1000多的star数和400多的fork数&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BradLarson/GPUImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GPUImage&lt;/a&gt;&lt;br&gt;一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SDWebImage&lt;/a&gt;&lt;br&gt;作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/RestKit/RestKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RestKit&lt;/a&gt;&lt;br&gt;主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa&lt;/a&gt;&lt;br&gt;由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来,GitHub自家的函数式响应式编程范式的Objective-C实现，名字听着很高大上，学习曲线确实也比较陡，但是绝对会改变你对iOS编程的认知&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebookarchive/three20&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;three20&lt;/a&gt;&lt;br&gt;由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus, 算是 three20 的一个替代品&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MBProgressHUD&lt;/a&gt;&lt;br&gt;作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/magicalpanda/MagicalRecord&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MagicalRecord&lt;/a&gt;&lt;br&gt;作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FMDB&lt;/a&gt;&lt;br&gt;一个对 SQLite 进行封装的库, 使用起来方便, 简单&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mantle/Mantle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mantle&lt;/a&gt;&lt;br&gt;作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了。GitHub自家的产物，轻量级建模的首选，也可以很好的配合CoreData工作&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Grouper/FlatUIKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FlatUIKit&lt;/a&gt;&lt;br&gt;收集了很多扁平化 UI 的 iOS 组件, 方便使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pokeb/asi-http-request&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ASIHTTPRequest&lt;/a&gt;&lt;br&gt;一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/path/FastImageCache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FastImageCache&lt;/a&gt;&lt;br&gt;Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Masonry&lt;/a&gt;&lt;br&gt;一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/Shimmer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Shimmer&lt;/a&gt;&lt;br&gt;Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/TransitApp/SVProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVProgressHUD&lt;/a&gt;&lt;br&gt;又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONKit&lt;/a&gt;&lt;br&gt;主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jverkoey/nimbus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nimbus&lt;/a&gt;&lt;br&gt;作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/facebook-ios-sdk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Facebook SDK for iOS&lt;/a&gt;&lt;br&gt;Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AsyncDisplayKit&lt;/a&gt;&lt;br&gt;Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/supermarin/Alcatraz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alcatraz&lt;/a&gt;&lt;br&gt;Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jessesquires/JSQMessagesViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSQMessagesViewController&lt;/a&gt;&lt;br&gt;优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/xctool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xctool&lt;/a&gt;&lt;br&gt;是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI, OCLint 等测试工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OpenEmu/OpenEmu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenEmu&lt;/a&gt;&lt;br&gt;超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nicklockwood/iCarousel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iCarousel&lt;/a&gt;&lt;br&gt;作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/romaonthego/RESideMenu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RESideMenu&lt;/a&gt;&lt;br&gt;作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PNChart&lt;/a&gt;&lt;br&gt;作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/PonyDebugger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PonyDebugger&lt;/a&gt;&lt;br&gt;由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jverdi/JVFloatLabeledTextField&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVFloatLabeledTextField&lt;/a&gt;&lt;br&gt;作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CEWendel/SWTableViewCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SWTableViewCell&lt;/a&gt;&lt;br&gt;UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/levey/AwesomeMenu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AwesomeMenu&lt;/a&gt;&lt;br&gt;作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tonymillion/Reachability&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reachability&lt;/a&gt;&lt;br&gt;Reachablity 是用于检测 iOS 设备网络环境的库,Beeframeowrk中使用过的库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; VVDocumenter-Xcode&lt;/a&gt;&lt;br&gt;作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/physical-web&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Physical Web&lt;/a&gt;&lt;br&gt;由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samuelclay/NewsBlur&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NewsBlur&lt;/a&gt;&lt;br&gt;作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cocos2d/cocos2d-objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cocos2D-SpriteBuilder&lt;/a&gt;&lt;br&gt;一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/TTTAttributedLabel/TTTAttributedLabel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TTTAttributedLabel&lt;/a&gt;&lt;br&gt;UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/robbiehanson/CocoaAsyncSocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaAsyncSocket&lt;/a&gt;&lt;br&gt;一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/devinross/tapkulibrary&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TapkuLibrary&lt;/a&gt;&lt;br&gt;作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CanvasPod/Canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Canvas&lt;/a&gt;&lt;br&gt;无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/SocketRocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SocketRocket&lt;/a&gt;&lt;br&gt;Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ECSlidingViewController/ECSlidingViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECSlidingViewController&lt;/a&gt;&lt;br&gt;一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stig/json-framework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Json Framework&lt;/a&gt;&lt;br&gt;用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/Tweaks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tweaks&lt;/a&gt;&lt;br&gt;Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/realm/realm-cocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;realm-cocoa&lt;/a&gt;&lt;br&gt;Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/icanzilb/JSONModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONModel&lt;/a&gt;&lt;br&gt;一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/KVOController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;KVOController&lt;/a&gt;&lt;br&gt;一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mwaterfall/MWPhotoBrowser&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MWPhotoBrowser&lt;/a&gt;&lt;br&gt;一款简单的 iOS 照片浏览控件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samvermette/SVPullToRefresh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVPullToRefresh&lt;/a&gt;&lt;br&gt;&lt;b&gt;一款只需一行代码便可集成上拉刷新和下拉加载的组件&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/pop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;POP&lt;/a&gt;&lt;br&gt;facebook出品的paper，动画效果太好了，赶超apple的原生app一大截。pop就是paper的动画库！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dennisreimann/ioctocat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ioctocat&lt;/a&gt;&lt;br&gt;github的iOS客户端，目前开源代码是V1版本，V2版本在appstore上可以下载&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChatSecure/ChatSecure-iOS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ChatSecure&lt;/a&gt;&lt;br&gt;使用XMPP协议的IM开源软件，很强大，在appstore上可以下载&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FDFullscreenPopGesture&lt;/a&gt;&lt;br&gt;一个丝滑的全屏滑动返回手势,相关博客文章点击&lt;a href=&quot;http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Jvaeyhcd/TKSubmitTransition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TKSubmitTransition&lt;/a&gt;&lt;br&gt;非常漂亮的一个登录转场动画&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dzenbot/DZNEmptyDataSet&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DZNEmptyDataSet&lt;/a&gt;&lt;br&gt;非常方便的对一些没有数据的UITableView或者UIScrollView加上提示图片和文字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nicklockwood/iRate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iRate&lt;/a&gt;&lt;br&gt;一个开源的评分控件，能够非常友好的设置提醒用户去评论我们的app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nicklockwood/iVersion&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iVersion&lt;/a&gt;&lt;br&gt;和iRate一样出自同一个人之手，，这个是提示用户更新版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/PureLayout/PureLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PureLayout&lt;/a&gt;&lt;br&gt;自动布局&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;文本相关&quot;&gt;&lt;a href=&quot;#文本相关&quot; class=&quot;headerlink&quot; title=&quot;文本相关&quot;&gt;&lt;/a&gt;文本相关&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/slackhq/SlackTextViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SlackTextViewController&lt;/a&gt;&lt;br&gt;你曾经用过Slack iOS应用吗？如果你在较大的软件公司工作，也许会用过。对那些没用过的人呢？—?Slack令人激动。用到Slack的应用也是这样，尤其是用作极佳、定制的文本输入控制时。这时你有了一个现成可用在应用中的代码。自适应文本区域？试一下。手势识别、自动填充、多媒体合并？试一下。快速drop-in解决方案？试一下。其他还想要什么？SlackTextViewController 可以替代 UITableViewController &amp;amp; UICollectionViewController。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/honcheng/RTLabel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RTLabel&lt;/a&gt;&lt;br&gt;用于显示html的Label&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/Shimmer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Shimmer&lt;/a&gt;&lt;br&gt;滑动解锁效果的界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/daiweilai/DDRichText&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DDRichText&lt;/a&gt;&lt;br&gt;为图文混排提供了一个思路&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;进度条&quot;&gt;&lt;a href=&quot;#进度条&quot; class=&quot;headerlink&quot; title=&quot;进度条&quot;&gt;&lt;/a&gt;进度条&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ninjinkun/NJKWebViewProgress&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NJKWebViewProgress&lt;/a&gt;&lt;br&gt;web界面加载进度条&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MBProgressHUD&lt;/a&gt;&lt;br&gt;MBProgressHUD 使用非常广泛，网上很多基于ta的封装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SVProgressHUD/SVProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVProgressHUD&lt;/a&gt;&lt;br&gt;Navigation的扩展，强烈推荐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/scalessec/Toast&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Toast&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;导航栏&quot;&gt;&lt;a href=&quot;#导航栏&quot; class=&quot;headerlink&quot; title=&quot;导航栏&quot;&gt;&lt;/a&gt;导航栏&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ltebean/LTNavigationbar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LTNavigationbar&lt;/a&gt;&lt;br&gt;上下滑动动态改变导航栏颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JazysYu/JZNavigationExtension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JZNavigationExtension&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;键盘类&quot;&gt;&lt;a href=&quot;#键盘类&quot; class=&quot;headerlink&quot; title=&quot;键盘类&quot;&gt;&lt;/a&gt;键盘类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hackiftekhar/IQKeyboardManager&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IQKeyboardManager&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/michaeltyson/TPKeyboardAvoiding&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TPKeyboardAvoiding&lt;/a&gt;&lt;br&gt;这个我用得很多，界面上如果有输入框可以界面会跟着键盘动，而不被键盘挡住。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基础工具类以及Category&quot;&gt;&lt;a href=&quot;#基础工具类以及Category&quot; class=&quot;headerlink&quot; title=&quot;基础工具类以及Category&quot;&gt;&lt;/a&gt;基础工具类以及Category&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/FabrizioBrancati/BFKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BFKit OC版本&lt;/a&gt;&lt;br&gt;国外的一个大神写的很好用的分类，比较齐全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MatthewYork/DateTools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DateTools&lt;/a&gt;&lt;br&gt;很强大的日期工具类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/shaojiankui/iOS-Categories&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-Categories&lt;/a&gt;&lt;br&gt;很是全面的一个扩展 iOS中的各种Objective-C Category, a collection of useful Objective-C Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fpt-software/Material-Controls-For-iOS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Material-Controls-For-iOS&lt;/a&gt;&lt;br&gt;大神模仿谷歌做的iOS原生特效控件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zwaldowski/BlocksKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlocksKit&lt;/a&gt;&lt;br&gt;为基础类提供Block支持，很好用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;弹出框&quot;&gt;&lt;a href=&quot;#弹出框&quot; class=&quot;headerlink&quot; title=&quot;弹出框&quot;&gt;&lt;/a&gt;弹出框&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kevin0571/STPopup&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STPopup&lt;/a&gt;&lt;br&gt;很方便的弹出框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/adad184/MMPopupView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MMPopupView&lt;/a&gt;&lt;br&gt;里脊串的弹出框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nealyoung/NYAlertViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NYAlertViewController&lt;/a&gt;&lt;br&gt;非常强大的弹出框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/12207480/TYAlertController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TYAlertController&lt;/a&gt;&lt;br&gt;很好很强大的弹出框，多种样式满足你的需求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/UncleJoke/JKPopMenuView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JKPopMenuView&lt;/a&gt;&lt;br&gt;一个简单的弹出菜单&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;其它&quot;&gt;&lt;a href=&quot;#其它&quot; class=&quot;headerlink&quot; title=&quot;其它&quot;&gt;&lt;/a&gt;其它&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CEWendel/SWTableViewCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SWTableViewCell&lt;/a&gt;&lt;br&gt;自定义侧滑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MortimerGoro/MGSwipeTableCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MGSwipeTableCell&lt;/a&gt;&lt;br&gt;同上自定义侧滑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FDFullscreenPopGesture&lt;/a&gt;&lt;br&gt;全屏滑动返回上级页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jivesoftware/PDTSimpleCalendar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDTSimpleCalendar&lt;/a&gt;&lt;br&gt;一款日历控件，可以看看&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Xcode插件&quot;&gt;&lt;a href=&quot;#Xcode插件&quot; class=&quot;headerlink&quot; title=&quot;Xcode插件&quot;&gt;&lt;/a&gt;Xcode插件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kattrali/cocoapods-xcode-plugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cocoapods-xcode-plugin&lt;/a&gt;&lt;br&gt;Dependency management helper for your CocoaPods, right in Xcode.&lt;br&gt;用于在Xcode中管理CocoaPods依赖库。&lt;br&gt;&lt;img src=&quot;http://wangzz.github.io/images/article1/plugin_cocoapods_menu.png&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/qfish/XAlign&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XAlign&lt;/a&gt;&lt;br&gt;An amazing Xcode plugin to align regular code. it can align Xnything in any way you want.&lt;br&gt;方便实现代码对其功能，使代码风格统一。&lt;br&gt;&lt;img src=&quot;http://wangzz.github.io/images/article1/plugin_align.gif&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/supermarin/Alcatraz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alcatraz&lt;/a&gt;&lt;br&gt;Alcatraz is an open-source package manager for Xcode 5+. It lets you discover and install plugins, templates and color schemes without the need for manually cloning or copying files. It installs itself as a part of Xcode and it feels like home.—Xcode插件管理工具。&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/919efe4e1e53237df51d7010c862bd5c04fd6a70/687474703a2f2f616c63617472617a2e696f2f696d616765732f73637265656e73686f744032782e706e67&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VVDocumenter-Xcode&lt;/a&gt;&lt;br&gt;提供了为代码增加注视的最快捷方式,非常好的Xcode插件。&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ca5518c9872e15b8a95b9d8c5f44bc331977d710/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f53637265656e53686f742e676966&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;br&gt;并且支持了Swift的注释，太棒了！&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/58e452b57245cd79c2e59ac7926609be4dffbfd8/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f7676646f63756d656e7465722d73776966742e676966&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ksuther/KSImageNamed-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;KSImageNamed-Xcode&lt;/a&gt;&lt;br&gt;当输入[NSImage imageNamed: 或者[UIImage imageNamed:时，会自动补全工程中可用的图片名称，同时能提供选中图片的预览。&lt;br&gt;&lt;img src=&quot;http://foggry.com/images/article1/plugin_image_named.gif&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自己做个笔记，方便以后工作遇到问题能够得到快速的解决&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;主要对当前Github排名靠前的项目做一个简单的简介，方便自己快速了解 Objective-C的一些优秀的开源框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;&lt;br&gt;作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gavinkwoe/BeeFramework&quot;&gt;BeeFramework&lt;/a&gt;&lt;br&gt;BeeFramework是一个iOS应用开发框架，由国内开发者郭虹宇创立并且在Github上开源。经过一年多的发展，BeeFramework在Github上，得到了广泛关注，有1000多的star数和400多的fork数&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BradLarson/GPUImage&quot;&gt;GPUImage&lt;/a&gt;&lt;br&gt;一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo安装新主题apollo</title>
    <link href="http://www.jvaeyhcd.cc/2016/02/20/Hexo%E5%AE%89%E8%A3%85%E6%96%B0%E4%B8%BB%E9%A2%98apollo/"/>
    <id>http://www.jvaeyhcd.cc/2016/02/20/Hexo安装新主题apollo/</id>
    <published>2016-02-20T08:15:35.000Z</published>
    <updated>2016-04-27T11:25:51.000Z</updated>
    
    <content type="html">&lt;p&gt;Hexo博客系统的流行原因，是因为他的个人性，而皮肤就是个人性的一种体现。Hexo换皮肤还是比较简单的,既可以自己根据默认的主题来修改，也可以到&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/themes/&lt;/a&gt;上去找主题。&lt;/p&gt;
&lt;p&gt;下面简单描述一下我安装apollo主题的过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;github上的文档给出了详细的安装命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo init #blogname#&amp;#10;cd #blogname# &amp;#10;npm install&amp;#10;npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive&amp;#10;git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;启用&quot;&gt;&lt;a href=&quot;#启用&quot; class=&quot;headerlink&quot; title=&quot;启用&quot;&gt;&lt;/a&gt;启用&lt;/h2&gt;&lt;p&gt;安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Extensions &amp;#25554;&amp;#20214;&amp;#21644;&amp;#30382;&amp;#32932;&amp;#10;## Plugins: https://hexo.io/plugins/&amp;#10;## Themes: https://hexo.io/themes/&amp;#10;# theme: landscape&amp;#10;theme: apollo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;启动hexo后修改成功后的皮肤如图所示&lt;br&gt;&lt;img src=&quot;/2016/02/20/Hexo安装新主题apollo/apollo.png&quot; alt=&quot;apollo主题&quot; title=&quot;apollo主题&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo博客系统的流行原因，是因为他的个人性，而皮肤就是个人性的一种体现。Hexo换皮肤还是比较简单的,既可以自己根据默认的主题来修改，也可以到&lt;a href=&quot;https://hexo.io/themes/&quot;&gt;https://hexo.io/themes/&lt;/a&gt;上去找主题。&lt;/p&gt;
&lt;p&gt;下面简单描述一下我安装apollo主题的过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
