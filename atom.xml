<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jvaeyhcd&#39;s Blog</title>
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jvaeyhcd.cc/"/>
  <updated>2016-03-20T09:43:31.000Z</updated>
  <id>http://jvaeyhcd.cc/</id>
  
  <author>
    <name>Jvaeyhcd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS几种不同传值方式</title>
    <link href="http://jvaeyhcd.cc/2016/03/17/iOS%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/"/>
    <id>http://jvaeyhcd.cc/2016/03/17/iOS几种不同传值方式/</id>
    <published>2016-03-17T07:17:32.000Z</published>
    <updated>2016-03-20T09:43:31.000Z</updated>
    
    <content type="html">&lt;p&gt;关于iOS的传值方式我所知道的一共有一下6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性传值&lt;/li&gt;
&lt;li&gt;代理传值&lt;/li&gt;
&lt;li&gt;block传值&lt;/li&gt;
&lt;li&gt;单例传值&lt;/li&gt;
&lt;li&gt;通知传值&lt;/li&gt;
&lt;li&gt;NSUserDefault保存数据传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h6 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h6&gt;&lt;p&gt;属性传值一般常用在页面中，从一个页面传值到另一个页面。例如从A页面跳转到B页面，如果需要将A页面中的某个值传递到B页面中，这个时候用到最简单的传值方式就是属性传值。&lt;/p&gt;
&lt;p&gt;下面是一个简单例子实现将AViewController中UItextFiled中的值传到BViewController中Label中。&lt;br&gt;AViewController.m中的代码如下：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;AViewController.h&amp;#34;&amp;#10;#import &amp;#34;BViewController.h&amp;#34;&amp;#10;&amp;#10;@interface AViewController ()&amp;#10;&amp;#10;//&amp;#23450;&amp;#20041;&amp;#36755;&amp;#20837;&amp;#26694;&amp;#10;@property (nonatomic, strong) UITextField *textField;&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation AViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;    [super viewDidLoad];&amp;#10;    // Do any additional setup after loading the view.&amp;#10;    &amp;#10;    [self.view addSubview:self.textField];&amp;#10;    //&amp;#23450;&amp;#20041;&amp;#28857;&amp;#20987;&amp;#36339;&amp;#36716;&amp;#30340;&amp;#25353;&amp;#38062;&amp;#10;    UIButton *pushBtn = [[UIButton alloc]initWithFrame:CGRectMake(20, 150, 100, 30)];&amp;#10;    pushBtn.titleLabel.font = [UIFont systemFontOfSize:12];&amp;#10;    [pushBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];&amp;#10;    [pushBtn setTitle:@&amp;#34;push&amp;#26174;&amp;#31034;&amp;#34; forState:UIControlStateNormal];&amp;#10;    [pushBtn setBackgroundColor:[UIColor yellowColor]];&amp;#10;    [pushBtn addTarget:self action:@selector(pushAction) forControlEvents:UIControlEventTouchUpInside];&amp;#10;    [self.view addSubview:pushBtn];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)pushAction &amp;#123;&amp;#10;    //&amp;#23450;&amp;#20041;&amp;#36339;&amp;#36716;&amp;#39029;&amp;#38754;&amp;#65292;&amp;#24182;&amp;#32473;B&amp;#39029;&amp;#38754;str&amp;#36171;&amp;#20540;&amp;#10;    BViewController *vc = [[BViewController alloc]init];&amp;#10;    vc.str = self.textField.text;&amp;#10;    [self.navigationController pushViewController:vc animated:YES];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;    [super didReceiveMemoryWarning];&amp;#10;    // Dispose of any resources that can be recreated.&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (UITextField *)textField &amp;#123;&amp;#10;    if (!_textField) &amp;#123;&amp;#10;        _textField = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 280, 30)];&amp;#10;        _textField.borderStyle = UITextBorderStyleRoundedRect;&amp;#10;    &amp;#125;&amp;#10;    return _textField;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;BViewController.h文件中，声明被赋值的属性&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;UIKit/UIKit.h&amp;#62;&amp;#10;&amp;#10;@interface BViewController : UIViewController&amp;#10;&amp;#10;@property (nonatomic, copy) NSString *str;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;BViewController.m中显示AViewController传递过来的属性值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;BViewController.h&amp;#34;&amp;#10;&amp;#10;@interface BViewController ()&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation BViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;    [super viewDidLoad];&amp;#10;    // Do any additional setup after loading the view.&amp;#10;    self.view.backgroundColor = [UIColor whiteColor];&amp;#10;    &amp;#10;    UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 100, 20)];&amp;#10;    label.font = [UIFont systemFontOfSize:14];&amp;#10;    label.textColor = [UIColor blackColor];&amp;#10;    //&amp;#26174;&amp;#31034;AViewController&amp;#20256;&amp;#36882;&amp;#36807;&amp;#26469;&amp;#30340;&amp;#20540;&amp;#10;    label.text = self.str;&amp;#10;    [self.view addSubview:label];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;    [super didReceiveMemoryWarning];&amp;#10;    // Dispose of any resources that can be recreated.&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h6 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h6&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS的传值方式我所知道的一共有一下6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性传值&lt;/li&gt;
&lt;li&gt;代理传值&lt;/li&gt;
&lt;li&gt;block传值&lt;/li&gt;
&lt;li&gt;单例传值&lt;/li&gt;
&lt;li&gt;通知传值&lt;/li&gt;
&lt;li&gt;NSUserDefault保存数据传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App Store上线完整流程</title>
    <link href="http://jvaeyhcd.cc/2016/03/05/App-Store%E4%B8%8A%E7%BA%BF%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"/>
    <id>http://jvaeyhcd.cc/2016/03/05/App-Store上线完整流程/</id>
    <published>2016-03-05T09:25:33.000Z</published>
    <updated>2016-03-18T08:00:18.000Z</updated>
    
    <content type="html">&lt;p&gt;经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。&lt;/p&gt;
&lt;h2 id=&quot;预先准备&quot;&gt;&lt;a href=&quot;#预先准备&quot; class=&quot;headerlink&quot; title=&quot;预先准备&quot;&gt;&lt;/a&gt;预先准备&lt;/h2&gt;&lt;p&gt;在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h6 id=&quot;Step-1-申请开发者帐号&quot;&gt;&lt;a href=&quot;#Step-1-申请开发者帐号&quot; class=&quot;headerlink&quot; title=&quot;Step 1:申请开发者帐号&quot;&gt;&lt;/a&gt;Step 1:申请开发者帐号&lt;/h6&gt;&lt;p&gt;如果您现在已有开发者帐号，那么恭喜您，您可以直接跳过此步骤直接进入下一步骤。苹果开发者帐号分为三种：个人开发者帐号、公司帐号、企业帐号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人帐号（Individual）:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：99美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：是&lt;/li&gt;
&lt;li&gt;最大uuid支持数：100&lt;/li&gt;
&lt;li&gt;协作人数：1人（开发者自己）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：“个人”开发者可以申请升级“公司”，可以通过拨打苹果公司客服电话（400 6701 855）来咨询和办理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 公司帐号（Company）: &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：99美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：是&lt;/li&gt;
&lt;li&gt;最大uuid支持数：100&lt;/li&gt;
&lt;li&gt;协作人数：多人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：允许多个开发者进行协作开发，比个人多一些帐号管理的设置，可设置多个Apple ID，分4种管理级别的权限。申请时需要填写公司的邓白氏编码（DUNS Number）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 企业帐号（Enterprise）: &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：299美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：否&lt;/li&gt;
&lt;li&gt;最大uuid支持数：不限制&lt;/li&gt;
&lt;li&gt;协作人数：多人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：需要注意的是，企业账号开发的应用不能上线App Store，适合那些不希望公开发布应用的企业。同样，申请时也需要公司的邓白氏编码（DUNS Number）。&lt;/p&gt;
&lt;h6 id=&quot;Step-2-App-ID（应用ID）&quot;&gt;&lt;a href=&quot;#Step-2-App-ID（应用ID）&quot; class=&quot;headerlink&quot; title=&quot;Step 2:App ID（应用ID）&quot;&gt;&lt;/a&gt;Step 2:App ID（应用ID）&lt;/h6&gt;&lt;p&gt;App ID是识别不同应用程序的唯一标示符。每个app都需要一个App ID或者app标识。目前有两种类型的App标识：一个是精确的App ID（explicit App ID），一个是通配符App ID（wildcard App ID）。使用通配符的App ID可以用来构建和安装多个程序。尽管通配符App ID非常方便，但是一个精确的App ID也是需要的，尤其是当App使用iCloud 或者使用其他iOS功能的时候，比如Game Center、Push Notifications或者IAP。如果你已经申请开发者帐号，接下你需要登录&lt;a href=&quot;https://developer.apple.com/membercenter/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/membercenter/。&lt;/a&gt;&lt;br&gt;登录成功后界面如下：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/developer_center.png&quot; alt=&quot;hexo-theme-apollo&quot; title=&quot;hexo-theme-apollo&quot;&gt;&lt;br&gt;点击“Certificates,Identifiers&amp;amp;Profiles”进入到&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/Identifiers.png&quot; alt=&quot;Identifiers&quot; title=&quot;Identifiers&quot;&gt;&lt;br&gt;选择Identifiers，然后点击“＋”注册你自己的应用的App Id&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_app_id.png&quot; alt=&quot;create_app_id&quot; title=&quot;create_app_id&quot;&gt;&lt;br&gt;以上两项设置好后，点击下一步，然后注册即可，这样一个App Id就创建好了。接下来需要设置开发证书。&lt;/p&gt;
&lt;h6 id=&quot;Step-3-Distribution-Certificate-发布证书&quot;&gt;&lt;a href=&quot;#Step-3-Distribution-Certificate-发布证书&quot; class=&quot;headerlink&quot; title=&quot;Step 3:Distribution Certificate(发布证书)&quot;&gt;&lt;/a&gt;Step 3:Distribution Certificate(发布证书)&lt;/h6&gt;&lt;p&gt;iOS应用都有一个安全证书用于验证开发者身份和签名。为了可以向App Store提交app，你需要创建一个iOS provisioning profile 。首先需要创建一个distribution certificate（发布证书），过程类似于创建一个development certificate（开发证书）。如果你已经在实体设备上测试你的App，那么你对创建development certificate就已经很熟悉了。&lt;/p&gt;
&lt;p&gt;首先选择Certificate,然后点击“＋”&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step1.png&quot; alt=&quot;create_certificates_step1&quot; title=&quot;create_certificates_step1&quot;&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step2.png&quot; alt=&quot;create_certificates_step2&quot; title=&quot;create_certificates_step2&quot;&gt;
&lt;p&gt;然后点击“下一步”来到如下界面：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step3.png&quot; alt=&quot;create_certificates_step3&quot; title=&quot;create_certificates_step3&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里需要上传一个.certSigningRequest文件来生成相应的证书。下面简单讲一下.certSigningRequest文件的生成方法：&lt;br&gt;首先打开“钥匙串访问”，在菜单中选择“钥匙串访问”-&amp;gt;“证书助理”-&amp;gt;“从证书颁发机构请求证书…”。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certSigningRequest_step1.png&quot; alt=&quot;create_certSigningRequest_step1&quot; title=&quot;create_certSigningRequest_step1&quot;&gt;&lt;br&gt;然后填写好相应的信息，注意：选择保存到磁盘。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certSigningRequest_step2.png&quot; alt=&quot;create_certSigningRequest_step2&quot; title=&quot;create_certSigningRequest_step2&quot;&gt;&lt;br&gt;点击继续，然后会生成一个.certSigningRequest文件。&lt;br&gt;然后选择生成的.certSigningRequest文件，点击下一步即可生成相应的证书。&lt;/p&gt;
&lt;h6 id=&quot;Step-4-Provisioning-Profile-配置文件&quot;&gt;&lt;a href=&quot;#Step-4-Provisioning-Profile-配置文件&quot; class=&quot;headerlink&quot; title=&quot;Step 4:Provisioning Profile(配置文件)&quot;&gt;&lt;/a&gt;Step 4:Provisioning Profile(配置文件)&lt;/h6&gt;&lt;p&gt;一旦你创建了App ID和distribution certificate，你可以创建一个iOS provisioning profile以方便在App Store中销售你的App。Provisioning Profile主要分为开发配置文件和发布配置文件，发布配置文件中又分App Store配置文件和Ad Hoc配置文件。App Store类型的Provisioning Profile顾名思义是用于发布到App Store的配置文件。Ad Hoc的Provisioning Profile配置文件是用于发布应用内的测试包的，在应用还没有上线的时候需要发ipa给客户安装的时候需要用到，只需要获取到客户手机的UDID然后生成相应的Ad Hoc类型的Provisioning Profile文件然后打包发布即可。&lt;br&gt;同样Provisioning Profile的创建方式如下：&lt;br&gt;选择“Provisioning Profiles”，然后点击“➕”创建Provisioning Profiles文件&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step1.png&quot; alt=&quot;create_pp_step1&quot; title=&quot;create_pp_step1&quot;&gt;
&lt;p&gt;选择相应的Provisioning Profiles文件类型&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step2.png&quot; alt=&quot;create_pp_step2&quot; title=&quot;create_pp_step2&quot;&gt;&lt;br&gt;选择您需要生成Provisioning Profiles文件的App ID&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step3.png&quot; alt=&quot;create_pp_step3&quot; title=&quot;create_pp_step3&quot;&gt;&lt;br&gt;选择相应的证书&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step4.png&quot; alt=&quot;create_pp_step4&quot; title=&quot;create_pp_step4&quot;&gt;&lt;br&gt;选择已注册的设备&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step5.png&quot; alt=&quot;create_pp_step5&quot; title=&quot;create_pp_step5&quot;&gt;&lt;br&gt;然后点击下一步即可生成Provisioning Profiles文件，点击下载，然后双击打开。&lt;/p&gt;
&lt;h6 id=&quot;Step-5-Build-Settings-生成设置&quot;&gt;&lt;a href=&quot;#Step-5-Build-Settings-生成设置&quot; class=&quot;headerlink&quot; title=&quot;Step 5:Build Settings(生成设置)&quot;&gt;&lt;/a&gt;Step 5:Build Settings(生成设置)&lt;/h6&gt;&lt;p&gt;配置App ID、distribution certificate 和provisioning profile已经完成，是时候配置Xcode中target的build settings了。在Xcode Project  Navigator的targets列表中选择一个target，打开顶部的Build Settings选项，然后更新一下Code Signing来跟之前创建的distribution provisioning profile相匹配。最近添加的provisioning profiles有时候不会立马就在build settings的Code Signing中看到，重启一下Xcode就可以解决这个问题。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/build_setting.png&quot; alt=&quot;build_setting&quot; title=&quot;build_setting&quot;&gt;&lt;/p&gt;
&lt;h6 id=&quot;Step-6-Deployment-Target-部署目标&quot;&gt;&lt;a href=&quot;#Step-6-Deployment-Target-部署目标&quot; class=&quot;headerlink&quot; title=&quot;Step 6:Deployment Target(部署目标)&quot;&gt;&lt;/a&gt;Step 6:Deployment Target(部署目标)&lt;/h6&gt;&lt;p&gt;所有配置都已配好后，就可以开始打包了生成ipa了。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/archive.png&quot; alt=&quot;archive&quot; title=&quot;archive&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;iTunes-Connect相关配置&quot;&gt;&lt;a href=&quot;#iTunes-Connect相关配置&quot; class=&quot;headerlink&quot; title=&quot;iTunes Connect相关配置&quot;&gt;&lt;/a&gt;iTunes Connect相关配置&lt;/h2&gt;&lt;h6 id=&quot;Step-1-创建“我的App”&quot;&gt;&lt;a href=&quot;#Step-1-创建“我的App”&quot; class=&quot;headerlink&quot; title=&quot;Step 1:创建“我的App”&quot;&gt;&lt;/a&gt;Step 1:创建“我的App”&lt;/h6&gt;&lt;p&gt;首先用你自己的开发者帐号登录到&lt;a href=&quot;https://itunesconnect.apple.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iTunes Connect&lt;/a&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step1.png&quot; alt=&quot;itunes_connect_step1&quot; title=&quot;itunes_connect_step1&quot;&gt;
&lt;p&gt;登录成功后点击“我的App”，然后点击“＋”-&amp;gt;“新建App”&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step2.png&quot; alt=&quot;itunes_connect_step2&quot; title=&quot;itunes_connect_step2&quot;&gt;&lt;br&gt;其中平台选择iOS，名称为你的app的名词，主要语言为你的app的主要语言，套装ID为之前创建的App ID，也就是Xcode工程中的Bundle ID。&lt;br&gt;点击下一步，创建成功后，选择你刚创建成功的应用，进行相关的设置。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step3.png&quot; alt=&quot;itunes_connect_step3&quot; title=&quot;itunes_connect_step3&quot;&gt;&lt;/p&gt;
&lt;p&gt;相关设置比较简单就不再多说。&lt;/p&gt;
&lt;h6 id=&quot;Step-2-打包上传到iTunes-Connect&quot;&gt;&lt;a href=&quot;#Step-2-打包上传到iTunes-Connect&quot; class=&quot;headerlink&quot; title=&quot;Step 2:打包上传到iTunes Connect&quot;&gt;&lt;/a&gt;Step 2:打包上传到iTunes Connect&lt;/h6&gt;&lt;p&gt;配置好了iTunes Connect的相关配置后，就可以将我们生成的ipa包上传到iTunes Connect上了。Xcode中配置完成后archive成功后Xcode会弹出如下界面：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/upload_itunes_connect.png&quot; alt=&quot;upload_itunes_connect&quot; title=&quot;upload_itunes_connect&quot;&gt;&lt;br&gt; 上传到iTunes Connect有两种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法一 &lt;/strong&gt;&lt;br&gt;直接点击上图的“Upload to App Store”按钮直接上传到App Store。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法二 &lt;/strong&gt;&lt;br&gt;先导出ipa，然后使用Application Loader上传到App Store。&lt;br&gt;点击“Export”，会弹出如下界面，选择导出的类型，这里要上传App Store，所以选择第一种。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/archive_step_1.png&quot; alt=&quot;archive_step_1&quot; title=&quot;archive_step_1&quot;&gt;&lt;br&gt;点击“下一步”，默认回去检查你的证书，如果没有什么问题一直下一步，最后会在桌面生成一个ipa的包。然后在Xcode中打开Application Loader。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_1.png&quot; alt=&quot;application_loader_1&quot; title=&quot;application_loader_1&quot;&gt;&lt;br&gt;用你自己的开发者帐号登录Application Loader，&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_login.png&quot; alt=&quot;application_loader_login&quot; title=&quot;application_loader_login&quot;&gt;&lt;br&gt;登录成功后选取你刚刚生成的ipa&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_step2.png&quot; alt=&quot;application_loader_step2&quot; title=&quot;application_loader_step2&quot;&gt;&lt;br&gt;然后上传提交到App Store。&lt;/p&gt;
&lt;h6 id=&quot;Step-3-提交给苹果审核&quot;&gt;&lt;a href=&quot;#Step-3-提交给苹果审核&quot; class=&quot;headerlink&quot; title=&quot;Step 3:提交给苹果审核&quot;&gt;&lt;/a&gt;Step 3:提交给苹果审核&lt;/h6&gt;&lt;p&gt;完成上面的步骤后，返回到iTunes Connect界面，选择你先前创建的App，在它的活动页面下可以看到所有已上传过的ipa版本。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step4.png&quot; alt=&quot;itunes_connect_step4&quot; title=&quot;itunes_connect_step4&quot;&gt;&lt;br&gt;选择App信息配置界面，找到“构建版本”，然后选择你刚刚上传的构建版本，然后提交审核即可&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step5.png&quot; alt=&quot;itunes_connect_step5&quot; title=&quot;itunes_connect_step5&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。&lt;/p&gt;
&lt;h2 id=&quot;预先准备&quot;&gt;&lt;a href=&quot;#预先准备&quot; class=&quot;headerlink&quot; title=&quot;预先准备&quot;&gt;&lt;/a&gt;预先准备&lt;/h2&gt;&lt;p&gt;在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RESideMenu在所有界面都会侧滑的问题解决办法</title>
    <link href="http://jvaeyhcd.cc/2016/03/05/RESideMenu%E5%9C%A8%E6%89%80%E6%9C%89%E7%95%8C%E9%9D%A2%E9%83%BD%E4%BC%9A%E4%BE%A7%E6%BB%91%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://jvaeyhcd.cc/2016/03/05/RESideMenu在所有界面都会侧滑的问题解决办法/</id>
    <published>2016-03-05T08:24:40.000Z</published>
    <updated>2016-03-05T09:11:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;奉上参考原文链接地址：&lt;a href=&quot;http://blog.csdn.net/icetime17/article/details/46883915&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/icetime17/article/details/46883915&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;RESideMenu基本用法&quot;&gt;&lt;a href=&quot;#RESideMenu基本用法&quot; class=&quot;headerlink&quot; title=&quot;RESideMenu基本用法&quot;&gt;&lt;/a&gt;RESideMenu基本用法&lt;/h2&gt;&lt;p&gt;首先创建window的rootViewController，在RootViewController引入并继承RESideMenu及其RESideMenuDelegate. &lt;/p&gt;
&lt;p&gt;具体相关代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;RESideMenu.h&amp;#34;&amp;#10;@interface RootViewController : RESideMenu &amp;#60;RESideMenuDelegate&amp;#62;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在RootViewController.m文件中设置好RESideMenu&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;RootViewController.h&amp;#34;&amp;#10;@interface RootViewController ()&amp;#10;@end&amp;#10;&amp;#10;@implementation RootViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;  [super viewDidLoad];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;  [super didReceiveMemoryWarning];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)awakeFromNib &amp;#123;&amp;#10;  self.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent;&amp;#10;  self.contentViewShadowColor = [UIColor blackColor];&amp;#10;  self.contentViewShadowOffset = CGSizeMake(0, 0);&amp;#10;  self.contentViewShadowOpacity = 0.6;&amp;#10;  self.contentViewShadowRadius = 12;&amp;#10;  self.contentViewShadowEnabled = NO;&amp;#10;&amp;#10;  self.contentViewController = [self.storyboard instantiateViewControllerWithIdentifier:@&amp;#34;ContentViewController&amp;#34;];&amp;#10;  self.leftMenuViewController = [self.storyboard instantiateViewControllerWithIdentifier:@&amp;#34;LeftMenuViewController&amp;#34;];&amp;#10;&amp;#10;  self.delegate = self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;#pragma mark - RESideMenu Delegate&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu willShowMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu didShowMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu willHideMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)sideMenu:(RESideMenu *)sideMenu didHideMenuViewController:(UIViewController *)menuViewController &amp;#123;&amp;#10;&amp;#125;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;遇到问题&quot;&gt;&lt;a href=&quot;#遇到问题&quot; class=&quot;headerlink&quot; title=&quot;遇到问题&quot;&gt;&lt;/a&gt;遇到问题&lt;/h2&gt;&lt;p&gt;在RESideMenu的使用过程中，发现所有的界面都加上了侧滑功能，并且iOS的滑动返回功能失效了。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;通过观察RESideMenu的源码发现，RESideMenu类中有一个BOOL属性panGestureEnabled, 可以将其视为侧滑效果的开关。以RESideMenu的panGestureEnabled属性为突破口，采用通知的方式来解决这个问题。&lt;br&gt;在RootViewController.m文件中加入如下代码：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&amp;#10;  [super viewDidLoad];&amp;#10;&amp;#10;  [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                           selector:@selector(disableRESideMenu)&amp;#10;                                               name:@&amp;#34;disableRESideMenu&amp;#34;&amp;#10;                                             object:nil];&amp;#10;  [[NSNotificationCenter defaultCenter] addObserver:self&amp;#10;                                           selector:@selector(enableRESideMenu) &amp;#10;                                               name:@&amp;#34;enableRESideMenu&amp;#34;&amp;#10;                                             object:nil];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)enableRESideMenu &amp;#123;&amp;#10;  self.panGestureEnabled = YES;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)disableRESideMenu &amp;#123;&amp;#10;  self.panGestureEnabled = NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在其他页面需要禁止侧滑的时候调用如下代码,发送通知&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#20851;&amp;#38381;&amp;#20391;&amp;#28369;&amp;#25928;&amp;#26524;&amp;#10;[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;#34;disableRESideMenu&amp;#34;&amp;#10;                                                            object:self&amp;#10;                                                          userInfo:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;相反在需要侧滑的地方调用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#24320;&amp;#21551;&amp;#20391;&amp;#28369;&amp;#25928;&amp;#26524;&amp;#10;[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;#34;enableRESideMenu&amp;#34;&amp;#10;                                                    object:self&amp;#10;                                                  userInfo:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Block正确使用避免Cycle Retain和Crash</title>
    <link href="http://jvaeyhcd.cc/2016/02/24/Block%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E9%81%BF%E5%85%8DCycle-Retain%E5%92%8CCrash/"/>
    <id>http://jvaeyhcd.cc/2016/02/24/Block正确使用避免Cycle-Retain和Crash/</id>
    <published>2016-02-24T01:28:26.000Z</published>
    <updated>2016-02-25T03:11:24.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下&lt;strong&gt;block不会增加引用计数，但ARC会，ARC下必须用&lt;/strong&gt;weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6&gt;Block简介&lt;/h6&gt;

&lt;p&gt;Block作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于Objective-C在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。&lt;/p&gt;
&lt;p&gt;可以这样理解，Block其实包含两个部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block执行的代码，这是在编译的时候已经生成好的；&lt;/li&gt;
&lt;li&gt;一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Block与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h6&gt;Block基本语法&lt;/h6&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#22768;&amp;#26126;&amp;#19968;&amp;#20010;Block&amp;#21464;&amp;#37327;&amp;#10;long (^sum) (int, int) = nil;&amp;#10;// sum&amp;#26159;&amp;#20010;Block&amp;#21464;&amp;#37327;&amp;#65292;&amp;#35813;Block&amp;#31867;&amp;#22411;&amp;#26377;&amp;#20004;&amp;#20010;int&amp;#22411;&amp;#21442;&amp;#25968;&amp;#65292;&amp;#36820;&amp;#22238;&amp;#31867;&amp;#22411;&amp;#26159;long&amp;#12290;&amp;#10;&amp;#10;// &amp;#23450;&amp;#20041;Block&amp;#24182;&amp;#36171;&amp;#32473;&amp;#21464;&amp;#37327;sum&amp;#10;sum = ^ long (int a, int b) &amp;#123;&amp;#10;  return a + b;&amp;#10;&amp;#125;;&amp;#10;&amp;#10;// &amp;#35843;&amp;#29992;Block&amp;#65306;&amp;#10;long s = sum(1, 2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义一个实例函数，该函数返回Block：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (long (^)(int, int)) sumBlock &amp;#123;&amp;#10;    int base = 100;&amp;#10;    return [[ ^ long (int a, int b) &amp;#123;&amp;#10;      return base + a + b;&amp;#10;    &amp;#125; copy] autorelease];&amp;#10;  &amp;#125;&amp;#10;&amp;#10;// &amp;#35843;&amp;#29992;Block&amp;#10;[self sumBlock](1,2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是不是感觉很怪？为了看的舒服，我们把Block类型typedef一下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef long (^BlkSum)(int, int);&amp;#10;&amp;#10;- (BlkSum) sumBlock &amp;#123;&amp;#10;    int base = 100;&amp;#10;    BlkSum blk = ^ long (int a, int b) &amp;#123;&amp;#10;      return base + a + b;&amp;#10;    &amp;#125;&amp;#10;    return [[blk copy] autorelease];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h6&gt;Block在内存中的位置&lt;/h6&gt;

&lt;p&gt;根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSGlobalBlock：类似函数，位于text段；&lt;/li&gt;
&lt;li&gt;NSStackBlock：位于栈内存，函数返回后Block将无效；&lt;/li&gt;
&lt;li&gt;NSMallocBlock：位于堆内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看下面一段代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BlkSum blk1 = ^ long (int a, int b) &amp;#123;&amp;#10;  return a + b;&amp;#10;&amp;#125;;&amp;#10;NSLog(@&amp;#34;blk1 = %@&amp;#34;, blk1);// blk1 = &amp;#60;__NSGlobalBlock__: 0x47d0&amp;#62;&amp;#10;&amp;#10;&amp;#10;int base = 100;&amp;#10;BlkSum blk2 = ^ long (int a, int b) &amp;#123;&amp;#10;  return base + a + b;&amp;#10;&amp;#125;;&amp;#10;NSLog(@&amp;#34;blk2 = %@&amp;#34;, blk2); // blk2 = &amp;#60;__NSStackBlock__: 0xbfffddf8&amp;#62;&amp;#10;&amp;#10;BlkSum blk3 = [[blk2 copy] autorelease];&amp;#10;NSLog(@&amp;#34;blk3 = %@&amp;#34;, blk3); // blk3 = &amp;#60;__NSMallocBlock__: 0x902fda0&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么blk1类型是NSGlobalBlock，而blk2类型是NSStackBlock？blk1和blk2的区别在于，blk1没有使用Block以外的任何外部变量，Block不需要建立局部变量值的快照，这使blk1与函数没有任何区别，从blk1所在内存地址0x47d0猜测编译器把blk1放到了text代码段。blk2与blk1唯一不同是的使用了局部变量base，在定义（注意是定义，不是运行）blk2时，局部变量base当前值被copy到栈上，作为常量供Block使用。执行下面代码，结果是203，而不是204。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int base = 100;&amp;#10;base += 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;    return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base++;&amp;#10;printf(&amp;#34;%ld&amp;#34;,sum(1,2));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Block内变量base是只读的，如果想在Block内改变base的值，在定义base时要用 &lt;strong&gt;block修饰：&lt;/strong&gt;block int base = 100;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block int base = 100;&amp;#10;base += 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;    base += 10;&amp;#10;    return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base++;&amp;#10;printf(&amp;#34;%ld\n&amp;#34;,sum(1,2));&amp;#10;printf(&amp;#34;%d\n&amp;#34;,base);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上方的代码输出将是214,211。Block中使用__block修饰的变量时，将取变量此刻运行时的值，而不是定义时的快照。这个例子中，执行sum(1,2)时，base将取base++之后的值，也就是201，再执行Blockbase+=10; base+a+b，运行结果是214。执行完Block时，base已经变成211了。&lt;/p&gt;
&lt;h6&gt;Block的copy、retain、release操作&lt;/h6&gt;

&lt;p&gt;不同于NSObjec的copy、retain、release操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block_copy与copy等效，Block_release与release等效；&lt;/li&gt;
&lt;li&gt;对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1；&lt;/li&gt;
&lt;li&gt;NSGlobalBlock：retain、copy、release操作都无效；&lt;/li&gt;
&lt;li&gt;NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象。&lt;/li&gt;
&lt;li&gt;NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain；&lt;/li&gt;
&lt;li&gt;尽量不要对Block使用retain操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;Block对不同类型的变量的存取&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt; 基本类型 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int base = 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;  // base++; &amp;#32534;&amp;#35793;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#21482;&amp;#35835;&amp;#10;  return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base = 0;&amp;#10;printf(&amp;#34;%ld\n&amp;#34;,sum(1,2)); // &amp;#36825;&amp;#37324;&amp;#36755;&amp;#20986;&amp;#26159;103&amp;#65292;&amp;#32780;&amp;#19981;&amp;#26159;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static变量、全局变量。如果把上个例子的base改成全局的、或static。Block就可以对他进行读写了。因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。&lt;br&gt;如下所示的一段代码输出结果是0 3 1，表明Block外部对base的更新会影响Block中的base的取值，同样Block对base的更新也会影响Block外部的base值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static int base = 100;&amp;#10;BlkSum sum = ^ long (int a, int b) &amp;#123;&amp;#10;  base++;&amp;#10;  return base + a + b;&amp;#10;&amp;#125;;&amp;#10;base = 0;&amp;#10;printf(&amp;#34;%d\n&amp;#34;, base);&amp;#10;printf(&amp;#34;%ld\n&amp;#34;,sum(1,2)); // &amp;#36825;&amp;#37324;&amp;#36755;&amp;#20986;&amp;#26159;3&amp;#65292;&amp;#32780;&amp;#19981;&amp;#26159;103&amp;#10;printf(&amp;#34;%d\n&amp;#34;, base);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block变量，被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。Block被另一个Block使用时，另一个Block被copy到堆上时，被使用的Block也会被copy。但作为参数的Block是不会发生copy的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void foo() &amp;#123;&amp;#10;  int base = 100;&amp;#10;  BlkSum blk = ^ long (int a, int b) &amp;#123;&amp;#10;    return  base + a + b;&amp;#10;  &amp;#125;;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, blk); // &amp;#60;__NSStackBlock__: 0xbfffdb40&amp;#62;&amp;#10;  bar(blk);&amp;#10;&amp;#125;&amp;#10;&amp;#10;void bar(BlkSum sum_blk) &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;,sum_blk); // &amp;#19982;&amp;#19978;&amp;#38754;&amp;#19968;&amp;#26679;&amp;#65292;&amp;#35828;&amp;#26126;&amp;#20316;&amp;#20026;&amp;#21442;&amp;#25968;&amp;#20256;&amp;#36882;&amp;#26102;&amp;#65292;&amp;#24182;&amp;#19981;&amp;#20250;&amp;#21457;&amp;#29983;copy&amp;#10;&amp;#10;  void (^blk) (BlkSum) = ^ (BlkSum sum) &amp;#123;&amp;#10;    NSLog(@&amp;#34;%@&amp;#34;,sum);     // &amp;#26080;&amp;#35770;blk&amp;#22312;&amp;#22534;&amp;#19978;&amp;#36824;&amp;#26159;&amp;#26632;&amp;#19978;&amp;#65292;&amp;#20316;&amp;#20026;&amp;#21442;&amp;#25968;&amp;#30340;Block&amp;#19981;&amp;#20250;&amp;#21457;&amp;#29983;copy&amp;#12290;&amp;#10;    NSLog(@&amp;#34;%@&amp;#34;,sum_blk); // &amp;#24403;blk copy&amp;#21040;&amp;#22534;&amp;#19978;&amp;#26102;&amp;#65292;sum_blk&amp;#20063;&amp;#34987;copy&amp;#20102;&amp;#19968;&amp;#20998;&amp;#21040;&amp;#22534;&amp;#19978;&amp;#19978;&amp;#12290;&amp;#10;  &amp;#125;;&amp;#10;  blk(sum_blk); // blk&amp;#22312;&amp;#26632;&amp;#19978;&amp;#10;&amp;#10;  blk = [[blk copy] autorelease];&amp;#10;  blk(sum_blk); // blk&amp;#22312;&amp;#22534;&amp;#19978;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ObjC对象，不同于基本类型，Block会引起对象的引用计数变化。&lt;br&gt;先看下面代码&lt;br&gt;执行结果为1 1 1 2 1。&lt;br&gt;&lt;strong&gt;globalObj和&lt;/strong&gt;staticObj在内存中的位置是确定的，所以Block copy时不会retain对象。&lt;br&gt;_instanceObj在Block copy时也没有直接retain _instanceObj对象本身，但会retain self。所以在Block中可以直接读写_instanceObj变量。&lt;br&gt;localObj在Block copy时，系统自动retain对象，增加其引用计数。&lt;br&gt;blockObj在Block copy时也不会retain。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface MyClass : NSObject &amp;#123;&amp;#10;    NSObject* _instanceObj;&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;@implementation MyClass&amp;#10;&amp;#10;NSObject* __globalObj = nil;&amp;#10;&amp;#10;- (id) init &amp;#123;&amp;#10;    if (self = [super init]) &amp;#123;&amp;#10;        _instanceObj = [[NSObject alloc] init];&amp;#10;    &amp;#125;&amp;#10;    return self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void) test &amp;#123;&amp;#10;    static NSObject* __staticObj = nil;&amp;#10;    __globalObj = [[NSObject alloc] init];&amp;#10;    __staticObj = [[NSObject alloc] init];&amp;#10;&amp;#10;    NSObject* localObj = [[NSObject alloc] init];&amp;#10;    __block NSObject* blockObj = [[NSObject alloc] init];&amp;#10;&amp;#10;    typedef void (^MyBlock)(void) ;&amp;#10;    MyBlock aBlock = ^&amp;#123;&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, __globalObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, __staticObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, _instanceObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, localObj);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, blockObj);&amp;#10;    &amp;#125;;&amp;#10;    aBlock = [[aBlock copy] autorelease];&amp;#10;    aBlock();&amp;#10;&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [__globalObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [__staticObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [_instanceObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [localObj retainCount]);&amp;#10;    NSLog(@&amp;#34;%d&amp;#34;, [blockObj retainCount]);&amp;#10;&amp;#125;&amp;#10;@end&amp;#10;&amp;#10;int main(int argc, char *argv[]) &amp;#123;&amp;#10;    @autoreleasepool &amp;#123;&amp;#10;        MyClass* obj = [[[MyClass alloc] init] autorelease];&amp;#10;        [obj test];&amp;#10;        return 0;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非ObjC对象，如GCD队列dispatch_queue_t。Block copy时并不会自动增加他的引用计数，这点要非常小心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;Block中使用的ObjC对象的行为&lt;/h6&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) void(^myBlock)(void);&amp;#10;&amp;#10;MyClass* obj = [[[MyClass alloc] init] autorelease];&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  [obj doSomething];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次。&lt;/p&gt;
&lt;h6&gt;retain cycle&lt;/h6&gt;

&lt;p&gt;retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];&amp;#10;[request setCompletionBlock:^&amp;#123;&amp;#10;  NSString* string = [request responseString];&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |&amp;#10;---&amp;#62; |           | --------&amp;#62; |           |&amp;#10;     | retain 2  | &amp;#60;-------- | retain 1  |&amp;#10;     |           |           |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决这个问题的办法是使用弱引用打断retain cycle：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];&amp;#10;[request setCompletionBlock:^&amp;#123;&amp;#10;  NSString* string = [request responseString];&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |&amp;#10;----&amp;#62;|           | --------&amp;#62; |           |&amp;#10;     | retain 1  | &amp;#60; - - - - | retain 1  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;request被持有者释放后。request 的retainCount变成0,request被dealloc，request释放持有的Block，导致Block的retainCount变成0，也被销毁。这样这两个对象内存都被回收。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |&amp;#10;--X-&amp;#62;|           | ----X---&amp;#62; |           |&amp;#10;     | retain 0  | &amp;#60; - - - - | retain 0  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;与上面情况类似的陷阱：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.myBlock = ^ &amp;#123;&amp;#10;  [self doSomething];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里self和myBlock循环引用，解决办法同上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block MyClass* weakSelf = self;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  [weakSelf doSomething];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, retain) NSString* someVar;&amp;#10;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, _someVer);&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里在Block中虽然没直接使用self，但使用了成员变量。在Block中使用成员变量，retain的不是这个变量，而会retain self。解决办法也和上面一样。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, retain) NSString* someVar;&amp;#10;&amp;#10;__block MyClass* weakSelf = self;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, self.someVer);&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString* str = _someVer;&amp;#10;self.myBlock = ^ &amp;#123;&amp;#10;  NSLog(@&amp;#34;%@&amp;#34;, str);&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;retain cycle不只发生在两个对象之间，也可能发生在多个对象之间，这样问题更复杂，更难发现&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassA* objA = [[[ClassA alloc] init] autorelease];&amp;#10;objA.myBlock = ^&amp;#123;&amp;#10;    [self doSomething];&amp;#10;&amp;#125;;&amp;#10;self.objA = objA;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+-----------+           +-----------+           +-----------+&amp;#10;|   self    |           |   objA    |           |   Block   |&amp;#10;|           | --------&amp;#62; |           | --------&amp;#62; |           |&amp;#10;| retain 1  |           | retain 1  |           | retain 1  |&amp;#10;|           |           |           |           |           |&amp;#10;+-----------+           +-----------+           +-----------+&amp;#10;     ^                                                |&amp;#10;     |                                                |&amp;#10;     +------------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法同样是用__block打破循环引用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassA* objA = [[[ClassA alloc] init] autorelease];&amp;#10;&amp;#10;MyClass* weakSelf = self;&amp;#10;objA.myBlock = ^&amp;#123;&amp;#10;  [weakSelf doSomething];&amp;#10;&amp;#125;;&amp;#10;self.objA = objA;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：MRC中&lt;strong&gt;block是不会引起retain；但在ARC中&lt;/strong&gt;block则会引起retain。ARC中应该使用&lt;strong&gt;weak或&lt;/strong&gt;unsafe_unretained弱引用。__weak只能在iOS5以后使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;h6&gt;Block使用对象被提前释放&lt;/h6&gt;&lt;br&gt;看下面例子，有这种情况，如果不只是request持有了Block，另一个对象也持有了Block。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |   objA&amp;#10;----&amp;#62;|           | --------&amp;#62; |           |&amp;#60;--------&amp;#10;     | retain 1  | &amp;#60; - - - - | retain 2  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;这时如果request 被持有者释放。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     +-----------+           +-----------+&amp;#10;     | request   |           |   Block   |   objA&amp;#10;--X-&amp;#62;|           | --------&amp;#62; |           |&amp;#60;--------&amp;#10;     | retain 0  | &amp;#60; - - - - | retain 1  |&amp;#10;     |           |   weak    |           |&amp;#10;     +-----------+           +-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时request已被完全释放，但Block仍被objA持有，没有释放，如果这时触发了Block，在Block中将访问已经销毁的request，这将导致程序crash。为了避免这种情况，开发者必须要注意对象和Block的生命周期。&lt;/p&gt;
&lt;p&gt;另一个常见错误使用是，开发者担心retain cycle错误的使用__block。比如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block kkProducView* weakSelf = self;&amp;#10;dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;  weakSelf.xx = xx;&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将Block作为参数传给dispatch_async时，系统会将Block拷贝到堆上，如果Block中使用了实例变量，还将retain self，因为dispatch_async并不知道self会在什么时候被释放，为了确保系统调度执行Block中的任务时self没有被意外释放掉，dispatch_async必须自己retain一次self，任务完成后再release self。但这里使用__block，使dispatch_async没有增加self的引用计数，这使得在系统在调度执行Block之前，self可能已被销毁，但系统并不知道这个情况，导致Block被调度执行时self已经被释放导致crash。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// MyClass.m&amp;#10;- (void) test &amp;#123;&amp;#10;  __block MyClass* weakSelf = self;&amp;#10;  double delayInSeconds = 10.0;&amp;#10;  dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));&amp;#10;  dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&amp;#123;&amp;#10;    NSLog(@&amp;#34;%@&amp;#34;, weakSelf);&amp;#10;&amp;#125;);&amp;#10;&amp;#10;// other.m&amp;#10;MyClass* obj = [[[MyClass alloc] init] autorelease];&amp;#10;[obj test];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里用dispatch_after模拟了一个异步任务，10秒后执行Block。但执行Block的时候MyClass* obj已经被释放了，导致crash。解决办法是不要使用__block。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下&lt;strong&gt;block不会增加引用计数，但ARC会，ARC下必须用&lt;/strong&gt;weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6&gt;Block简介&lt;/h6&gt;

&lt;p&gt;Block作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于Objective-C在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。&lt;/p&gt;
&lt;p&gt;可以这样理解，Block其实包含两个部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block执行的代码，这是在编译的时候已经生成好的；&lt;/li&gt;
&lt;li&gt;一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Block与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Github上优秀的Objective-C项目简介</title>
    <link href="http://jvaeyhcd.cc/2016/02/20/Github%E4%B8%8A%E4%BC%98%E7%A7%80%E7%9A%84Objective-C%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/"/>
    <id>http://jvaeyhcd.cc/2016/02/20/Github上优秀的Objective-C项目简介/</id>
    <published>2016-02-20T09:15:47.000Z</published>
    <updated>2016-03-05T07:07:47.000Z</updated>
    
    <content type="html">&lt;p&gt;主要对当前Github排名靠前的项目做一个简单的简介，方便自己快速了解 Objective-C的一些优秀的开源框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;&lt;br&gt;作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gavinkwoe/BeeFramework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BeeFramework&lt;/a&gt;&lt;br&gt;BeeFramework是一个iOS应用开发框架，由国内开发者郭虹宇创立并且在Github上开源。经过一年多的发展，BeeFramework在Github上，得到了广泛关注，有1000多的star数和400多的fork数&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BradLarson/GPUImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GPUImage&lt;/a&gt;&lt;br&gt;一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SDWebImage&lt;/a&gt;&lt;br&gt;作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/RestKit/RestKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RestKit&lt;/a&gt;&lt;br&gt;主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa&lt;/a&gt;&lt;br&gt;由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来,GitHub自家的函数式响应式编程范式的Objective-C实现，名字听着很高大上，学习曲线确实也比较陡，但是绝对会改变你对iOS编程的认知&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebookarchive/three20&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;three20&lt;/a&gt;&lt;br&gt;由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus, 算是 three20 的一个替代品&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MBProgressHUD&lt;/a&gt;&lt;br&gt;作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/magicalpanda/MagicalRecord&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MagicalRecord&lt;/a&gt;&lt;br&gt;作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FMDB&lt;/a&gt;&lt;br&gt;一个对 SQLite 进行封装的库, 使用起来方便, 简单&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mantle/Mantle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mantle&lt;/a&gt;&lt;br&gt;作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了。GitHub自家的产物，轻量级建模的首选，也可以很好的配合CoreData工作&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Grouper/FlatUIKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FlatUIKit&lt;/a&gt;&lt;br&gt;收集了很多扁平化 UI 的 iOS 组件, 方便使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pokeb/asi-http-request&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ASIHTTPRequest&lt;/a&gt;&lt;br&gt;一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/path/FastImageCache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FastImageCache&lt;/a&gt;&lt;br&gt;Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Masonry&lt;/a&gt;&lt;br&gt;一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/Shimmer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Shimmer&lt;/a&gt;&lt;br&gt;Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/TransitApp/SVProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVProgressHUD&lt;/a&gt;&lt;br&gt;又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONKit&lt;/a&gt;&lt;br&gt;主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jverkoey/nimbus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nimbus&lt;/a&gt;&lt;br&gt;作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/facebook-ios-sdk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Facebook SDK for iOS&lt;/a&gt;&lt;br&gt;Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AsyncDisplayKit&lt;/a&gt;&lt;br&gt;Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/supermarin/Alcatraz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alcatraz&lt;/a&gt;&lt;br&gt;Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jessesquires/JSQMessagesViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSQMessagesViewController&lt;/a&gt;&lt;br&gt;优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/xctool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xctool&lt;/a&gt;&lt;br&gt;是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI, OCLint 等测试工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OpenEmu/OpenEmu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenEmu&lt;/a&gt;&lt;br&gt;超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nicklockwood/iCarousel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iCarousel&lt;/a&gt;&lt;br&gt;作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/romaonthego/RESideMenu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RESideMenu&lt;/a&gt;&lt;br&gt;作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PNChart&lt;/a&gt;&lt;br&gt;作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/PonyDebugger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PonyDebugger&lt;/a&gt;&lt;br&gt;由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jverdi/JVFloatLabeledTextField&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVFloatLabeledTextField&lt;/a&gt;&lt;br&gt;作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CEWendel/SWTableViewCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SWTableViewCell&lt;/a&gt;&lt;br&gt;UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/levey/AwesomeMenu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AwesomeMenu&lt;/a&gt;&lt;br&gt;作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tonymillion/Reachability&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reachability&lt;/a&gt;&lt;br&gt;Reachablity 是用于检测 iOS 设备网络环境的库,Beeframeowrk中使用过的库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; VVDocumenter-Xcode&lt;/a&gt;&lt;br&gt;作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/physical-web&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Physical Web&lt;/a&gt;&lt;br&gt;由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samuelclay/NewsBlur&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NewsBlur&lt;/a&gt;&lt;br&gt;作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cocos2d/cocos2d-objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cocos2D-SpriteBuilder&lt;/a&gt;&lt;br&gt;一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/TTTAttributedLabel/TTTAttributedLabel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TTTAttributedLabel&lt;/a&gt;&lt;br&gt;UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/robbiehanson/CocoaAsyncSocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaAsyncSocket&lt;/a&gt;&lt;br&gt;一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/devinross/tapkulibrary&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TapkuLibrary&lt;/a&gt;&lt;br&gt;作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CanvasPod/Canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Canvas&lt;/a&gt;&lt;br&gt;无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/SocketRocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SocketRocket&lt;/a&gt;&lt;br&gt;Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ECSlidingViewController/ECSlidingViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECSlidingViewController&lt;/a&gt;&lt;br&gt;一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stig/json-framework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Json Framework&lt;/a&gt;&lt;br&gt;用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/Tweaks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tweaks&lt;/a&gt;&lt;br&gt;Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/realm/realm-cocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;realm-cocoa&lt;/a&gt;&lt;br&gt;Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/icanzilb/JSONModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONModel&lt;/a&gt;&lt;br&gt;一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/KVOController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;KVOController&lt;/a&gt;&lt;br&gt;一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mwaterfall/MWPhotoBrowser&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MWPhotoBrowser&lt;/a&gt;&lt;br&gt;一款简单的 iOS 照片浏览控件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/samvermette/SVPullToRefresh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVPullToRefresh&lt;/a&gt;&lt;br&gt;&lt;b&gt;一款只需一行代码便可集成上拉刷新和下拉加载的组件&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/pop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;POP&lt;/a&gt;&lt;br&gt;facebook出品的paper，动画效果太好了，赶超apple的原生app一大截。pop就是paper的动画库！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dennisreimann/ioctocat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ioctocat&lt;/a&gt;&lt;br&gt;github的iOS客户端，目前开源代码是V1版本，V2版本在appstore上可以下载&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChatSecure/ChatSecure-iOS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ChatSecure&lt;/a&gt;&lt;br&gt;使用XMPP协议的IM开源软件，很强大，在appstore上可以下载&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FDFullscreenPopGesture&lt;/a&gt;&lt;br&gt;一个丝滑的全屏滑动返回手势,相关博客文章点击&lt;a href=&quot;http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Xcode插件&quot;&gt;&lt;a href=&quot;#Xcode插件&quot; class=&quot;headerlink&quot; title=&quot;Xcode插件&quot;&gt;&lt;/a&gt;Xcode插件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kattrali/cocoapods-xcode-plugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cocoapods-xcode-plugin&lt;/a&gt;&lt;br&gt;Dependency management helper for your CocoaPods, right in Xcode.&lt;br&gt;用于在Xcode中管理CocoaPods依赖库。&lt;br&gt;&lt;img src=&quot;http://wangzz.github.io/images/article1/plugin_cocoapods_menu.png&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/qfish/XAlign&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XAlign&lt;/a&gt;&lt;br&gt;An amazing Xcode plugin to align regular code. it can align Xnything in any way you want.&lt;br&gt;方便实现代码对其功能，使代码风格统一。&lt;br&gt;&lt;img src=&quot;http://wangzz.github.io/images/article1/plugin_align.gif&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/supermarin/Alcatraz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alcatraz&lt;/a&gt;&lt;br&gt;Alcatraz is an open-source package manager for Xcode 5+. It lets you discover and install plugins, templates and color schemes without the need for manually cloning or copying files. It installs itself as a part of Xcode and it feels like home.—Xcode插件管理工具。&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/919efe4e1e53237df51d7010c862bd5c04fd6a70/687474703a2f2f616c63617472617a2e696f2f696d616765732f73637265656e73686f744032782e706e67&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VVDocumenter-Xcode&lt;/a&gt;&lt;br&gt;提供了为代码增加注视的最快捷方式,非常好的Xcode插件。&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ca5518c9872e15b8a95b9d8c5f44bc331977d710/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f53637265656e53686f742e676966&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;br&gt;并且支持了Swift的注释，太棒了！&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/58e452b57245cd79c2e59ac7926609be4dffbfd8/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f7676646f63756d656e7465722d73776966742e676966&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ksuther/KSImageNamed-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;KSImageNamed-Xcode&lt;/a&gt;&lt;br&gt;当输入[NSImage imageNamed: 或者[UIImage imageNamed:时，会自动补全工程中可用的图片名称，同时能提供选中图片的预览。&lt;br&gt;&lt;img src=&quot;http://foggry.com/images/article1/plugin_image_named.gif&quot; alt=&quot;&amp;quot;&amp;quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自己做个笔记，方便以后工作遇到问题能够得到快速的解决&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;主要对当前Github排名靠前的项目做一个简单的简介，方便自己快速了解 Objective-C的一些优秀的开源框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;&lt;br&gt;作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gavinkwoe/BeeFramework&quot;&gt;BeeFramework&lt;/a&gt;&lt;br&gt;BeeFramework是一个iOS应用开发框架，由国内开发者郭虹宇创立并且在Github上开源。经过一年多的发展，BeeFramework在Github上，得到了广泛关注，有1000多的star数和400多的fork数&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BradLarson/GPUImage&quot;&gt;GPUImage&lt;/a&gt;&lt;br&gt;一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo安装新主题apollo</title>
    <link href="http://jvaeyhcd.cc/2016/02/20/Hexo%E5%AE%89%E8%A3%85%E6%96%B0%E4%B8%BB%E9%A2%98apollo/"/>
    <id>http://jvaeyhcd.cc/2016/02/20/Hexo安装新主题apollo/</id>
    <published>2016-02-20T08:15:35.000Z</published>
    <updated>2016-02-25T03:11:54.000Z</updated>
    
    <content type="html">&lt;p&gt;Hexo博客系统的流行原因，是因为他的个人性，而皮肤就是个人性的一种体现。Hexo换皮肤还是比较简单的,既可以自己根据默认的主题来修改，也可以到&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/themes/&lt;/a&gt;上去找主题。&lt;/p&gt;
&lt;p&gt;下面简单描述一下我安装apollo主题的过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;github上的文档给出了详细的安装命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo init #blogname#&amp;#10;cd #blogname# &amp;#10;npm install&amp;#10;npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive&amp;#10;git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;启用&quot;&gt;&lt;a href=&quot;#启用&quot; class=&quot;headerlink&quot; title=&quot;启用&quot;&gt;&lt;/a&gt;启用&lt;/h2&gt;&lt;p&gt;安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Extensions &amp;#25554;&amp;#20214;&amp;#21644;&amp;#30382;&amp;#32932;&amp;#10;## Plugins: https://hexo.io/plugins/&amp;#10;## Themes: https://hexo.io/themes/&amp;#10;# theme: landscape&amp;#10;theme: apollo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;启动hexo后修改成功后的皮肤如图所示&lt;br&gt;&lt;img src=&quot;/2016/02/20/Hexo安装新主题apollo/apollo.png&quot; alt=&quot;hexo-theme-apollo&quot; title=&quot;hexo-theme-apollo&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo博客系统的流行原因，是因为他的个人性，而皮肤就是个人性的一种体现。Hexo换皮肤还是比较简单的,既可以自己根据默认的主题来修改，也可以到&lt;a href=&quot;https://hexo.io/themes/&quot;&gt;https://hexo.io/themes/&lt;/a&gt;上去找主题。&lt;/p&gt;
&lt;p&gt;下面简单描述一下我安装apollo主题的过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo在github上构建免费的博客</title>
    <link href="http://jvaeyhcd.cc/2016/02/20/Hexo%E5%9C%A8github%E4%B8%8A%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://jvaeyhcd.cc/2016/02/20/Hexo在github上构建免费的博客/</id>
    <published>2016-02-20T04:07:20.000Z</published>
    <updated>2016-03-04T13:22:35.000Z</updated>
    
    <content type="html">&lt;p&gt;很多次想搭建一个自己的博客，彻底从csdn上转移到自己的博客站点中，但是一直由于时间的原因耽搁了。之前也使用过Wordpress来搭建自己的博客，但是发现Wordpress使用起来不是太方便。后来再接触了markdown语法写文章后，喜欢上了markdown。再后来了解到了hexo，一个基于Node的博客框架，同样可以实现基于github的博客，而且更轻更快，更适合Node的开发程序员。&lt;/p&gt;
&lt;h2 id=&quot;1-Hexo介绍&quot;&gt;&lt;a href=&quot;#1-Hexo介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Hexo介绍&quot;&gt;&lt;/a&gt;1.Hexo介绍&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown&lt;/a&gt;（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;2-Hexo安装&quot;&gt;&lt;a href=&quot;#2-Hexo安装&quot; class=&quot;headerlink&quot; title=&quot;2.Hexo安装&quot;&gt;&lt;/a&gt;2.Hexo安装&lt;/h2&gt;&lt;p&gt;安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mac用户在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&amp;gt; Download -&amp;gt; Command Line Tools -&amp;gt; Install 安装命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;安装-Git&quot;&gt;&lt;a href=&quot;#安装-Git&quot; class=&quot;headerlink&quot; title=&quot;安装 Git&quot;&gt;&lt;/a&gt;安装 Git&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Windows：下载并安装 &lt;a href=&quot;https://git-scm.com/download/win&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mac：使用 &lt;a href=&quot;http://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homebrew&lt;/a&gt;, &lt;a href=&quot;http://www.macports.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MacPorts&lt;/a&gt; 或下载 安装程序 安装。&lt;/li&gt;
&lt;li&gt;Linux (Ubuntu, Debian)：sudo apt-get install git-core&lt;/li&gt;
&lt;li&gt;Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;安装-Node-js&quot;&gt;&lt;a href=&quot;#安装-Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装 Node.js&quot;&gt;&lt;/a&gt;安装 Node.js&lt;/h4&gt;&lt;p&gt;安装 Node.js 的最佳方式是使用&lt;a href=&quot;https://github.com/creationix/nvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nvm&lt;/a&gt;&lt;br&gt;cURL:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Wget:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，重启终端并执行下列命令即可安装 Node.js。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nvm install 5.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者您也可以下载 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安装程序&lt;/a&gt; 来安装。&lt;/p&gt;
&lt;h4 id=&quot;安装-Hexo&quot;&gt;&lt;a href=&quot;#安装-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装 Hexo&quot;&gt;&lt;/a&gt;安装 Hexo&lt;/h4&gt;&lt;p&gt;所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo,Hexo安装，要用全局安装，加-g参数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&amp;#10;$ npm install -g hexo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;查看hexo的版本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo version&amp;#10;hexo-cli: 1.0.1&amp;#10;os: Darwin 15.3.0 darwin x64&amp;#10;http_parser: 2.5.0&amp;#10;node: 4.2.1&amp;#10;v8: 4.5.103.35&amp;#10;uv: 1.7.5&amp;#10;zlib: 1.2.8&amp;#10;ares: 1.10.1-DEV&amp;#10;icu: 56.1&amp;#10;modules: 46&amp;#10;openssl: 1.0.2d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-Hexo创建项目&quot;&gt;&lt;a href=&quot;#3-Hexo创建项目&quot; class=&quot;headerlink&quot; title=&quot;3.Hexo创建项目&quot;&gt;&lt;/a&gt;3.Hexo创建项目&lt;/h2&gt;&lt;p&gt;我的系统环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac OS X EI Capitan&lt;/li&gt;
&lt;li&gt;node v4.2.1&lt;/li&gt;
&lt;li&gt;npm 2.14.7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装好后，我们就可以使用Hexo创建项目了。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo init nodejs-hexo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们看到当前在目录下，出现了一个文件夹，包括初始化的文件。&lt;/p&gt;
&lt;p&gt;进入目录，并启动Hexo服务器。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# &amp;#36827;&amp;#20837;&amp;#30446;&amp;#24405;&amp;#10;$ cd nodejs-hexo&amp;#10;# &amp;#21551;&amp;#21160;hexo&amp;#26381;&amp;#21153;&amp;#22120;&amp;#10;$ hexo server&amp;#10;INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时端口4000被打开了，我们能过浏览器打开地址，&lt;a href=&quot;http://0.0.0.0:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0.0.0.0:4000/&lt;/a&gt;&lt;br&gt;ps:Mac上的地址是&lt;a href=&quot;http://0.0.0.0:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0.0.0.0:4000/&lt;/a&gt;， windows上的地址是&lt;a href=&quot;http://localhost:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-Hexo结构解析&quot;&gt;&lt;a href=&quot;#4-Hexo结构解析&quot; class=&quot;headerlink&quot; title=&quot;4.Hexo结构解析&quot;&gt;&lt;/a&gt;4.Hexo结构解析&lt;/h2&gt;&lt;p&gt;接下来，我们需要对Hexo做全面的了解，才能做出个性化的博客。&lt;/p&gt;
&lt;h4 id=&quot;4-1目录和文件&quot;&gt;&lt;a href=&quot;#4-1目录和文件&quot; class=&quot;headerlink&quot; title=&quot;4.1目录和文件&quot;&gt;&lt;/a&gt;4.1目录和文件&lt;/h4&gt;&lt;img src=&quot;/2016/02/20/Hexo在github上构建免费的博客/hexo-dict.png&quot; alt=&quot;Hexo目录结构示意图&quot; title=&quot;Hexo目录结构示意图&quot;&gt;
&lt;ul&gt;
&lt;li&gt;.deploy_git 发布到github上生成的静态文件夹&lt;/li&gt;
&lt;li&gt;node_modules mode的modules&lt;/li&gt;
&lt;li&gt;scaffolds 脚手架，也就是一个工具模板&lt;/li&gt;
&lt;li&gt;scripts 写文件的js，扩展hexo的功能&lt;/li&gt;
&lt;li&gt;source 存放博客正文内容&lt;/li&gt;
&lt;li&gt;source/_drafts 草稿箱&lt;/li&gt;
&lt;li&gt;source/_posts 文件箱&lt;/li&gt;
&lt;li&gt;themes 存放皮肤的目录&lt;/li&gt;
&lt;li&gt;themes/landscape 默认的皮肤&lt;/li&gt;
&lt;li&gt;_config.yml 全局的配置文件&lt;/li&gt;
&lt;li&gt;db.json 静态常量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;_posts目录：我们每次创建的文章都放在了_posts目录下面，Hexo是一个静态博客框架，没有数据库，文章内容都是以文本文件的方式进行存储的，直接存储在_posts的目录。&lt;/p&gt;
&lt;p&gt;themes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。&lt;/p&gt;
&lt;h4 id=&quot;4-2全局配置&quot;&gt;&lt;a href=&quot;#4-2全局配置&quot; class=&quot;headerlink&quot; title=&quot;4.2全局配置&quot;&gt;&lt;/a&gt;4.2全局配置&lt;/h4&gt;&lt;p&gt;_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;站点信息: 定义标题，作者，语言&lt;/li&gt;
&lt;li&gt;URL: URL访问路径&lt;/li&gt;
&lt;li&gt;文件目录: 正文的存储目录&lt;/li&gt;
&lt;li&gt;写博客配置：文章标题，文章类型，外部链接等&lt;/li&gt;
&lt;li&gt;目录和标签：默认分类，分类图，标签图&lt;/li&gt;
&lt;li&gt;归档设置：归档的类型&lt;/li&gt;
&lt;li&gt;服务器设置：IP，访问端口，日志输出&lt;/li&gt;
&lt;li&gt;时间和日期格式： 时间显示格式，日期显示格式&lt;/li&gt;
&lt;li&gt;分页设置：每页显示数量&lt;/li&gt;
&lt;li&gt;评论：外挂的Disqus评论系统&lt;/li&gt;
&lt;li&gt;插件和皮肤：换皮肤，安装插件&lt;/li&gt;
&lt;li&gt;Markdown语言：markdown的标准&lt;/li&gt;
&lt;li&gt;CSS的stylus格式：是否允许压缩&lt;/li&gt;
&lt;li&gt;部署配置：主要是github发布&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;附上我本地的_config.yml配置&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Hexo Configuration&amp;#10;## Docs: https://hexo.io/docs/configuration.html&amp;#10;## Source: https://github.com/hexojs/hexo/&amp;#10;&amp;#10;# Site &amp;#31449;&amp;#28857;&amp;#20449;&amp;#24687;&amp;#10;title: Salvador&amp;#10;subtitle:&amp;#10;description:&amp;#10;author: Salvador&amp;#10;language: en&amp;#10;timezone:&amp;#10;&amp;#10;# URL&amp;#10;## If your site is put in a subdirectory, set url as &amp;#39;http://yoursite.com/child&amp;#39; and root as &amp;#39;/child/&amp;#39;&amp;#10;url: http://yoursite.com&amp;#10;root: /&amp;#10;permalink: :year/:month/:day/:title/&amp;#10;permalink_defaults:&amp;#10;&amp;#10;# Directory &amp;#25991;&amp;#20214;&amp;#30446;&amp;#24405;&amp;#10;source_dir: source&amp;#10;public_dir: public&amp;#10;tag_dir: tags&amp;#10;archive_dir: archives&amp;#10;category_dir: categories&amp;#10;code_dir: downloads/code&amp;#10;i18n_dir: :lang&amp;#10;skip_render:&amp;#10;&amp;#10;# Writing &amp;#20889;&amp;#21338;&amp;#23458;&amp;#37197;&amp;#32622;&amp;#10;new_post_name: :title.md # File name of new posts&amp;#10;default_layout: post&amp;#10;titlecase: false # Transform title into titlecase&amp;#10;external_link: true # Open external links in new tab&amp;#10;filename_case: 0&amp;#10;render_drafts: false&amp;#10;post_asset_folder: true&amp;#10;relative_link: false&amp;#10;future: true&amp;#10;highlight:&amp;#10;  enable: true&amp;#10;  line_number: true&amp;#10;  auto_detect: false&amp;#10;  tab_replace:&amp;#10;&amp;#10;# Category &amp;#38; Tag &amp;#30446;&amp;#24405;&amp;#21644;&amp;#26631;&amp;#31614;&amp;#10;default_category: uncategorized&amp;#10;category_map:&amp;#10;tag_map:&amp;#10;&amp;#10;# Date / Time format &amp;#26102;&amp;#38388;&amp;#21644;&amp;#26085;&amp;#26399;&amp;#26684;&amp;#24335;&amp;#10;## Hexo uses Moment.js to parse and display date&amp;#10;## You can customize the date format as defined in&amp;#10;## http://momentjs.com/docs/#/displaying/format/&amp;#10;date_format: YYYY-MM-DD&amp;#10;time_format: HH:mm:ss&amp;#10;&amp;#10;# Pagination &amp;#20998;&amp;#39029;&amp;#35774;&amp;#32622;&amp;#10;## Set per_page to 0 to disable pagination&amp;#10;per_page: 10&amp;#10;pagination_dir: page&amp;#10;&amp;#10;# Extensions &amp;#25554;&amp;#20214;&amp;#21644;&amp;#30382;&amp;#32932;&amp;#10;## Plugins: https://hexo.io/plugins/&amp;#10;## Themes: https://hexo.io/themes/&amp;#10;# theme: landscape&amp;#10;theme: apollo&amp;#10;&amp;#10;# Deployment &amp;#37096;&amp;#32626;&amp;#37197;&amp;#32622;&amp;#10;## Docs: https://hexo.io/docs/deployment.html&amp;#10;deploy: &amp;#10;  type: git &amp;#10;  repo: https://github.com/Jvaeyhcd/jvaeyhcd.github.io.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-Hexo使用&quot;&gt;&lt;a href=&quot;#5-Hexo使用&quot; class=&quot;headerlink&quot; title=&quot;5.Hexo使用&quot;&gt;&lt;/a&gt;5.Hexo使用&lt;/h2&gt;&lt;h4 id=&quot;5-1创建新文章&quot;&gt;&lt;a href=&quot;#5-1创建新文章&quot; class=&quot;headerlink&quot; title=&quot;5.1创建新文章&quot;&gt;&lt;/a&gt;5.1创建新文章&lt;/h4&gt;&lt;p&gt;接下来，我们可以开始创建博客了。Hexo建议通过命令来创建文章，当然你也可以直接在_posts目录下创建文件。&lt;br&gt;通过命令创建新的文章&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new post Hexo&amp;#22312;github&amp;#19978;&amp;#26500;&amp;#24314;&amp;#20813;&amp;#36153;&amp;#30340;&amp;#10;INFO  Created: ~/hexo-blog/source/_posts/Hexo&amp;#22312;github&amp;#19978;&amp;#26500;&amp;#24314;&amp;#20813;&amp;#36153;&amp;#30340;.md&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建完成后在_posts目录下，就会生成文件“Hexo在github上构建免费的.md”&lt;/p&gt;
&lt;img src=&quot;/2016/02/20/Hexo在github上构建免费的博客/hexo-new.png&quot; alt=&quot;Hexo创建新的文章&quot; title=&quot;Hexo创建新的文章&quot;&gt;
&lt;p&gt;然后，我们编辑文件：”Hexo在github上构建免费的.md”，以markdown语法写文章，然后保存。&lt;/p&gt;
&lt;p&gt;在命令行，启动服务器。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;5-2文章的语法&quot;&gt;&lt;a href=&quot;#5-2文章的语法&quot; class=&quot;headerlink&quot; title=&quot;5.2文章的语法&quot;&gt;&lt;/a&gt;5.2文章的语法&lt;/h4&gt;&lt;p&gt;我们在写文章时，有一些语法的要求。&lt;br&gt;语法包括3部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本信息：标题，发布日期，分类目录，标签，类型，固定发布链接&lt;/li&gt;
&lt;li&gt;正文：markdown语法和Swig语法(掌握一个就行)&lt;/li&gt;
&lt;li&gt;特殊标记：引用，链接，图片，代码块，iframe，youtube视频&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;5-2-1基本信息&quot;&gt;&lt;a href=&quot;#5-2-1基本信息&quot; class=&quot;headerlink&quot; title=&quot;5.2.1基本信息&quot;&gt;&lt;/a&gt;5.2.1基本信息&lt;/h6&gt;&lt;p&gt;必须在文件的顶部，—的行之前的部分。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&amp;#10;title: Hexo&amp;#22312;github&amp;#19978;&amp;#26500;&amp;#24314;&amp;#20813;&amp;#36153;&amp;#30340;&amp;#21338;&amp;#23458;&amp;#10;date: 2016-02-20 12:07:20&amp;#10;tags:&amp;#10;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h6 id=&quot;5-2-2正文&quot;&gt;&lt;a href=&quot;#5-2-2正文&quot; class=&quot;headerlink&quot; title=&quot;5.2.2正文&quot;&gt;&lt;/a&gt;5.2.2正文&lt;/h6&gt;&lt;p&gt;hexo的正文要求使用markdown的语法，markdown的语法可以参考 &lt;a href=&quot;http://www.markdown.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;此处&lt;/a&gt;.&lt;/p&gt;
&lt;h6 id=&quot;5-2-3特殊标记&quot;&gt;&lt;a href=&quot;#5-2-3特殊标记&quot; class=&quot;headerlink&quot; title=&quot;5.2.3特殊标记&quot;&gt;&lt;/a&gt;5.2.3特殊标记&lt;/h6&gt;&lt;p&gt;hexo对于一些有特殊标记 文字块，做了特殊的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 引用 &lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Swig&amp;#35821;&amp;#27861;&amp;#10;&amp;#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&amp;#125;&amp;#10;Every interaction is both precious and an opportunity to delight.&amp;#10;&amp;#123;% endblockquote %&amp;#125;&amp;#10;&amp;#10;# Markdown&amp;#35821;&amp;#27861;&amp;#10;&amp;#62; Every interaction is both precious and an opportunity to delight.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 代码块 &lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Swig&amp;#35821;&amp;#27861;&amp;#10;&amp;#123;% codeblock .compact http://underscorejs.org/#compact Underscore.js %&amp;#125;&amp;#10;.compact([0, 1, false, 2, &amp;#8216;&amp;#8217;, 3]);&amp;#10;=&amp;#62; [1, 2, 3]&amp;#10;&amp;#123;% endcodeblock %&amp;#125;&amp;#10;&amp;#10;# Markdown&amp;#35821;&amp;#27861;&amp;#10;&amp;#39;```&amp;#123;bash&amp;#125;&amp;#10;.compact([0, 1, false, 2, &amp;#8216;&amp;#8217;, 3]);&amp;#10;=&amp;#62; [1, 2, 3]&amp;#10;```&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 链接 &lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Swig&amp;#35821;&amp;#27861;&amp;#10;&amp;#123;% link &amp;#31881;&amp;#19997;&amp;#26085;&amp;#24535; http://blog.fens.me true &amp;#31881;&amp;#19997;&amp;#26085;&amp;#24535; %&amp;#125;&amp;#10;&amp;#10;# Markdown&amp;#35821;&amp;#27861;&amp;#10;[&amp;#31881;&amp;#19997;&amp;#26085;&amp;#24535;](http://blog.fens.me)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 图片 &lt;/strong&gt;&lt;br&gt;对于本地图片，需要在_config.yml文件中配置”post_asset_folder: true”。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Writing &amp;#20889;&amp;#21338;&amp;#23458;&amp;#37197;&amp;#32622;&amp;#10;new_post_name: :title.md # File name of new posts&amp;#10;default_layout: post&amp;#10;titlecase: false # Transform title into titlecase&amp;#10;external_link: true # Open external links in new tab&amp;#10;filename_case: 0&amp;#10;render_drafts: false&amp;#10;post_asset_folder: true&amp;#10;relative_link: false&amp;#10;future: true&amp;#10;highlight:&amp;#10;  enable: true&amp;#10;  line_number: true&amp;#10;  auto_detect: false&amp;#10;  tab_replace:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样在”hexo new”创建文章的时候hexo会自动会在_posts文件夹下面生成一个与文章同名的文件夹存放图片资源,如下图所示&lt;br&gt;&lt;img src=&quot;/2016/02/20/Hexo在github上构建免费的博客/hexo-new.png&quot; alt=&quot;Hexo创建新的文章&quot; title=&quot;Hexo创建新的文章&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;% asset_path slug %&amp;#125;&amp;#10;&amp;#123;% asset_img slug [title] %&amp;#125;&amp;#10;&amp;#123;% asset_link slug [title] %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如说：当你打开文章资源文件夹功能后，你把一个 “example.jpg” 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 它将 不会 出现在页面上。正确的引用本地图片方式是使用下面的标签而不是 markdown ：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;% asset_img example.jpg This is an example image %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-发布到github&quot;&gt;&lt;a href=&quot;#6-发布到github&quot; class=&quot;headerlink&quot; title=&quot;6.发布到github&quot;&gt;&lt;/a&gt;6.发布到github&lt;/h2&gt;&lt;h4 id=&quot;6-1-静态化处理&quot;&gt;&lt;a href=&quot;#6-1-静态化处理&quot; class=&quot;headerlink&quot; title=&quot;6.1 静态化处理&quot;&gt;&lt;/a&gt;6.1 静态化处理&lt;/h4&gt;&lt;p&gt;写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 静态化命令 *&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行完命令后，在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。&lt;/p&gt;
&lt;h4 id=&quot;6-1-上传到github&quot;&gt;&lt;a href=&quot;#6-1-上传到github&quot; class=&quot;headerlink&quot; title=&quot;6.1 上传到github&quot;&gt;&lt;/a&gt;6.1 上传到github&lt;/h4&gt;&lt;p&gt;接下来，我们把这个博客发布到github。&lt;br&gt;首先在github上创建一个项目“你的用户名.github.io”,我创建的项目是&lt;a href=&quot;https://github.com/Jvaeyhcd/jvaeyhcd.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jvaeyhcd.github.io&lt;/a&gt;&lt;br&gt;编辑全局配置文件：_config.yml，找到deploy的部分，设置github的项目地址。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Deployment &amp;#37096;&amp;#32626;&amp;#37197;&amp;#32622;&amp;#10;## Docs: https://hexo.io/docs/deployment.html&amp;#10;deploy: &amp;#10;  type: git #&amp;#36825;&amp;#37324;&amp;#24517;&amp;#39035;&amp;#26159;git&amp;#65292;&amp;#20197;&amp;#21069;&amp;#26159;github&amp;#10;  repo: https://github.com/Jvaeyhcd/jvaeyhcd.github.io.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后，通过命令进行部署。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;部署完成后，打开你在github上创建的工程，你会看到&lt;br&gt;&lt;img src=&quot;/2016/02/20/Hexo在github上构建免费的博客/github.png&quot; alt=&quot;github&quot; title=&quot;github&quot;&gt;&lt;br&gt;然后访问&lt;a href=&quot;http://jvaeyhcd.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jvaeyhcd.github.io/&lt;/a&gt;就能看到你发布到github上的博客了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很多次想搭建一个自己的博客，彻底从csdn上转移到自己的博客站点中，但是一直由于时间的原因耽搁了。之前也使用过Wordpress来搭建自己的博客，但是发现Wordpress使用起来不是太方便。后来再接触了markdown语法写文章后，喜欢上了markdown。再后来了解到了hexo，一个基于Node的博客框架，同样可以实现基于github的博客，而且更轻更快，更适合Node的开发程序员。&lt;/p&gt;
&lt;h2 id=&quot;1-Hexo介绍&quot;&gt;&lt;a href=&quot;#1-Hexo介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Hexo介绍&quot;&gt;&lt;/a&gt;1.Hexo介绍&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPods安装和使用教程</title>
    <link href="http://jvaeyhcd.cc/2016/02/20/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://jvaeyhcd.cc/2016/02/20/CocoaPods安装和使用教程/</id>
    <published>2016-02-20T01:14:02.000Z</published>
    <updated>2016-02-25T03:11:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;一、CocosPods是什么&quot;&gt;&lt;a href=&quot;#一、CocosPods是什么&quot; class=&quot;headerlink&quot; title=&quot;一、CocosPods是什么&quot;&gt;&lt;/a&gt;一、CocosPods是什么&lt;/h2&gt;&lt;p&gt;CocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。&lt;br&gt;在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要&lt;br&gt;1.把开源库的源代码复制到项目中&lt;br&gt;2.添加一些依赖框架和动态库&lt;br&gt;3.设置-ObjC，-fno-objc-arc等参数&lt;br&gt;4.管理他们的更新&lt;br&gt;在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;二、CocoaPods的原理&quot;&gt;&lt;a href=&quot;#二、CocoaPods的原理&quot; class=&quot;headerlink&quot; title=&quot;二、CocoaPods的原理&quot;&gt;&lt;/a&gt;二、CocoaPods的原理&lt;/h2&gt;&lt;p&gt;CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。&lt;/p&gt;
&lt;h2 id=&quot;三、CocoaPods的安装&quot;&gt;&lt;a href=&quot;#三、CocoaPods的安装&quot; class=&quot;headerlink&quot; title=&quot;三、CocoaPods的安装&quot;&gt;&lt;/a&gt;三、CocoaPods的安装&lt;/h2&gt;&lt;p&gt;CocoaPods可以方便地通过Mac自带的RubyGems安装。&lt;br&gt;打开Terminal，然后键入以下命令：&lt;br&gt;$ sudo gem install cocoapods&lt;/p&gt;
&lt;p&gt;执行完这句如果报告以下错误：&lt;br&gt;ERROR: Could not find a valid gem ‘cocoapods’ (&amp;gt;= 0), here is why:&lt;br&gt;Unable to download data from &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://rubygems.org/&lt;/a&gt; - Errno::ETIMEDOUT: Operation timed out - connect(2) (&lt;a href=&quot;https://rubygems.org/latest_specs.4.8.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://rubygems.org/latest_specs.4.8.gz&lt;/a&gt;)&lt;br&gt;ERROR: Possible alternatives: cocoapods&lt;/p&gt;
&lt;p&gt;这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources -l (&amp;#26597;&amp;#30475;&amp;#24403;&amp;#21069;ruby&amp;#30340;&amp;#28304;)&amp;#10;$ gem sources --remove https://rubygems.org/&amp;#10;$ gem sources -a https://ruby.taobao.org/&amp;#10;$ gem sources -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果gem太老，可以尝试用如下命令升级gem&lt;br&gt;$ sudo gem update –system&lt;br&gt;升级成功后会提示: RubyGems system software updated&lt;/p&gt;
&lt;p&gt;然后重新执行安装下载命令&lt;br&gt;$ sudo gem install cocoapods&lt;br&gt;这时候应该没什么问题了&lt;/p&gt;
&lt;p&gt;接下来进行安装，执行：&lt;br&gt;$ pod setup&lt;/p&gt;
&lt;p&gt;Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.（文章末尾附使用镜像索引的方法）&lt;/p&gt;
&lt;h2 id=&quot;四、Cocoapods的使用&quot;&gt;&lt;a href=&quot;#四、Cocoapods的使用&quot; class=&quot;headerlink&quot; title=&quot;四、Cocoapods的使用&quot;&gt;&lt;/a&gt;四、Cocoapods的使用&lt;/h2&gt;&lt;p&gt;进入工程所在的目录（工程根目录）&lt;br&gt;执行命令 touch Podfile&lt;br&gt;这句是说新建一个名为Podfile的文件（不能写成别的名字，也可以自己在工程根目录里面直接新建）&lt;/p&gt;
&lt;p&gt;然后对改文件进行编辑，执行命令 open -e Podfile&lt;br&gt;第一次执行这个命令,会有一个空白文件打开，可以先放在一边，&lt;br&gt;Podfile文件的格式应该如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;platform :ios, &amp;#39;7.0&amp;#39;&amp;#10;pod &amp;#39;AMap2DMap&amp;#39;, &amp;#39;~&amp;#62; 2.5.0&amp;#39;&amp;#10;pod &amp;#39;AFNetworking&amp;#39;, &amp;#39;~&amp;#62; 2.5.3&amp;#39;&amp;#10;pod &amp;#39;SDWebImage&amp;#39;, &amp;#39;~&amp;#62; 3.7.2&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要注意的几点：platform那一行，ios三个字母都要小写，而且与前面的冒号之间不能有间隔，后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在6.0以上才能运行，遇到这样的开源库就需要写上版本号。&lt;/p&gt;
&lt;p&gt;platform下面就是Cocoapods需要集成的开源库，根据你的需要确定集成那些库。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;我要集成AFNetworking这个库类，需要在Cocoapods里面先搜索是否有需要的库，可以在Terminal中输入：&lt;br&gt;pod search AFNetworking&lt;br&gt;回车之后就可以看到和你搜索的关键字相关的一些库类。&lt;/p&gt;
&lt;p&gt;其中第一个就是我们需要的，把pod ‘AFNetworking’， ‘~&amp;gt;2.5.3’&lt;br&gt;那一行复制到我们的Podfile文件中，保存修改。&lt;br&gt;然后在Terminal中执行 ：&lt;br&gt;pod install&lt;/p&gt;
&lt;p&gt;这样，AFNetworking就已经下载完成并且设置好了编译参数和依赖，以后使用的时候切记如下两点：&lt;br&gt;1.从此以后需要使用Cocoapods生成的 .xcworkspace文件来打开工程，而不是使用以前的.xcodeproj文件&lt;br&gt;2.每次更改了Podfile文件，都需要重新执行一次pod update命令&lt;/p&gt;
&lt;p&gt;ps:当执行pod install之后，除了Podfile，还会生成一个名为Podfile.lock的文件，它会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock.在多人协作的时候，这样可以防止第三方库升级时候造成大家各自的第三方库版本不一致。所以在提交版本的时候不能把它落下，也不要添加到.gitignore中.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、CocosPods是什么&quot;&gt;&lt;a href=&quot;#一、CocosPods是什么&quot; class=&quot;headerlink&quot; title=&quot;一、CocosPods是什么&quot;&gt;&lt;/a&gt;一、CocosPods是什么&lt;/h2&gt;&lt;p&gt;CocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。&lt;br&gt;在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要&lt;br&gt;1.把开源库的源代码复制到项目中&lt;br&gt;2.添加一些依赖框架和动态库&lt;br&gt;3.设置-ObjC，-fno-objc-arc等参数&lt;br&gt;4.管理他们的更新&lt;br&gt;在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
