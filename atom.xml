<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jvaeyhcd&#39;s Note</title>
  <subtitle>My Coding Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jvaeyhcd.cc/"/>
  <updated>2016-06-01T10:30:16.000Z</updated>
  <id>http://www.jvaeyhcd.cc/</id>
  
  <author>
    <name>Jvaeyhcd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift学习笔记之闭包</title>
    <link href="http://www.jvaeyhcd.cc/2016/06/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://www.jvaeyhcd.cc/2016/06/01/Swift学习笔记之闭包/</id>
    <published>2016-06-01T01:20:16.000Z</published>
    <updated>2016-06-01T10:30:16.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一般来说，在学习一个新的东西前我们都需要先了解这个东西的定义。在Swift中的闭包是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和Objective-C中的代码块(blocks)以及其它一些语言中的匿名函数比较相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;全局和嵌套函数其实也是特殊的闭包，闭包采取如下三种形式之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局函数是一个有名字但不会捕获任何值的闭包&lt;/li&gt;
&lt;li&gt;嵌套函数是一个有名字并可以捕获其封闭函数内值的闭包&lt;/li&gt;
&lt;li&gt;闭包表达式是一个利用轻量级语法    所写的可以捕获其上下文中变量或常量值的匿名闭包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Swift表达式拥有简洁的风格，并鼓励在常见场景进行语法优化，主要有如下优化方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用上下文推断判断参数和返回值类型&lt;/li&gt;
&lt;li&gt;隐式返回单表达式闭包，即单表达式可以省略&lt;code&gt;return&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;参数名称缩写&lt;/li&gt;
&lt;li&gt;尾随（Trailing）闭包语法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;闭包表达式&quot;&gt;&lt;a href=&quot;#闭包表达式&quot; class=&quot;headerlink&quot; title=&quot;闭包表达式&quot;&gt;&lt;/a&gt;闭包表达式&lt;/h2&gt;&lt;p&gt;闭包表达式是一种利用简洁语法构建内联闭包的方式，闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过几次迭代展示了&lt;code&gt;sort&lt;/code&gt;方法定义和语法优化的方式。每一次都用更简洁的方式描述了相同的功能。&lt;/p&gt;
&lt;h3 id=&quot;sort方法&quot;&gt;&lt;a href=&quot;#sort方法&quot; class=&quot;headerlink&quot; title=&quot;sort方法&quot;&gt;&lt;/a&gt;sort方法&lt;/h3&gt;&lt;p&gt;Swift标准库提供了名为&lt;code&gt;sort&lt;/code&gt;的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，&lt;code&gt;sort&lt;/code&gt;方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组并不会被&lt;code&gt;sort&lt;/code&gt;方法修改。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; names = [&lt;span class=&quot;string&quot;&gt;&quot;Jay&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Vae&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Jvaeyhcd&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Tom&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Jack&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sortFun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s1:String, s2:String)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1 &amp;gt; s2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(sortFun)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该例子是对一个&lt;code&gt;String&lt;/code&gt;类型的数组进行排序，因此排序闭包函数类型需为&lt;code&gt;(String,String)-&amp;gt;Bool&lt;/code&gt;。提供排序闭包函数的方式是写一个符合其类型要求的普通函数，并将其作为&lt;code&gt;sort&lt;/code&gt;的参数传入。然而，这是一个相当冗长的方式，本质上只是写一个单表达式函数（&lt;code&gt;s1 &amp;gt; s2&lt;/code&gt;）。下面例子中，利用闭包表达式可以更好地构建一个内联排序闭包。&lt;/p&gt;
&lt;h3 id=&quot;闭包表达式语法&quot;&gt;&lt;a href=&quot;#闭包表达式语法&quot; class=&quot;headerlink&quot; title=&quot;闭包表达式语法&quot;&gt;&lt;/a&gt;闭包表达式语法&lt;/h3&gt;&lt;p&gt;闭包表达式语法一般如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; (parameters) -&amp;gt; returnType &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    statements&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;闭包表达式可以使用变量、常量以及&lt;code&gt;inout&lt;/code&gt;类型作为参数，但是不能提供默认值。也可以在参数列表的最后使用可变参数，元组也可以作为参数和返回值。&lt;/p&gt;
&lt;p&gt;下面例子展示了上面&lt;code&gt;sortFun(_:_:)&lt;/code&gt;函数对应的闭包表达式版本的代码：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (s1:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, s2:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)-&amp;gt;&lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1 &amp;lt; s2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是内联闭包参数和返回值类型申明与&lt;code&gt;sortFun(_:_:)&lt;/code&gt;类型申明相同。两种方式中，都写成了&lt;code&gt;(s1:String, s2:String)-&amp;gt;Bool&lt;/code&gt;。然而在内联表达式中，函数和返回值类型都写在大括号内，而不是大括号外。&lt;br&gt;闭包函数体部分由关键字&lt;code&gt;in&lt;/code&gt;引入。该关键字表示闭包的参数和返回值类型都已定义完成，闭包函数体即将开始。由于这个闭包函数体部分如此短，以至于可以将其写成一行代码：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(&amp;#123;(s1:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, s2:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1 &amp;lt; s2&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该例中&lt;code&gt;sort(_:)&lt;/code&gt;方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。&lt;/p&gt;
&lt;h3 id=&quot;根据上下文推断类型&quot;&gt;&lt;a href=&quot;#根据上下文推断类型&quot; class=&quot;headerlink&quot; title=&quot;根据上下文推断类型&quot;&gt;&lt;/a&gt;根据上下文推断类型&lt;/h3&gt;&lt;p&gt;因为排序闭包函数是作为&lt;code&gt;sort(_:)&lt;/code&gt;方法参数传入的，Swift可判断其参数和返回值的类型。&lt;code&gt;sort(_:)&lt;/code&gt;方法被一个字符串数组调用，此参数必须是&lt;code&gt;(String, String)-&amp;gt;Bool&lt;/code&gt;类型的函数。这意味着&lt;code&gt;(String, String)&lt;/code&gt;和&lt;code&gt;Bool&lt;/code&gt;类型并不是必须作为闭包表达式定义的一部分。因为所有类型都可以被正确判断，返回箭头(&lt;code&gt;-&amp;gt;&lt;/code&gt;)和围绕在周围的括号也可以被省略：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(&amp;#123;s1, s2 &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1 &amp;gt; s2&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，都可以推断出闭包的参数和返回值类型。 这意味着闭包作为函数或者方法的参数时，您几乎不需要利用完整格式构造内联闭包。&lt;/p&gt;
&lt;p&gt;尽管如此，您仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则可以采用完整格式的闭包。&lt;/p&gt;
&lt;h3 id=&quot;单表达式闭包隐式返回&quot;&gt;&lt;a href=&quot;#单表达式闭包隐式返回&quot; class=&quot;headerlink&quot; title=&quot;单表达式闭包隐式返回&quot;&gt;&lt;/a&gt;单表达式闭包隐式返回&lt;/h3&gt;&lt;p&gt;单行表达式闭包可以通过省略&lt;code&gt;return&lt;/code&gt;关键字来隐式返回单行表达式的结果，如上面版本代码可以改写为：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(&amp;#123;s1, s2 &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; s1 &amp;gt; s2&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;sort(_:)&lt;/code&gt;方法的参数类型明确了闭包必须返回一个&lt;code&gt;Bool&lt;/code&gt;类型值。因为闭包函数体只包含了一个单一表达式（&lt;code&gt;s1 &amp;gt; s2&lt;/code&gt;），该表达式返回&lt;code&gt;Bool&lt;/code&gt;类型值，因此这里没有歧义，&lt;code&gt;return&lt;/code&gt;关键字可以省略。&lt;/p&gt;
&lt;h3 id=&quot;参数名称缩写&quot;&gt;&lt;a href=&quot;#参数名称缩写&quot; class=&quot;headerlink&quot; title=&quot;参数名称缩写&quot;&gt;&lt;/a&gt;参数名称缩写&lt;/h3&gt;&lt;p&gt;Swift自动为内联包提供了参数名称缩写功能，你可以直接通过&lt;code&gt;$0&lt;/code&gt;,&lt;code&gt;$1&lt;/code&gt;,&lt;code&gt;$2&lt;/code&gt;来顺序调用闭包的参数，以此类推。如果您在闭包表达式中使用参数名缩写，你可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。&lt;code&gt;in&lt;/code&gt;关键字同样也可以被省略，因此闭包表达式完全由闭包函数体构成：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(&amp;#123;$&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;gt; $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;$0&lt;/code&gt;和&lt;code&gt;$1&lt;/code&gt;表示闭包中第一个和第二个&lt;code&gt;String&lt;/code&gt;类型的参数。&lt;/p&gt;
&lt;h3 id=&quot;运算符函数&quot;&gt;&lt;a href=&quot;#运算符函数&quot; class=&quot;headerlink&quot; title=&quot;运算符函数&quot;&gt;&lt;/a&gt;运算符函数&lt;/h3&gt;&lt;p&gt;实际上还有更简单的方式来实现上面例子中的闭包表达式。Swift中&lt;code&gt;String&lt;/code&gt;类型定义了关于大于符号(&lt;code&gt;&amp;gt;&lt;/code&gt;)的字符串实现，其作为一个函数接收两个&lt;code&gt;String&lt;/code&gt;类型的参数并返回&lt;code&gt;Bool&lt;/code&gt;类型的值。而这正好与&lt;code&gt;sort(_:)&lt;/code&gt;方法的参数需要的函数类型相符合。因此，您可以简单地传递一个大于号，Swift 可以自动推断出您想使用大于号的字符串函数实现：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNames = names.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;尾随闭包&quot;&gt;&lt;a href=&quot;#尾随闭包&quot; class=&quot;headerlink&quot; title=&quot;尾随闭包&quot;&gt;&lt;/a&gt;尾随闭包&lt;/h2&gt;&lt;p&gt;如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号后的闭包表达式，函数支持将其作为最后一个参数调用：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;someFunctionThatTakesAClosure&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(closure: &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 函数体部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下是不使用尾随闭包进行函数调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;someFunctionThatTakesAClosure(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 闭包主体部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下是使用尾随闭包进行函数调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;someFunctionThatTakesAClosure() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 闭包主体部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以上面&lt;code&gt;sort(_:)&lt;/code&gt;方法参数字符串排序闭包可以改写为&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNumbers = numbers.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;&amp;#123;$&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;gt; $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果函数只需要闭包表达式一个参数，当使用尾随闭包时可以把&lt;code&gt;()&lt;/code&gt;省略&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sortedNumbers = numbers.&lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;()&amp;#123;$&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;gt; $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当闭包非常长以至于不能在一行进行书写，尾随闭包变得非常有用。举个例子来说，Swifte的&lt;code&gt;Array&lt;/code&gt;类型有一个&lt;code&gt;map(_:)&lt;/code&gt;方法，其获取一个闭包表达式作为唯一参数。该闭包函数会为数组中的额每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。当提供给数组的闭包用于数组每个元素后，&lt;code&gt;map(_:)&lt;/code&gt;方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; digitNames = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Zero&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;One&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Two&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Three&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Four&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Five&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Six&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Seven&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Eight&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Nine&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers = [&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;65&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; strings = numbers.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (number) -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; number = number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; output = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; number &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        output = digitNames[number % &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]! + output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number /= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(strings)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面示例代码展示了如何在&lt;code&gt;map(_:)&lt;/code&gt;方法中使用尾随闭包将&lt;code&gt;Int&lt;/code&gt;类型的数组&lt;code&gt;[34, 65, 89]&lt;/code&gt;转换为包含对应&lt;code&gt;String&lt;/code&gt;类型值的数组&lt;code&gt;[&amp;quot;ThreeFour&amp;quot;, &amp;quot;SixFive&amp;quot;, &amp;quot;EightNine&amp;quot;]&lt;/code&gt;。&lt;br&gt;&lt;code&gt;map(_:)&lt;/code&gt;为数组中每一个元素调用了闭包表达式。您不需要指定闭包的输入参数&lt;code&gt;number&lt;/code&gt;的类型，因为可以通过要映射的数组类型进行推断。&lt;br&gt;在该例中，局部变量&lt;code&gt;number&lt;/code&gt;的值由闭包中的&lt;code&gt;numbe&lt;/code&gt;r参数获得,因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是固定的),闭包表达式指定了返回类型为&lt;code&gt;String&lt;/code&gt;，以表明存储映射值的新数组类型为&lt;code&gt;String&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;闭包表达式在每次被调用的时候创建了一个叫做&lt;code&gt;output&lt;/code&gt;的字符串并返回。其使用求余运算符（&lt;code&gt;number % 10&lt;/code&gt;）计算最后一位数字并利用&lt;code&gt;digitNames&lt;/code&gt;字典获取所映射的字符串。&lt;/p&gt;
&lt;h2 id=&quot;捕获值&quot;&gt;&lt;a href=&quot;#捕获值&quot; class=&quot;headerlink&quot; title=&quot;捕获值&quot;&gt;&lt;/a&gt;捕获值&lt;/h2&gt;&lt;p&gt;闭包可以在其被定义的上下文中捕获常量或者变量。即使定义这些常量或变量的作用域已经不在，闭包仍然可以在闭包函数体内引用和修改这些值。Swift中可捕获值的最简单的形势就是嵌套函数，也就是定义在其它函数内的函数。嵌套函数可以捕获其外部函数所有的参数以及常量和变量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一般来说，在学习一个新的东西前我们都需要先了解这个东西的定义。在Swift中的闭包是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和Objective-C中的代码块(blocks)以及其它一些语言中的匿名函数比较相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift学习笔记" scheme="http://www.jvaeyhcd.cc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
      <category term="闭包" scheme="http://www.jvaeyhcd.cc/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记之函数</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/31/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/31/Swift学习笔记之函数/</id>
    <published>2016-05-31T10:19:17.000Z</published>
    <updated>2016-06-01T01:33:01.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
      <category term="Swift学习笔记" scheme="http://www.jvaeyhcd.cc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记之高级运算符</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/30/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/30/Swift学习笔记之高级运算符/</id>
    <published>2016-05-30T02:46:46.000Z</published>
    <updated>2016-05-30T08:00:57.000Z</updated>
    
    <content type="html">&lt;p&gt;除了基本运算符外，Swift还提供了许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在C和Objective-C中已经被大家熟知的位运算符和位移运算符。&lt;/p&gt;
&lt;p&gt;与C语言和Objective-C的算数运算符不同，Swift中的算数运算符默认是不会溢出的。所有溢出行为都会被捕获并报告位错误。如果想让系统允许溢出行为，可以选择使用Swift中另一套默认支持溢出的运算符，比如溢出运算符（&lt;code&gt;&amp;amp;+&lt;/code&gt;）,所有的溢出运算符都是以&lt;code&gt;&amp;amp;&lt;/code&gt;开头的。&lt;/p&gt;
&lt;h2 id=&quot;位运算符&quot;&gt;&lt;a href=&quot;#位运算符&quot; class=&quot;headerlink&quot; title=&quot;位运算符&quot;&gt;&lt;/a&gt;位运算符&lt;/h2&gt;&lt;p&gt;位运算符可以操作数据结构中每个独立的比特位，它通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源和原始数据也十分有用，比如自定义通信协议传输的数据进行编码和解码。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;按位取反运算符&quot;&gt;&lt;a href=&quot;#按位取反运算符&quot; class=&quot;headerlink&quot; title=&quot;按位取反运算符&quot;&gt;&lt;/a&gt;按位取反运算符&lt;/h3&gt;&lt;p&gt;按位取反运算符（&lt;code&gt;~&lt;/code&gt;）可以对一个数值的全部比特位进行取反：&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitwiseNOT_2x.png&quot; alt=&quot;按位取反运算&quot; title=&quot;按位取反运算&quot;&gt;
&lt;p&gt;按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能加空格。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; initialBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0b00001111&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//十进制等于15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; invertedBits = ~initialBits       &lt;span class=&quot;comment&quot;&gt;//等于 0b11110000，十进制为240&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;按位与运算符&quot;&gt;&lt;a href=&quot;#按位与运算符&quot; class=&quot;headerlink&quot; title=&quot;按位与运算符&quot;&gt;&lt;/a&gt;按位与运算符&lt;/h3&gt;&lt;p&gt;按位与运算符（&lt;code&gt;&amp;amp;&lt;/code&gt;）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数对应位都为&lt;code&gt;1&lt;/code&gt;的时候，新数的对应位才为&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitwiseAND_2x.png&quot; alt=&quot;按位与运算&quot; title=&quot;按位与运算&quot;&gt;
&lt;p&gt;在下面的示例当中，&lt;code&gt;firstBits&lt;/code&gt; 和 &lt;code&gt;lastBits&lt;/code&gt; 中间 4 个位的值都为 1。按位与运算符对它们进行了运算，得到二进制数值 &lt;code&gt;00111100&lt;/code&gt;，等价于无符号十进制数的 60：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; firstBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0b11111100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; lastBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt;  = &lt;span class=&quot;number&quot;&gt;0b00111111&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; middleBits = firstBits &amp;amp; lastBits &lt;span class=&quot;comment&quot;&gt;// 等于 00111100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;按位或运算符&quot;&gt;&lt;a href=&quot;#按位或运算符&quot; class=&quot;headerlink&quot; title=&quot;按位或运算符&quot;&gt;&lt;/a&gt;按位或运算符&lt;/h3&gt;&lt;p&gt;按位或运算符(&lt;code&gt;|&lt;/code&gt;)可以对两个数的比特位进行比较，它返回一个新的数，如果两个对应的比特位中有任意一个为&lt;code&gt;1&lt;/code&gt;时，新数对应位就为&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitwiseOR_2x.png&quot; alt=&quot;按位或运算&quot; title=&quot;按位或运算&quot;&gt;
&lt;p&gt;在下面的示例中，&lt;code&gt;someBits&lt;/code&gt; 和 &lt;code&gt;moreBits&lt;/code&gt; 不同的位会被设置为 &lt;code&gt;1&lt;/code&gt;。接位或运算符对它们进行了运算，得到二进制数值 &lt;code&gt;11111110&lt;/code&gt;，等价于无符号十进制数的 &lt;code&gt;254&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; someBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0b10110010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; moreBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0b01011110&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; combinedbits = someBits | moreBits &lt;span class=&quot;comment&quot;&gt;// 等于 11111110&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;按位异或运算符&quot;&gt;&lt;a href=&quot;#按位异或运算符&quot; class=&quot;headerlink&quot; title=&quot;按位异或运算符&quot;&gt;&lt;/a&gt;按位异或运算符&lt;/h3&gt;&lt;p&gt;按位异或运算符(&lt;code&gt;^&lt;/code&gt;)可以对两个数的比特位进行比较，它返回一个新的数，当两个数对应比特位不相同时，新数的对应位就为&lt;code&gt;1&lt;/code&gt;：&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitwiseXOR_2x.png&quot; alt=&quot;按位异或运算&quot; title=&quot;按位异或运算&quot;&gt;
&lt;p&gt;在下面的示例当中，&lt;code&gt;firstBits&lt;/code&gt; 和 &lt;code&gt;otherBits&lt;/code&gt; 都有一个自己的位为 &lt;code&gt;1&lt;/code&gt; 而对方的对应位为 &lt;code&gt;0&lt;/code&gt; 的位。 按位异或运算符将新数的这两个位都设置为 &lt;code&gt;1&lt;/code&gt;，同时将其它位都设置为 &lt;code&gt;0&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; firstBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0b00010100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; otherBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0b00000101&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; outputBits = firstBits ^ otherBits &lt;span class=&quot;comment&quot;&gt;// 等于 00010001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;按位左移、右移运算符&quot;&gt;&lt;a href=&quot;#按位左移、右移运算符&quot; class=&quot;headerlink&quot; title=&quot;按位左移、右移运算符&quot;&gt;&lt;/a&gt;按位左移、右移运算符&lt;/h3&gt;&lt;p&gt;按位左移运算符（&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;）和按位右移运算符（&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;）可以对一个数的所有位进行指定位数的左移和右移。对一个数的左移和右移一位相当于对一个数乘以2或者除以2。&lt;/p&gt;
&lt;h4 id=&quot;无符号整数的位移运算&quot;&gt;&lt;a href=&quot;#无符号整数的位移运算&quot; class=&quot;headerlink&quot; title=&quot;无符号整数的位移运算&quot;&gt;&lt;/a&gt;无符号整数的位移运算&lt;/h4&gt;&lt;p&gt;对无符号的整数进行位移的规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已经存在的位按指定的位数进行左移和右移&lt;/li&gt;
&lt;li&gt;任何因移动超出整型存储范围的位都会被丢弃&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;0&lt;/code&gt;来填充位移后产生的空白&lt;br&gt;这种方法称为逻辑位移。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下这张图展示了 &lt;code&gt;11111111 &amp;lt;&amp;lt; 1&lt;/code&gt;（即把 &lt;code&gt;11111111&lt;/code&gt; 向左移动 &lt;code&gt;1&lt;/code&gt; 位），和 &lt;code&gt;11111111 &amp;gt;&amp;gt; 1&lt;/code&gt;（即把 &lt;code&gt;11111111&lt;/code&gt; 向右移动 &lt;code&gt;1&lt;/code&gt; 位）的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的：&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitshiftUnsigned_2x.png&quot; alt=&quot;按位左移、右移运算&quot; title=&quot;按位左移、右移运算&quot;&gt;
&lt;p&gt;下面的代码演示了 Swift 中的移位运算：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; shiftBits: &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 即二进制的 00000100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shiftBits &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// 00001000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shiftBits &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// 00010000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shiftBits &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// 10000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shiftBits &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// 00000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shiftBits &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// 00000001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还可以使用位移运算对其它数据类型进行编码和解码。&lt;/p&gt;
&lt;h4 id=&quot;有符号整数的位移运算&quot;&gt;&lt;a href=&quot;#有符号整数的位移运算&quot; class=&quot;headerlink&quot; title=&quot;有符号整数的位移运算&quot;&gt;&lt;/a&gt;有符号整数的位移运算&lt;/h4&gt;&lt;p&gt;对比无符号整数，有符号整数的位移运算相对就要复杂得多，这种复杂性源于有符号整数的二进制表现新式。&lt;br&gt;有符号整数使用第一个比特位（通常称为符号位）来表示这个数的正负。符号为&lt;code&gt;0&lt;/code&gt;代表正数，为&lt;code&gt;1&lt;/code&gt;代表负数。其余的比特位（通常称为数值位）存储了实际的值。&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitshiftSignedFour_2x.png&quot; alt=&quot; bitshiftSignedFour_2x&quot; title=&quot; bitshiftSignedFour_2x&quot;&gt;
&lt;p&gt;符号位为 &lt;code&gt;0&lt;/code&gt;，说明这是一个正数，另外 7 位则代表了十进制数值 4 的二进制表示。&lt;/p&gt;
&lt;p&gt;负数的存储方式略有不同。它存储的值的绝对值等于 &lt;code&gt;2&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 次方减去它的实际值（也就是数值位表示的值），这里的 &lt;code&gt;n&lt;/code&gt; 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 &lt;code&gt;2&lt;/code&gt; 的 &lt;code&gt;7&lt;/code&gt; 次方，即 &lt;code&gt;128&lt;/code&gt;。&lt;br&gt;这是值为 &lt;code&gt;-4&lt;/code&gt; 的 &lt;code&gt;Int8&lt;/code&gt; 型整数的二进制位表现形式：&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitshiftSignedMinusFour_2x.png&quot; alt=&quot;bitshiftSignedMinusFour_2x&quot; title=&quot;bitshiftSignedMinusFour_2x&quot;&gt;
&lt;p&gt;这次的符号位为 &lt;code&gt;1&lt;/code&gt;，说明这是一个负数，另外 7 个位则代表了数值 &lt;code&gt;124&lt;/code&gt;（即 &lt;code&gt;128 - 4&lt;/code&gt;）的二进制表示。负数的表示通常被称为二进制补码表示，用这种方法表示负数乍看起来有点奇怪，但它有一下几个优点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果想对&lt;code&gt;-1&lt;/code&gt;和&lt;code&gt;-4&lt;/code&gt;进行加法运算，我们只需要将这两个数的全部8个比特位相加，并且将计算结果中超出8位的值丢弃,其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitshiftSignedAddition_2x.png&quot; alt=&quot;有符号相加&quot; title=&quot;有符号相加&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当对整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/bitshiftSigned_2x.png&quot; alt=&quot;有符号位移&quot; title=&quot;有符号位移&quot;&gt;
&lt;p&gt;这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为&lt;b&gt;算术移位&lt;/b&gt;。&lt;br&gt;由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 &lt;code&gt;0&lt;/code&gt;。在移位的过程中保持符号位不变，意味着负整数在接近 &lt;code&gt;0&lt;/code&gt; 的过程中会一直保持为负。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;溢出运算符&quot;&gt;&lt;a href=&quot;#溢出运算符&quot; class=&quot;headerlink&quot; title=&quot;溢出运算符&quot;&gt;&lt;/a&gt;溢出运算符&lt;/h2&gt;&lt;p&gt;在默认情况下，当向一个整数赋予超过它容量的值时，Swift默认会报错，而不是产生一个无效的数。这个行为为我们在运算过大或者过小的数的时候提供了额外的安全性。&lt;br&gt;例如&lt;code&gt;Int16&lt;/code&gt;型整数能容纳的有符号整数范围是&lt;code&gt;-32768&lt;/code&gt;到&lt;code&gt;32767&lt;/code&gt;,当一个为Int16型变量的值超出了这个范围时，系统会报错：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; potentialOverflow = &lt;span class=&quot;type&quot;&gt;Int16&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;potentialOverflow += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;            &lt;span class=&quot;comment&quot;&gt;// 这里会报错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;溢出运算符可以让数值溢出的时候采取截断处理，而非报错。可以使用Swift提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以&lt;code&gt;&amp;amp;&lt;/code&gt;开头的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;溢出加法 &lt;code&gt;&amp;amp;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;溢出减法 &lt;code&gt;&amp;amp;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;溢出乘法 &lt;code&gt;&amp;amp;*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;无符号数值上溢&quot;&gt;&lt;a href=&quot;#无符号数值上溢&quot; class=&quot;headerlink&quot; title=&quot;无符号数值上溢&quot;&gt;&lt;/a&gt;无符号数值上溢&lt;/h3&gt;&lt;p&gt;数值有可能出现上溢或者下溢。&lt;br&gt;这个示例演示了但我们对一个无符号整数使用溢出加法(&lt;code&gt;&amp;amp;+&lt;/code&gt;)进行上溢运算时会发生什么：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; unsignedOverflow = &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsignedOverflow = unsignedOverflow &amp;amp;+ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时 unsignedOverflow 等于 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unsignedOverflow&lt;/code&gt; 被初始化为 &lt;code&gt;UInt8&lt;/code&gt; 所能容纳的最大整数（&lt;code&gt;255&lt;/code&gt;，以二进制表示即 &lt;code&gt;11111111&lt;/code&gt;）。然后使用了溢出加法运算符（&lt;code&gt;&amp;amp;+&lt;/code&gt;）对其进行加 1 运算。这使得它的二进制表示正好超出 UInt8 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 &lt;code&gt;UInt8&lt;/code&gt; 边界内的值是 &lt;code&gt;00000000&lt;/code&gt;，也就是十进制数值的 0。&lt;br&gt;&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/overflowAddition_2x.png&quot; alt=&quot;上溢&quot; title=&quot;上溢&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;无符号数值下溢&quot;&gt;&lt;a href=&quot;#无符号数值下溢&quot; class=&quot;headerlink&quot; title=&quot;无符号数值下溢&quot;&gt;&lt;/a&gt;无符号数值下溢&lt;/h3&gt;&lt;p&gt;同样的，当我们对一个无符号整数使用溢出减法(&lt;code&gt;&amp;amp;-&lt;/code&gt;)进行下溢运算时也会产生类似的现象：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; unsignedOverflow = &lt;span class=&quot;type&quot;&gt;UInt8&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsignedOverflow = unsignedOverflow &amp;amp;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时 unsignedOverflow 等于 255&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UInt8&lt;/code&gt; 型整数能容纳的最小值是 &lt;code&gt;0&lt;/code&gt;，以二进制表示即 &lt;code&gt;00000000&lt;/code&gt;。当使用溢出减法运算符对其进行减 1 运算时，数值会产生下溢并被截断为 &lt;code&gt;11111111&lt;/code&gt;， 也就是十进制数值的 &lt;code&gt;255&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/overflowUnsignedSubtraction_2x.png&quot; alt=&quot;下溢&quot; title=&quot;下溢&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;有符号数值溢出&quot;&gt;&lt;a href=&quot;#有符号数值溢出&quot; class=&quot;headerlink&quot; title=&quot;有符号数值溢出&quot;&gt;&lt;/a&gt;有符号数值溢出&lt;/h3&gt;&lt;p&gt;溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算。比如下面的例子：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; signedOverflow = &lt;span class=&quot;type&quot;&gt;Int8&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// signedOverflow 等于 Int8 所能容纳的最小整数 -128&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;signedOverflow = signedOverflow &amp;amp;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时 signedOverflow 等于 127&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Int8&lt;/code&gt;型整数能容纳的最小值是&lt;code&gt;－128&lt;/code&gt;，以二进制表示即&lt;code&gt;10000000&lt;/code&gt;。当使用溢出减法运算符对其进行减&lt;code&gt;1&lt;/code&gt;运算时，符号位被翻转，得到二进制数值&lt;code&gt;01111111&lt;/code&gt;，也就是十进制的&lt;code&gt;127&lt;/code&gt;，这个值也是&lt;code&gt;Int8&lt;/code&gt;型整数所能容纳的最大值。&lt;/p&gt;
&lt;img src=&quot;/2016/05/30/Swift学习笔记之高级运算符/overflowSignedSubtraction_2x.png&quot; alt=&quot;有符数值溢出&quot; title=&quot;有符数值溢出&quot;&gt;
&lt;p&gt;对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。&lt;/p&gt;
&lt;h2 id=&quot;运算符函数&quot;&gt;&lt;a href=&quot;#运算符函数&quot; class=&quot;headerlink&quot; title=&quot;运算符函数&quot;&gt;&lt;/a&gt;运算符函数&lt;/h2&gt;&lt;p&gt;类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。&lt;/p&gt;
&lt;p&gt;下面一个例子展示了如何为自定义的结构体实现加法运算符(&lt;code&gt;+&lt;/code&gt;)。算数运算符是一个双目运算符，因为它可以对两个值进行运算，同时它还是中缀运算符，因为它出现在两个值中间。&lt;/p&gt;
&lt;p&gt;例子中定义了一个名为 &lt;code&gt;Vector2D&lt;/code&gt; 的结构体用来表示二维坐标向量 &lt;code&gt;(x, y)&lt;/code&gt;，紧接着定义了一个可以对两个 &lt;code&gt;Vector2D&lt;/code&gt; 结构体进行相加的运算符函数：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vector2D&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, y = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; + &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;: Vector2D, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;: Vector2D)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;.x + &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;.x, y: &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;.y + &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;.y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 &lt;code&gt;+&lt;/code&gt; 名字一致。因为算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 &lt;code&gt;Vector2D&lt;/code&gt; 的参数，同时有一个 &lt;code&gt;Vector2D&lt;/code&gt; 类型的返回值。&lt;/p&gt;
&lt;p&gt;在这个实现中，输入参数分别被命名为 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt;，代表在 + 运算符左边和右边的两个 &lt;code&gt;Vector2D&lt;/code&gt; 实例。函数返回了一个新的 &lt;code&gt;Vector2D&lt;/code&gt; 实例，这个实例的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 分别等于作为参数的两个实例的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值之和。&lt;/p&gt;
&lt;p&gt;这个函数被定义成全局的，而不是 &lt;code&gt;Vector2D&lt;/code&gt; 结构体的成员方法，所以任意两个 &lt;code&gt;Vector2D&lt;/code&gt; 实例都可以使用这个中缀运算符：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vector = &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;, y: &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; anotherVector = &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, y: &lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; combinedVector = vector + anotherVector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;前缀和后缀运算符&quot;&gt;&lt;a href=&quot;#前缀和后缀运算符&quot; class=&quot;headerlink&quot; title=&quot;前缀和后缀运算符&quot;&gt;&lt;/a&gt;前缀和后缀运算符&lt;/h3&gt;&lt;p&gt;上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 &lt;code&gt;-a&lt;/code&gt;），而当它出现在值之后时，它就是后缀的（例如 &lt;code&gt;b!&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;要实现前缀或者后缀运算符，需要在声明运算符函数的时候在&lt;code&gt;func&lt;/code&gt;关键字之前指定&lt;code&gt;prefix&lt;/code&gt;或者&lt;code&gt;postfix&lt;/code&gt;修饰符。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; - &lt;span class=&quot;params&quot;&gt;(vector: Vector2D)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: -vector.x, y: -vector.y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码为 &lt;code&gt;Vector2D&lt;/code&gt; 类型实现了单目负号运算符。由于该运算符是前缀运算符，所以这个函数需要加上 &lt;code&gt;prefix&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;p&gt;对于简单数值，单目负号运算符可以对它们的正负性进行改变。对于 &lt;code&gt;Vector2D&lt;/code&gt; 来说，该运算将其 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 属性的正负性都进行了改变：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; positive = &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;, y: &lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; negative = -positive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; alsoPositive = -negative&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;复合赋值运算符&quot;&gt;&lt;a href=&quot;#复合赋值运算符&quot; class=&quot;headerlink&quot; title=&quot;复合赋值运算符&quot;&gt;&lt;/a&gt;复合赋值运算符&lt;/h3&gt;&lt;p&gt;复合赋值运算符将赋值运算符（&lt;code&gt;=&lt;/code&gt;）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（&lt;code&gt;+=&lt;/code&gt;）。在实现的时候，需要把运算符的左参数设置成 &lt;code&gt;inout&lt;/code&gt; 类型，因为这个参数的值会在运算符函数内直接被修改。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; += &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;: Vector2D, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;: Vector2D)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; original = &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, y: &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vectorToAdd = &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt;(x: &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;, y: &lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;original += vectorToAdd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// original 的值现在为 (4.0, 6.0)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：不能对默认的赋值运算符（&lt;code&gt;=&lt;/code&gt;）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （&lt;code&gt;a ? b : c&lt;/code&gt;） 进行重载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;等价运算符&quot;&gt;&lt;a href=&quot;#等价运算符&quot; class=&quot;headerlink&quot; title=&quot;等价运算符&quot;&gt;&lt;/a&gt;等价运算符&lt;/h3&gt;&lt;p&gt;自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（&lt;code&gt;==&lt;/code&gt;）与“不等”运算符（&lt;code&gt;!=&lt;/code&gt;）。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。&lt;/p&gt;
&lt;p&gt;为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; == &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;: Vector2D, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;: Vector2D)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;.x == &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;.x) &amp;amp;&amp;amp; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;.y == &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;.y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; != &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;: Vector2D, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;: Vector2D)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !(&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; == &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义运算符&quot;&gt;&lt;a href=&quot;#自定义运算符&quot; class=&quot;headerlink&quot; title=&quot;自定义运算符&quot;&gt;&lt;/a&gt;自定义运算符&lt;/h2&gt;&lt;p&gt;除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。&lt;br&gt;新的运算符要使用 &lt;code&gt;operator&lt;/code&gt; 关键字在全局作用域内进行定义，同时还要指定 &lt;code&gt;prefix&lt;/code&gt;、&lt;code&gt;infix&lt;/code&gt; 或者 &lt;code&gt;postfix&lt;/code&gt; 修饰符：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; +++ &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码定义了一个新的名为 &lt;code&gt;+++&lt;/code&gt; 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因此我们针对 &lt;code&gt;Vector2D&lt;/code&gt; 的实例来定义它的意义。对这个示例来讲，&lt;code&gt;+++&lt;/code&gt; 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵对自身进行相加，从而让 &lt;code&gt;Vector2D&lt;/code&gt; 实例的 &lt;code&gt;x&lt;/code&gt; 属性和 &lt;code&gt;y&lt;/code&gt; 属性的值翻倍：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; +++ &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; vector: Vector2D)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Vector2D&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector += vector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; vector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;除了基本运算符外，Swift还提供了许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在C和Objective-C中已经被大家熟知的位运算符和位移运算符。&lt;/p&gt;
&lt;p&gt;与C语言和Objective-C的算数运算符不同，Swift中的算数运算符默认是不会溢出的。所有溢出行为都会被捕获并报告位错误。如果想让系统允许溢出行为，可以选择使用Swift中另一套默认支持溢出的运算符，比如溢出运算符（&lt;code&gt;&amp;amp;+&lt;/code&gt;）,所有的溢出运算符都是以&lt;code&gt;&amp;amp;&lt;/code&gt;开头的。&lt;/p&gt;
&lt;h2 id=&quot;位运算符&quot;&gt;&lt;a href=&quot;#位运算符&quot; class=&quot;headerlink&quot; title=&quot;位运算符&quot;&gt;&lt;/a&gt;位运算符&lt;/h2&gt;&lt;p&gt;位运算符可以操作数据结构中每个独立的比特位，它通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源和原始数据也十分有用，比如自定义通信协议传输的数据进行编码和解码。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift学习笔记" scheme="http://www.jvaeyhcd.cc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记之基本运算符</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/27/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/27/Swift学习笔记之基本运算符/</id>
    <published>2016-05-27T02:49:18.000Z</published>
    <updated>2016-05-30T02:42:41.000Z</updated>
    
    <content type="html">&lt;p&gt;运算符是检查、改变、合并值的特殊符号或短语。Swift支持了大部分标准C语言的运算符，并且改进了很多特性来减少常规编码错误。例如(&lt;code&gt;=&lt;/code&gt;)不放回值，以防止把想要判断相等运算符（&lt;code&gt;==&lt;/code&gt;）的地方写成赋值符导致的错误。&lt;/p&gt;
&lt;h3 id=&quot;赋值运算符&quot;&gt;&lt;a href=&quot;#赋值运算符&quot; class=&quot;headerlink&quot; title=&quot;赋值运算符&quot;&gt;&lt;/a&gt;赋值运算符&lt;/h3&gt;&lt;p&gt;赋值运算（&lt;code&gt;a = b&lt;/code&gt;），表示用&lt;code&gt;b&lt;/code&gt;的值来初始化或更新&lt;code&gt;a&lt;/code&gt;的值&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//a 现在等于1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;如果赋值运算符右边是一个多元组，它的元素马上被分解成多个常量或变量：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; (x, y) = (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 现在x等于1，y等于2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与C语言和Objective－C不同，Swift的赋值操作并不返回任何值。所以一下代码是错误的&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if a = b &amp;#123;&amp;#10;&amp;#9;//&amp;#36825;&amp;#21477;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#65292;&amp;#22240;&amp;#20026;&amp;#36171;&amp;#20540;&amp;#36816;&amp;#31639;&amp;#31526;&amp;#27809;&amp;#26377;&amp;#36820;&amp;#22238;&amp;#20540;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个特性使得你无法把（&lt;code&gt;==&lt;/code&gt;）错写成（&lt;code&gt;=&lt;/code&gt;）,由于&lt;code&gt;if a = b&lt;/code&gt;是错误代码，Swift能帮你避免此类错误的发生。&lt;/p&gt;
&lt;h3 id=&quot;算术运算符&quot;&gt;&lt;a href=&quot;#算术运算符&quot; class=&quot;headerlink&quot; title=&quot;算术运算符&quot;&gt;&lt;/a&gt;算术运算符&lt;/h3&gt;&lt;p&gt;Swift 中所有数值类型都支持了基本的四则算术运算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加法(&lt;code&gt;+&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;减法(&lt;code&gt;-&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;乘法(&lt;code&gt;*&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;除法(&lt;code&gt;/&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与C语言和Objective-C不同的是，Swift默认情况下不允许在数值运算中出现溢出的情况。&lt;/li&gt;
&lt;li&gt;加法运算符可以直接用于&lt;code&gt;String&lt;/code&gt;字符串的拼接：&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&quot;baby&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//等于&quot;Hello, baby&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;求余运算符&quot;&gt;&lt;a href=&quot;#求余运算符&quot; class=&quot;headerlink&quot; title=&quot;求余运算符&quot;&gt;&lt;/a&gt;求余运算符&lt;/h3&gt;&lt;p&gt;求余运算符（&lt;code&gt;a % b&lt;/code&gt;）是计算&lt;code&gt;b&lt;/code&gt;的多少倍刚刚好可以容入&lt;code&gt;a&lt;/code&gt;，返回多出来的那部分，就是余数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求余运算(&lt;code&gt;%&lt;/code&gt;)在其它语言也叫做取模运算。然而严格来说，我们看该运算符对负数操作的结果，「求余」比「取模」更合适些。&lt;/li&gt;
&lt;li&gt;在对负数&lt;code&gt;b&lt;/code&gt;求余时，&lt;code&gt;b&lt;/code&gt;的符号会被忽略。这意味着&lt;code&gt;a % b&lt;/code&gt;和&lt;code&gt;a % -b&lt;/code&gt;的结果是一样的。&lt;/li&gt;
&lt;li&gt;不同于 C 语言和 Objective-C，Swift 中是可以对浮点数进行求余的。&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;//等于0.5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.5&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;//等于1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一元负号运算符&quot;&gt;&lt;a href=&quot;#一元负号运算符&quot; class=&quot;headerlink&quot; title=&quot;一元负号运算符&quot;&gt;&lt;/a&gt;一元负号运算符&lt;/h3&gt;&lt;p&gt;数值的正负号可以使用前缀 &lt;code&gt;-&lt;/code&gt;（即一元负号）来切换：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; one = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; minusOne = -one        &lt;span class=&quot;comment&quot;&gt;//minusOne等于-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; plusOne = -minusOne    &lt;span class=&quot;comment&quot;&gt;//plusOne等于1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一元负号（&lt;code&gt;-&lt;/code&gt;）写在操作数之前，中间没有空格。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一元正号运算符&quot;&gt;&lt;a href=&quot;#一元正号运算符&quot; class=&quot;headerlink&quot; title=&quot;一元正号运算符&quot;&gt;&lt;/a&gt;一元正号运算符&lt;/h3&gt;&lt;p&gt;一元正号（&lt;code&gt;+&lt;/code&gt;）不做任何改变地返回操作数的值：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; minusSix = -&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; alsoMinusSix = +minusSix  &lt;span class=&quot;comment&quot;&gt;// alsoMinusSix 等于 -6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;组合赋值运算符&quot;&gt;&lt;a href=&quot;#组合赋值运算符&quot; class=&quot;headerlink&quot; title=&quot;组合赋值运算符&quot;&gt;&lt;/a&gt;组合赋值运算符&lt;/h3&gt;&lt;p&gt;如同 C 语言，Swift 也提供把其他运算符和赋值运算（&lt;code&gt;=&lt;/code&gt;）组合的组合赋值运算符，组合加运算（&lt;code&gt;+=&lt;/code&gt;）是其中一个例子：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// a 现在是 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合赋值运算符没有返回值，&lt;code&gt;let b = a += 2&lt;/code&gt;这类代码是错误的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;比较运算符&quot;&gt;&lt;a href=&quot;#比较运算符&quot; class=&quot;headerlink&quot; title=&quot;比较运算符&quot;&gt;&lt;/a&gt;比较运算符&lt;/h3&gt;&lt;p&gt;所有标准 C 语言中的比较运算都可以在 Swift 中使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等于（&lt;code&gt;==&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;不等于(&lt;code&gt;!=&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;大于(&lt;code&gt;&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;小于(&lt;code&gt;&amp;lt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;大于等于(&lt;code&gt;&amp;gt;=&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;小于等于(&lt;code&gt;&amp;lt;=&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当元组中的值可以比较时，你也可以使用这些运算符来比较它们的大小。例如，因为 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 类型的值可以比较，所以类型为 &lt;code&gt;(Int, String)&lt;/code&gt; 的元组也可以被比较。相反，&lt;code&gt;Bool&lt;/code&gt; 不能被比较，也意味着存有布尔类型的元组不能被比较。&lt;/p&gt;
&lt;p&gt;比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的。例如：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;zebra&quot;&lt;/span&gt;) &amp;lt; (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;apple&quot;&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;// true，因为 1 小于 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;apple&quot;&lt;/span&gt;) &amp;lt; (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bird&quot;&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;// true，因为 3 等于 3，但是 apple 小于 bird&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dog&quot;&lt;/span&gt;) == (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dog&quot;&lt;/span&gt;)      &lt;span class=&quot;comment&quot;&gt;// true，因为 4 等于 4，dog 等于 dog&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三目运算符&quot;&gt;&lt;a href=&quot;#三目运算符&quot; class=&quot;headerlink&quot; title=&quot;三目运算符&quot;&gt;&lt;/a&gt;三目运算符&lt;/h3&gt;&lt;p&gt;三目运算符的特殊在于它是有三个操作数的运算符，它的形式是&lt;code&gt;question ? answer1 : answer2&lt;/code&gt;。它简洁的表达了根据问题成立与否作出二选一的操作。如果&lt;code&gt;question&lt;/code&gt;成立返回&lt;code&gt;answer1&lt;/code&gt;的结果；否则返回&lt;code&gt;answer2&lt;/code&gt;的结果。&lt;/p&gt;
&lt;p&gt;三目运算符是以下代码的缩写形式：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; question &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    answer1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    answer2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三目运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三目运算符会使简洁的代码变的难懂。我们应避免在一个组合语句中使用多个三目运算符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;空合运算符&quot;&gt;&lt;a href=&quot;#空合运算符&quot; class=&quot;headerlink&quot; title=&quot;空合运算符&quot;&gt;&lt;/a&gt;空合运算符&lt;/h3&gt;&lt;p&gt;空合运算符（&lt;code&gt;a ?? b&lt;/code&gt;）将对可选类型 &lt;code&gt;a&lt;/code&gt; 进行空判断，如果 &lt;code&gt;a&lt;/code&gt; 包含一个值就进行解封，否则就返回一个默认值 &lt;code&gt;b&lt;/code&gt;。表达式 &lt;code&gt;a&lt;/code&gt; 必须是 Optional 类型。默认值 &lt;code&gt;b&lt;/code&gt; 的类型必须要和 &lt;code&gt;a&lt;/code&gt; 存储值的类型保持一致。&lt;/p&gt;
&lt;p&gt;空合运算符是对以下代码的简短表达方法：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; ? a! : b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 a 为非空值（non-nil），那么值 b 将不会被计算。这也就是所谓的短路求值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;区间运算符&quot;&gt;&lt;a href=&quot;#区间运算符&quot; class=&quot;headerlink&quot; title=&quot;区间运算符&quot;&gt;&lt;/a&gt;区间运算符&lt;/h3&gt;&lt;p&gt;Swift 提供了两个方便表达一个区间的值的运算符。&lt;/p&gt;
&lt;h4 id=&quot;闭区间运算符&quot;&gt;&lt;a href=&quot;#闭区间运算符&quot; class=&quot;headerlink&quot; title=&quot;闭区间运算符&quot;&gt;&lt;/a&gt;闭区间运算符&lt;/h4&gt;&lt;p&gt;闭区间运算符（&lt;code&gt;a...b&lt;/code&gt;）定义一个包含从 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt;（包括 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;）的所有值的区间。&lt;code&gt;a&lt;/code&gt; 的值不能超过 &lt;code&gt;b&lt;/code&gt;。 ‌ 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在 &lt;code&gt;for-in&lt;/code&gt; 循环中：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;...&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(index)&lt;/span&gt; * 5 = &lt;span class=&quot;subst&quot;&gt;\(index * &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1 * 5 = 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2 * 5 = 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3 * 5 = 15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 4 * 5 = 20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 5 * 5 = 25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;半开区间运算符&quot;&gt;&lt;a href=&quot;#半开区间运算符&quot; class=&quot;headerlink&quot; title=&quot;半开区间运算符&quot;&gt;&lt;/a&gt;半开区间运算符&lt;/h4&gt;&lt;p&gt;半开区间（&lt;code&gt;a..&amp;lt;b&lt;/code&gt;）定义一个从 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt; 但不包括 &lt;code&gt;b&lt;/code&gt; 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。&lt;/p&gt;
&lt;p&gt;半开区间的实用性在于当你使用一个从 0 开始的列表（如数组）时，非常方便地从0数到列表的长度。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; names = [&lt;span class=&quot;string&quot;&gt;&quot;Anna&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Alex&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Brian&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Jack&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; = names.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&amp;lt;&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;第 &lt;span class=&quot;subst&quot;&gt;\(i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt; 个人叫 &lt;span class=&quot;subst&quot;&gt;\(names[i])&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第 1 个人叫 Anna&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第 2 个人叫 Alex&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第 3 个人叫 Brian&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第 4 个人叫 Jack&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;逻辑运算符&quot;&gt;&lt;a href=&quot;#逻辑运算符&quot; class=&quot;headerlink&quot; title=&quot;逻辑运算符&quot;&gt;&lt;/a&gt;逻辑运算符&lt;/h3&gt;&lt;p&gt;逻辑运算的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑非（&lt;code&gt;!a&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;逻辑与（&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;逻辑或（&lt;code&gt;a || b&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;逻辑非&quot;&gt;&lt;a href=&quot;#逻辑非&quot; class=&quot;headerlink&quot; title=&quot;逻辑非&quot;&gt;&lt;/a&gt;逻辑非&lt;/h4&gt;&lt;p&gt;逻辑非运算（&lt;code&gt;!a&lt;/code&gt;）对一个布尔值取反，使得 &lt;code&gt;true&lt;/code&gt; 变 &lt;code&gt;false&lt;/code&gt;，&lt;code&gt;false&lt;/code&gt; 变 &lt;code&gt;true&lt;/code&gt;。它是一个前置运算符，需紧跟在操作数之前，且不加空格。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; allowedEntry = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !allowedEntry &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ACCESS DENIED&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出 &quot;ACCESS DENIED&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;逻辑与&quot;&gt;&lt;a href=&quot;#逻辑与&quot; class=&quot;headerlink&quot; title=&quot;逻辑与&quot;&gt;&lt;/a&gt;逻辑与&lt;/h4&gt;&lt;p&gt;逻辑与（&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;）表达了只有 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的值都为 &lt;code&gt;true&lt;/code&gt; 时，整个表达式的值才会是 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只要任意一个值为 &lt;code&gt;false&lt;/code&gt;，整个表达式的值就为 &lt;code&gt;false&lt;/code&gt;。事实上，如果第一个值为 &lt;code&gt;false&lt;/code&gt;，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; enteredDoorCode = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; passedRetinaScan = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; enteredDoorCode &amp;amp;&amp;amp; passedRetinaScan &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Welcome!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ACCESS DENIED&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出 &quot;ACCESS DENIED&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;逻辑或&quot;&gt;&lt;a href=&quot;#逻辑或&quot; class=&quot;headerlink&quot; title=&quot;逻辑或&quot;&gt;&lt;/a&gt;逻辑或&lt;/h4&gt;&lt;p&gt;逻辑或（&lt;code&gt;a || b&lt;/code&gt;）是一个由两个连续的 &lt;code&gt;|&lt;/code&gt;组成的中置运算符。它表示了两个逻辑表达式的其中一个为 &lt;code&gt;true&lt;/code&gt;，整个表达式就为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同逻辑与运算类似，逻辑或也是「短路计算」的，当左端的表达式为 &lt;code&gt;true&lt;/code&gt; 时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; hasDoorKey = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; knowsOverridePassword = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; hasDoorKey || knowsOverridePassword &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Welcome!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ACCESS DENIED&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出 &quot;Welcome!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;逻辑运算符组合计算&quot;&gt;&lt;a href=&quot;#逻辑运算符组合计算&quot; class=&quot;headerlink&quot; title=&quot;逻辑运算符组合计算&quot;&gt;&lt;/a&gt;逻辑运算符组合计算&lt;/h4&gt;&lt;p&gt;我们可以组合多个逻辑运算来表达一个复合逻辑：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; enteredDoorCode &amp;amp;&amp;amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Welcome!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ACCESS DENIED&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出 &quot;Welcome!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift 逻辑操作符 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。&lt;/li&gt;
&lt;li&gt;为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (enteredDoorCode &amp;amp;&amp;amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Welcome!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ACCESS DENIED&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出 &quot;Welcome!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;运算符是检查、改变、合并值的特殊符号或短语。Swift支持了大部分标准C语言的运算符，并且改进了很多特性来减少常规编码错误。例如(&lt;code&gt;=&lt;/code&gt;)不放回值，以防止把想要判断相等运算符（&lt;code&gt;==&lt;/code&gt;）的地方写成赋值符导致的错误。&lt;/p&gt;
&lt;h3 id=&quot;赋值运算符&quot;&gt;&lt;a href=&quot;#赋值运算符&quot; class=&quot;headerlink&quot; title=&quot;赋值运算符&quot;&gt;&lt;/a&gt;赋值运算符&lt;/h3&gt;&lt;p&gt;赋值运算（&lt;code&gt;a = b&lt;/code&gt;），表示用&lt;code&gt;b&lt;/code&gt;的值来初始化或更新&lt;code&gt;a&lt;/code&gt;的值&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//a 现在等于1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift学习笔记" scheme="http://www.jvaeyhcd.cc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>初识ReactiveCocoa响应式编程</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/24/%E5%88%9D%E8%AF%86ReactiveCocoa%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/24/初识ReactiveCocoa响应式编程/</id>
    <published>2016-05-24T05:02:01.000Z</published>
    <updated>2016-05-24T05:45:09.000Z</updated>
    
    <content type="html">&lt;p&gt;参考文章&lt;br&gt;&lt;a href=&quot;http://www.itiger.me/?p=38&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用ReactiveCocoa实现iOS平台响应式编程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa与Functional Reactive Programming&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/87ef6720a096&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最快让你上手ReactiveCocoa之基础篇&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2014/07/reactiveCocoa-cocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;花瓣网李忠：ReactiveCocoa是Cocoa的未来&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa 讨论会&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;参考文章&lt;br&gt;&lt;a href=&quot;http://www.itiger.me/?p=38&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用ReactiveCocoa实现iOS平台响应式编程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://limboy.me/
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://www.jvaeyhcd.cc/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins构建iOS持续集成自动打包</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/21/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BAiOS%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/21/使用Jenkins构建iOS持续集成自动打包/</id>
    <published>2016-05-21T07:48:50.000Z</published>
    <updated>2016-05-21T07:55:25.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用持续集成&quot;&gt;&lt;a href=&quot;#为什么使用持续集成&quot; class=&quot;headerlink&quot; title=&quot;为什么使用持续集成&quot;&gt;&lt;/a&gt;为什么使用持续集成&lt;/h3&gt;&lt;p&gt;1、减少重复繁琐的打包过程&lt;br&gt;2、任何时间、任何地点测试都可以获取到新包&lt;br&gt;3、增强项目的可见性&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;参考文档：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/c69deb29720d#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://rannie.github.io/ios/2014/12/29/xcodebuild-jenkins-ci.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用 Xcodebuild + Jenkins + Apache 做 iOS 持续集成&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用持续集成&quot;&gt;&lt;a href=&quot;#为什么使用持续集成&quot; class=&quot;headerlink&quot; title=&quot;为什么使用持续集成&quot;&gt;&lt;/a&gt;为什么使用持续集成&lt;/h3&gt;&lt;p&gt;1、减少重复繁琐的打包过程&lt;br&gt;2、任何时间、任何地点测试都可以获取到新包&lt;br&gt;3、增强项目的可见性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://www.jvaeyhcd.cc/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>关闭iOS系统自动更新提示的方法</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/16/%E5%85%B3%E9%97%ADiOS%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/16/关闭iOS系统自动更新提示的方法/</id>
    <published>2016-05-16T02:16:25.000Z</published>
    <updated>2016-05-16T02:53:02.000Z</updated>
    
    <content type="html">&lt;p&gt;一直以来都被iOS的自动更新困扰，每次苹果推出了最新版本的iOS系统都会提示自动更新，真的很烦。并且公司的测试机不可能全都是一个版本的系统，不然很多不同iOS版本系统的bug根本无法测出来，所以为了保持测试机系统的多样性，我想保持一部分手机系统永不更新，让我自己的手机保持最新系统就行了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h3&gt;&lt;p&gt;经过一段时间的试验，有如下几个对应方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 - 通用 - 用量 - 管理存储空间 - 找到更新包，然后删除它&lt;/li&gt;
&lt;li&gt;设置 - iTunes&amp;amp;App Stores, 找到Updates，关闭&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果以上两个方案还不管用，直接放大招：&lt;br&gt;在手机上打开safari，地址栏输入:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://oldcat.me/web/NOOTA9.mobileconfig&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后回车&lt;br&gt;按照要求安装此provision文件即可，然后重启。&lt;/p&gt;
&lt;img src=&quot;/2016/05/16/关闭iOS系统自动更新提示的方法/thumb_IMG_0889_1024.jpg&quot; alt=&quot;安装provision文件&quot; title=&quot;安装provision文件&quot;&gt;
&lt;p&gt;重启后打开设置 - 通用 - 软件更新 有惊喜&lt;/p&gt;
&lt;img src=&quot;/2016/05/16/关闭iOS系统自动更新提示的方法/thumb_IMG_0890_1024.jpg&quot; alt=&quot;结果图&quot; title=&quot;结果图&quot;&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都被iOS的自动更新困扰，每次苹果推出了最新版本的iOS系统都会提示自动更新，真的很烦。并且公司的测试机不可能全都是一个版本的系统，不然很多不同iOS版本系统的bug根本无法测出来，所以为了保持测试机系统的多样性，我想保持一部分手机系统永不更新，让我自己的手机保持最新系统就行了。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.jvaeyhcd.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="iOS系统" scheme="http://www.jvaeyhcd.cc/tags/iOS%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C过滤NSString中的HTML标签</title>
    <link href="http://www.jvaeyhcd.cc/2016/05/04/Objective-C%E8%BF%87%E6%BB%A4NSString%E4%B8%AD%E7%9A%84HTML%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.jvaeyhcd.cc/2016/05/04/Objective-C过滤NSString中的HTML标签/</id>
    <published>2016-05-04T03:17:29.000Z</published>
    <updated>2016-05-04T03:32:15.000Z</updated>
    
    <content type="html">&lt;p&gt;开发过程中常常会遇到这样一个情况：对于后台编辑的一些文本都是使用富文本的形式进行编辑的，我们在使用接口区请求数据的时候，请求到的数据是带HTML标签的富文本形式，但是我们前台是使用UIlabel去显示的，这个时候就需要去掉NSString的HTML标签。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;对于这种常用的一些方法，我们一般会创建一个NSString的Category去实现。关于去掉NSString中HTML标签的实现方法我在网上找到了两种实现方式：&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h3&gt;&lt;p&gt;用NSScanner扫描来处理&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;NSString+Jvaeyhcd.h&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;Foundation/Foundation.h&amp;#62;&amp;#10;&amp;#10;@interface NSString (Jvaeyhcd)&amp;#10;&amp;#10;- (NSString *)removeHTML;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NSString+Jvaeyhcd.m&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)removeHTML &amp;#123;&amp;#10;    &amp;#10;    NSScanner *theScanner;&amp;#10;    NSString *text = nil;&amp;#10;    &amp;#10;    theScanner = [NSScanner scannerWithString:self];&amp;#10;&amp;#10;    while ([theScanner isAtEnd] == NO) &amp;#123;&amp;#10;        // find start of tag&amp;#10;        [theScanner scanUpToString:@&amp;#34;&amp;#60;&amp;#34; intoString:NULL] ;&amp;#10;        // find end of tag&amp;#10;        [theScanner scanUpToString:@&amp;#34;&amp;#62;&amp;#34; intoString:&amp;#38;text] ;&amp;#10;        &amp;#10;        // replace the found tag with a space&amp;#10;        &amp;#10;        //(you can filter multi-spaces out later if you wish)&amp;#10;        &amp;#10;        self = [self stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&amp;#34;%@&amp;#62;&amp;#34;, text] withString:@&amp;#34; &amp;#34;];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法二&quot;&gt;&lt;a href=&quot;#方法二&quot; class=&quot;headerlink&quot; title=&quot;方法二&quot;&gt;&lt;/a&gt;方法二&lt;/h3&gt;&lt;p&gt;用NSString自带的Seprated自截断方法&lt;/p&gt;
&lt;p&gt;NSString+Jvaeyhcd.h&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;Foundation/Foundation.h&amp;#62;&amp;#10;&amp;#10;@interface NSString (Jvaeyhcd)&amp;#10;&amp;#10;- (NSString *)removeHTML2;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NSString+Jvaeyhcd.m&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)removeHTML2 &amp;#123;&amp;#10;    NSArray *components = [self componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&amp;#34;&amp;#60;&amp;#62;&amp;#34;]];&amp;#10;    NSMutableArray *componentsToKeep = [NSMutableArray array];&amp;#10;    &amp;#10;    for (int i = 0; i &amp;#60; [components count]; i = i + 2) &amp;#123;&amp;#10;        [componentsToKeep addObject:[components objectAtIndex:i]];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    NSString *plainText = [componentsToKeep componentsJoinedByString:@&amp;#34;&amp;#34;];&amp;#10;    &amp;#10;    return plainText;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中常常会遇到这样一个情况：对于后台编辑的一些文本都是使用富文本的形式进行编辑的，我们在使用接口区请求数据的时候，请求到的数据是带HTML标签的富文本形式，但是我们前台是使用UIlabel去显示的，这个时候就需要去掉NSString的HTML标签。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;对于这种常用的一些方法，我们一般会创建一个NSString的Category去实现。关于去掉NSString中HTML标签的实现方法我在网上找到了两种实现方式：&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h3&gt;&lt;p&gt;用NSScanner扫描来处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://www.jvaeyhcd.cc/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习笔记之基础部分</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/29/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/29/Swift学习笔记之基础部分/</id>
    <published>2016-04-29T02:07:32.000Z</published>
    <updated>2016-04-29T08:57:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文所有知识都来至于网上以及官方的学习资料，本文不做任何商业用途，只是自己的一个学习笔记，如有侵权请及时告知我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言(传说以后还可以用于开始Android应用)。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的（如果没有 C 或者 Objective-C 相关开发经验也没有关系，大家都说Swift比较通俗易懂更加容易上手）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Swift包含了C 和Objective-C上所有的数据类型，&lt;code&gt;Int&lt;/code&gt;表示整型值；&lt;code&gt;Double&lt;/code&gt;和&lt;code&gt;Float&lt;/code&gt;表示浮点型值；&lt;code&gt;Bool&lt;/code&gt;是布尔型值；&lt;code&gt;String&lt;/code&gt;是字符串型值。此外Swift还提供了三个基本的集合类型，&lt;code&gt;Array&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt;和&lt;code&gt;Dictionary&lt;/code&gt;。&lt;br&gt;除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。&lt;/p&gt;
&lt;p&gt;Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用&lt;code&gt;nil&lt;/code&gt;，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的nil指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。&lt;/p&gt;
&lt;p&gt;Swift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个String，类型安全会阻止你不小心传入一个&lt;code&gt;Int&lt;/code&gt;。你可以在开发阶段尽早发现并修正错误。&lt;/p&gt;
&lt;h2 id=&quot;常量和变量&quot;&gt;&lt;a href=&quot;#常量和变量&quot; class=&quot;headerlink&quot; title=&quot;常量和变量&quot;&gt;&lt;/a&gt;常量和变量&lt;/h2&gt;&lt;p&gt;常量的值一旦设定就不能改变，而变量的值可以随意更改。&lt;/p&gt;
&lt;h2 id=&quot;声明常量和变量&quot;&gt;&lt;a href=&quot;#声明常量和变量&quot; class=&quot;headerlink&quot; title=&quot;声明常量和变量&quot;&gt;&lt;/a&gt;声明常量和变量&lt;/h2&gt;&lt;p&gt;常量和变量必须在使用前声明，用&lt;code&gt;let&lt;/code&gt;来声明常量，用&lt;code&gt;var&lt;/code&gt;来声明变量。下面的例子展示了如何用常量和变量&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let maxNumberOfLoginTimes = 10&amp;#10;var currentLoginTimes = 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两行代码可以理解为：&lt;br&gt;&lt;code&gt;maxNumberOfLoginTimes&lt;/code&gt;声明为一个常量，它的值是10并且不可再被改变，&lt;code&gt;currentLoginAttempt&lt;/code&gt;申明为一个初始值为0的变量。&lt;br&gt;我们可以在一行中声明多个常量或者多个变量，用逗号隔开：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var x = 0.0, y = 0.0&amp;#10;let a = 1, b = 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果你的代码中有不需要改变的值，请使用&lt;code&gt;let&lt;/code&gt;关键字将它声明为常量。只将需要改变的值声明为变量。与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let languageName = &amp;#34;Swift&amp;#34;&amp;#10;languageName = &amp;#34;Swift++&amp;#34;&amp;#10;// &amp;#36825;&amp;#20250;&amp;#25253;&amp;#32534;&amp;#35793;&amp;#26102;&amp;#38169;&amp;#35823; - languageName &amp;#19981;&amp;#21487;&amp;#25913;&amp;#21464;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;类型标注&quot;&gt;&lt;a href=&quot;#类型标注&quot; class=&quot;headerlink&quot; title=&quot;类型标注&quot;&gt;&lt;/a&gt;类型标注&lt;/h2&gt;&lt;p&gt;当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。&lt;br&gt;这个例子给&lt;code&gt;welcomeMessage&lt;/code&gt;变量添加了类型标注，表示这个变量可以存储&lt;code&gt;String&lt;/code&gt;类型的值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var welcomeMessage: String&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：&lt;br&gt;“声明一个类型为&lt;code&gt;String&lt;/code&gt;，名字为&lt;code&gt;welcomeMessage&lt;/code&gt;的变量。”&lt;br&gt;“类型为&lt;code&gt;String&lt;/code&gt;”的意思是“可以存储任意&lt;code&gt;String&lt;/code&gt;类型的值。”&lt;br&gt;&lt;code&gt;welcomeMessage&lt;/code&gt;变量现在可以被设置成任意字符串：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;welcomeMessage = &amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var red, green, blue: Double&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给&lt;code&gt;welcomeMessage&lt;/code&gt;赋初始值，所以变量&lt;code&gt;welcomeMessage&lt;/code&gt;的类型是通过一个类型标注指定的，而不是通过初始值推断的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常量和变量的命名&quot;&gt;&lt;a href=&quot;#常量和变量的命名&quot; class=&quot;headerlink&quot; title=&quot;常量和变量的命名&quot;&gt;&lt;/a&gt;常量和变量的命名&lt;/h2&gt;&lt;p&gt;你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let &amp;#960; = 3.14159&amp;#10;let &amp;#20320;&amp;#22909; = &amp;#34;&amp;#20320;&amp;#22909;&amp;#19990;&amp;#30028;&amp;#34;&amp;#10;let &amp;#128054;&amp;#128046; = &amp;#34;dogcow&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。&lt;/p&gt;
&lt;p&gt;一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;输出常量和变量&quot;&gt;&lt;a href=&quot;#输出常量和变量&quot; class=&quot;headerlink&quot; title=&quot;输出常量和变量&quot;&gt;&lt;/a&gt;输出常量和变量&lt;/h2&gt;&lt;p&gt;你可以用&lt;code&gt;print(_:separator:terminator:)&lt;/code&gt;函数来输出当前常量或变量的值:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var friendlyWelcome = &amp;#34;Bonjour!&amp;#34;&amp;#10;print(friendlyWelcome)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;Bonjour!&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print(_:separator:terminator:)&lt;/code&gt;是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，&lt;code&gt;print(_:separator:terminator:)&lt;/code&gt;将会输出内容到“console”面板上。separator和terminator参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给terminator参数–例如，&lt;code&gt;print(someValue, terminator:&amp;quot;&amp;quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;#34;The current value of friendlyWelcome is \(friendlyWelcome)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The current value of friendlyWelcome is Bonjour!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h2&gt;&lt;p&gt;请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。&lt;br&gt;与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* &amp;#36825;&amp;#26159;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322;&amp;#30340;&amp;#24320;&amp;#22836;&amp;#10;/* &amp;#36825;&amp;#26159;&amp;#31532;&amp;#20108;&amp;#20010;&amp;#34987;&amp;#23884;&amp;#22871;&amp;#30340;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322; */&amp;#10;&amp;#36825;&amp;#26159;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322;&amp;#30340;&amp;#32467;&amp;#23614; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。&lt;br&gt;当然Swift的单行注释和多行注释和C语言的类似。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#36825;&amp;#26159;&amp;#19968;&amp;#20010;&amp;#21333;&amp;#34892;&amp;#27880;&amp;#37322;&amp;#10;/* &amp;#36825;&amp;#26159;&amp;#19968;&amp;#20010;,&amp;#10;&amp;#22810;&amp;#34892;&amp;#27880;&amp;#37322; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;分号&quot;&gt;&lt;a href=&quot;#分号&quot; class=&quot;headerlink&quot; title=&quot;分号&quot;&gt;&lt;/a&gt;分号&lt;/h2&gt;&lt;p&gt;与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let cat = &amp;#34;&amp;#128049;&amp;#34;; print(cat)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;&amp;#128049;&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;整数&quot;&gt;&lt;a href=&quot;#整数&quot; class=&quot;headerlink&quot; title=&quot;整数&quot;&gt;&lt;/a&gt;整数&lt;/h2&gt;&lt;p&gt;整数就是没有小数部分的数字，比如42和-23。整数可以是有符号（正、负、零）或者无符号（正、零）。&lt;/p&gt;
&lt;p&gt;Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是&lt;code&gt;UInt8&lt;/code&gt;，32位有符号整数类型是&lt;code&gt;Int32&lt;/code&gt;。就像 Swift 的其他类型一样，整数类型采用大写命名法。&lt;/p&gt;
&lt;h2 id=&quot;整数范围&quot;&gt;&lt;a href=&quot;#整数范围&quot; class=&quot;headerlink&quot; title=&quot;整数范围&quot;&gt;&lt;/a&gt;整数范围&lt;/h2&gt;&lt;p&gt;你可以访问不同整数类型的&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;属性来获取对应类型的最小值和最大值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let minValue = UInt8.min  // minValue &amp;#20026; 0&amp;#65292;&amp;#26159; UInt8 &amp;#31867;&amp;#22411;&amp;#10;let maxValue = UInt8.max  // maxValue &amp;#20026; 255&amp;#65292;&amp;#26159; UInt8 &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;所传回值的类型，正是其所对的整数类型(如上例&lt;code&gt;UInt8&lt;/code&gt;, 所传回的类型是&lt;code&gt;UInt8&lt;/code&gt;)，可用在表达式中相同类型值旁。&lt;/p&gt;
&lt;h2 id=&quot;Int&quot;&gt;&lt;a href=&quot;#Int&quot; class=&quot;headerlink&quot; title=&quot;Int&quot;&gt;&lt;/a&gt;Int&lt;/h2&gt;&lt;p&gt;一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在32位平台上，&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Int32&lt;/code&gt;长度相同。&lt;/li&gt;
&lt;li&gt;在64位平台上，&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Int64&lt;/code&gt;长度相同。&lt;br&gt;除非你需要特定长度的整数，一般来说使用&lt;code&gt;Int&lt;/code&gt;就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，&lt;code&gt;Int&lt;/code&gt;可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UInt&quot;&gt;&lt;a href=&quot;#UInt&quot; class=&quot;headerlink&quot; title=&quot;UInt&quot;&gt;&lt;/a&gt;UInt&lt;/h2&gt;&lt;p&gt;Swift 也提供了一个特殊的无符号类型&lt;code&gt;UInt&lt;/code&gt;，长度与当前平台的原生字长相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在32位平台上，&lt;code&gt;UInt&lt;/code&gt;和&lt;code&gt;UInt32&lt;/code&gt;长度相同。&lt;/li&gt;
&lt;li&gt;在64位平台上，&lt;code&gt;UInt&lt;/code&gt;和&lt;code&gt;UInt64&lt;/code&gt;长度相同。&lt;blockquote&gt;
&lt;p&gt;注意：尽量不要使用&lt;code&gt;UInt&lt;/code&gt;，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用&lt;code&gt;Int&lt;/code&gt;，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;浮点数&quot;&gt;&lt;a href=&quot;#浮点数&quot; class=&quot;headerlink&quot; title=&quot;浮点数&quot;&gt;&lt;/a&gt;浮点数&lt;/h2&gt;&lt;p&gt;浮点数是有小数部分的数字，比如&lt;code&gt;3.14159&lt;/code&gt;，&lt;code&gt;0.1&lt;/code&gt;和&lt;code&gt;-273.15&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浮点类型比整数类型表示的范围更大，可以存储比&lt;code&gt;Int&lt;/code&gt;类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Double&lt;/code&gt;表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Float&lt;/code&gt;表示32位浮点数。精度要求不高的话可以使用此类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类型安全和类型推断&quot;&gt;&lt;a href=&quot;#类型安全和类型推断&quot; class=&quot;headerlink&quot; title=&quot;类型安全和类型推断&quot;&gt;&lt;/a&gt;类型安全和类型推断&lt;/h2&gt;&lt;p&gt;Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个&lt;code&gt;String&lt;/code&gt;，你绝对不可能不小心传进去一个&lt;code&gt;Int&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。&lt;/p&gt;
&lt;p&gt;当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。&lt;/p&gt;
&lt;p&gt;因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。&lt;/p&gt;
&lt;p&gt;当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如&lt;code&gt;42&lt;/code&gt;和&lt;code&gt;3.14159&lt;/code&gt;。）&lt;/p&gt;
&lt;p&gt;例如，如果你给一个新常量赋值&lt;code&gt;42&lt;/code&gt;并且没有标明类型，Swift 可以推断出常量类型是Int，因为你给它赋的初始值看起来像一个整数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let meaningOfLife = 42&amp;#10;// meaningOfLife &amp;#20250;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Int &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是&lt;code&gt;Double&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let pi = 3.14159&amp;#10;// pi &amp;#20250;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Double &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当推断浮点数的类型时，Swift 总是会选择&lt;code&gt;Double&lt;/code&gt;而不是&lt;code&gt;Float&lt;/code&gt;。&lt;br&gt;如果表达式中同时出现了整数和浮点数，会被推断为&lt;code&gt;Double&lt;/code&gt;类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let anotherPi = 3 + 0.14159&amp;#10;// anotherPi &amp;#20250;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Double &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原始值&lt;code&gt;3&lt;/code&gt;没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为&lt;code&gt;Double&lt;/code&gt;类型。&lt;/p&gt;
&lt;h2 id=&quot;数值型字面量&quot;&gt;&lt;a href=&quot;#数值型字面量&quot; class=&quot;headerlink&quot; title=&quot;数值型字面量&quot;&gt;&lt;/a&gt;数值型字面量&lt;/h2&gt;&lt;p&gt;整数字面量可以被写作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个十进制数，没有前缀&lt;/li&gt;
&lt;li&gt;一个二进制数，前缀是&lt;code&gt;0b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个八进制数，前缀是&lt;code&gt;0o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个十六进制数，前缀是&lt;code&gt;0x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的所有整数字面量的十进制值都是16:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let decimalInteger = 16&amp;#10;let binaryInteger = 0b10000       // &amp;#20108;&amp;#36827;&amp;#21046;&amp;#30340;16&amp;#10;let octalInteger = 0o20           // &amp;#20843;&amp;#36827;&amp;#21046;&amp;#30340;16&amp;#10;let hexadecimalInteger = 0x10     // &amp;#21313;&amp;#20845;&amp;#36827;&amp;#21046;&amp;#30340;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是&lt;code&gt;0x&lt;/code&gt;）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 &lt;code&gt;e&lt;/code&gt; 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 &lt;code&gt;p&lt;/code&gt; 来指定。&lt;br&gt;如果一个十进制数的指数为&lt;code&gt;exp&lt;/code&gt;，那这个数相当于基数和10^exp的乘积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1.25e2&lt;/code&gt; 表示 1.25 × 10^2，等于 &lt;code&gt;125.0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1.25e-2&lt;/code&gt; 表示 1.25 × 10^-2，等于 &lt;code&gt;0.0125&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个十六进制数的指数为&lt;code&gt;exp&lt;/code&gt;，那这个数相当于基数和2^exp的乘积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0xFp2&lt;/code&gt; 表示 15 × 2^2，等于 &lt;code&gt;60.0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0xFp-2&lt;/code&gt; 表示 15 × 2^-2，等于 &lt;code&gt;3.75&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的这些浮点字面量都等于十进制的&lt;code&gt;12.1875&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let decimalDouble = 12.1875&amp;#10;let exponentDouble = 1.21875e1&amp;#10;let hexadecimalDouble = 0xC.3p0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let paddedDouble = 000123.456&amp;#10;let oneMillion = 1_000_000&amp;#10;let justOverOneMillion = 1_000_000.000_000_1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;数值型类型转换&quot;&gt;&lt;a href=&quot;#数值型类型转换&quot; class=&quot;headerlink&quot; title=&quot;数值型类型转换&quot;&gt;&lt;/a&gt;数值型类型转换&lt;/h2&gt;&lt;p&gt;通常来讲，即使代码中的整数常量和变量已知非负，也请使用&lt;code&gt;Int&lt;/code&gt;类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。&lt;/p&gt;
&lt;p&gt;只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。&lt;/p&gt;
&lt;h2 id=&quot;整数转换&quot;&gt;&lt;a href=&quot;#整数转换&quot; class=&quot;headerlink&quot; title=&quot;整数转换&quot;&gt;&lt;/a&gt;整数转换&lt;/h2&gt;&lt;p&gt;不同整数类型的变量和常量可以存储不同范围的数字。&lt;code&gt;Int8&lt;/code&gt;类型的常量或者变量可以存储的数字范围是-128~127，而&lt;code&gt;UInt8&lt;/code&gt;类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let cannotBeNegative: UInt8 = -1&amp;#10;// UInt8 &amp;#31867;&amp;#22411;&amp;#19981;&amp;#33021;&amp;#23384;&amp;#20648;&amp;#36127;&amp;#25968;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#10;let tooBig: Int8 = Int8.max + 1&amp;#10;// Int8 &amp;#31867;&amp;#22411;&amp;#19981;&amp;#33021;&amp;#23384;&amp;#20648;&amp;#36229;&amp;#36807;&amp;#26368;&amp;#22823;&amp;#20540;&amp;#30340;&amp;#25968;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#20250;&amp;#25253;&amp;#38169;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。&lt;/p&gt;
&lt;p&gt;要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量&lt;code&gt;twoThousand&lt;/code&gt;是&lt;code&gt;UInt16&lt;/code&gt;类型，然而常量&lt;code&gt;one&lt;/code&gt;是&lt;code&gt;UInt8&lt;/code&gt;类型。它们不能直接相加，因为它们类型不同。所以要调用&lt;code&gt;UInt16(one)&lt;/code&gt;来创建一个新的&lt;code&gt;UInt16&lt;/code&gt;数字并用&lt;code&gt;one&lt;/code&gt;的值来初始化，然后使用这个新数字来计算：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let twoThousand: UInt16 = 2_000&amp;#10;let one: UInt8 = 1&amp;#10;let twoThousandAndOne = twoThousand + UInt16(one)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在两个数字的类型都是&lt;code&gt;UInt16&lt;/code&gt;，可以进行相加。目标常量&lt;code&gt;twoThousandAndOne&lt;/code&gt;的类型被推断为&lt;code&gt;UInt16&lt;/code&gt;，因为它是两个&lt;code&gt;UInt16&lt;/code&gt;值的和。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SomeType(ofInitialValue)&lt;/code&gt;是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，&lt;code&gt;UInt16&lt;/code&gt;有一个构造器，可以接受一个&lt;code&gt;UInt8&lt;/code&gt;类型的值，所以这个构造器可以用现有的&lt;code&gt;UInt8&lt;/code&gt;来创建一个新的&lt;code&gt;UInt16&lt;/code&gt;。注意，你并不能传入任意类型的值，只能传入&lt;code&gt;UInt16&lt;/code&gt;内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）。&lt;/p&gt;
&lt;h2 id=&quot;整数和浮点数转换&quot;&gt;&lt;a href=&quot;#整数和浮点数转换&quot; class=&quot;headerlink&quot; title=&quot;整数和浮点数转换&quot;&gt;&lt;/a&gt;整数和浮点数转换&lt;/h2&gt;&lt;p&gt;整数和浮点数的转换必须显式指定类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let three = 3&amp;#10;let pointOneFourOneFiveNine = 0.14159&amp;#10;let pi = Double(three) + pointOneFourOneFiveNine&amp;#10;// pi &amp;#31561;&amp;#20110; 3.14159&amp;#65292;&amp;#25152;&amp;#20197;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Double &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中，常量&lt;code&gt;three&lt;/code&gt;的值被用来创建一个&lt;code&gt;Double&lt;/code&gt;类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。&lt;br&gt;浮点数到整数的反向转换同样行，整数类型可以用&lt;code&gt;Double&lt;/code&gt;或者&lt;code&gt;Float&lt;/code&gt;类型来初始化：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let integerPi = Int(pi)&amp;#10;// integerPi &amp;#31561;&amp;#20110; 3&amp;#65292;&amp;#25152;&amp;#20197;&amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026; Int &amp;#31867;&amp;#22411;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说&lt;code&gt;4.75&lt;/code&gt;会变成&lt;code&gt;4&lt;/code&gt;，&lt;code&gt;-3.9&lt;/code&gt;会变成&lt;code&gt;-3&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：结合数字类常量和变量不同于结合数字类字面量。字面量&lt;code&gt;3&lt;/code&gt;可以直接和字面量&lt;code&gt;0.14159&lt;/code&gt;相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;类型别名&quot;&gt;&lt;a href=&quot;#类型别名&quot; class=&quot;headerlink&quot; title=&quot;类型别名&quot;&gt;&lt;/a&gt;类型别名&lt;/h2&gt;&lt;p&gt;类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用&lt;code&gt;typealias&lt;/code&gt;关键字来定义类型别名。&lt;/p&gt;
&lt;p&gt;当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typealias AudioSample = UInt16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var maxAmplitudeFound = AudioSample.min&amp;#10;// maxAmplitudeFound &amp;#29616;&amp;#22312;&amp;#26159; 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;本例中，&lt;code&gt;AudioSample&lt;/code&gt;被定义为&lt;code&gt;UInt16&lt;/code&gt;的一个别名。因为它是别名，&lt;code&gt;AudioSample.min&lt;/code&gt;实际上是&lt;code&gt;UInt16.min&lt;/code&gt;，所以会给&lt;code&gt;maxAmplitudeFound&lt;/code&gt;赋一个初值&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;headerlink&quot; title=&quot;布尔值&quot;&gt;&lt;/a&gt;布尔值&lt;/h2&gt;&lt;p&gt;Swift 有一个基本的布尔（Boolean）类型，叫做&lt;code&gt;Bool&lt;/code&gt;。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let orangesAreOrange = true&amp;#10;let turnipsAreDelicious = false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;orangesAreOrange&lt;/code&gt;和&lt;code&gt;turnipsAreDelicious&lt;/code&gt;的类型会被推断为&lt;code&gt;Bool&lt;/code&gt;，因为它们的初值是布尔字面量。就像之前提到的&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Double&lt;/code&gt;一样，如果你创建变量的时候给它们赋值&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;，那你不需要将常量或者变量声明为&lt;code&gt;Bool&lt;/code&gt;类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。&lt;br&gt;当你编写条件语句比如&lt;code&gt;if&lt;/code&gt;语句的时候，布尔值非常有用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if turnipsAreDelicious &amp;#123;&amp;#10;    print(&amp;#34;Mmm, tasty turnips!&amp;#34;)&amp;#10;&amp;#125; else &amp;#123;&amp;#10;    print(&amp;#34;Eww, turnips are horrible.&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;Eww, turnips are horrible.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你在需要使用&lt;code&gt;Bool&lt;/code&gt;类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let i = 1&amp;#10;if i &amp;#123;&amp;#10;    // &amp;#36825;&amp;#20010;&amp;#20363;&amp;#23376;&amp;#19981;&amp;#20250;&amp;#36890;&amp;#36807;&amp;#32534;&amp;#35793;&amp;#65292;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然而，下面的例子是合法的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let i = 1&amp;#10;if i == 1 &amp;#123;&amp;#10;    // &amp;#36825;&amp;#20010;&amp;#20363;&amp;#23376;&amp;#20250;&amp;#32534;&amp;#35793;&amp;#25104;&amp;#21151;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i == 1&lt;/code&gt;的比较结果是&lt;code&gt;Bool&lt;/code&gt;类型，所以第二个例子可以通过类型检查。&lt;/p&gt;
&lt;p&gt;和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。&lt;/p&gt;
&lt;h2 id=&quot;元组&quot;&gt;&lt;a href=&quot;#元组&quot; class=&quot;headerlink&quot; title=&quot;元组&quot;&gt;&lt;/a&gt;元组&lt;/h2&gt;&lt;p&gt;元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。&lt;/p&gt;
&lt;p&gt;下面这个例子中，&lt;code&gt;(404, &amp;quot;Not Found&amp;quot;)&lt;/code&gt;是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个&lt;code&gt;404 Not Found&lt;/code&gt;状态码。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let http404Error = (404, &amp;#34;Not Found&amp;#34;)&amp;#10;// http404Error &amp;#30340;&amp;#31867;&amp;#22411;&amp;#26159; (Int, String)&amp;#65292;&amp;#20540;&amp;#26159; (404, &amp;#34;Not Found&amp;#34;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(404, &amp;quot;Not Found&amp;quot;)&lt;/code&gt;元组把一个&lt;code&gt;Int&lt;/code&gt;值和一个&lt;code&gt;String&lt;/code&gt;值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为&lt;code&gt;(Int, String)&lt;/code&gt;的元组”。&lt;br&gt;你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为&lt;code&gt;(Int, Int, Int)&lt;/code&gt;或者&lt;code&gt;(String, Bool)&lt;/code&gt;或者其他任何你想要的组合的元组。&lt;br&gt;你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let (statusCode, statusMessage) = http404Error&amp;#10;print(&amp;#34;The status code is \(statusCode)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 404&amp;#34;&amp;#10;print(&amp;#34;The status message is \(statusMessage)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status message is Not Found&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（&lt;code&gt;_&lt;/code&gt;）标记：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let (justTheStatusCode, _) = http404Error&amp;#10;print(&amp;#34;The status code is \(justTheStatusCode)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 404&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;#34;The status code is \(http404Error.0)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 404&amp;#34;&amp;#10;print(&amp;#34;The status message is \(http404Error.1)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status message is Not Found&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以在定义元组的时候给单个元素命名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let http200Status = (statusCode: 200, description: &amp;#34;OK&amp;#34;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;给元组中的元素命名后，你可以通过名字来获取这些元素的值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;#34;The status code is \(http200Status.statusCode)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status code is 200&amp;#34;&amp;#10;print(&amp;#34;The status message is \(http200Status.description)&amp;#34;)&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;The status message is OK&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个&lt;code&gt;(Int, String)&lt;/code&gt;元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可选类型&quot;&gt;&lt;a href=&quot;#可选类型&quot; class=&quot;headerlink&quot; title=&quot;可选类型&quot;&gt;&lt;/a&gt;可选类型&lt;/h2&gt;&lt;p&gt;使用可选类型（optionals）来处理值可能缺失的情况。&lt;br&gt;来看一个例子。Swift 的&lt;code&gt;Int&lt;/code&gt;类型有一种构造器，作用是将一个&lt;code&gt;String&lt;/code&gt;值转换成一个&lt;code&gt;Int&lt;/code&gt;值。然而，并不是所有的字符串都可以转换成一个整数。字符串&lt;code&gt;&amp;quot;123&amp;quot;&lt;/code&gt;可以被转换成数字&lt;code&gt;123&lt;/code&gt;，但是字符串&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;不行。&lt;/p&gt;
&lt;p&gt;下面的例子使用这种构造器来尝试将一个&lt;code&gt;String&lt;/code&gt;转换成&lt;code&gt;Int&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let possibleNumber = &amp;#34;123&amp;#34;&amp;#10;let convertedNumber = Int(possibleNumber)&amp;#10;// convertedNumber &amp;#34987;&amp;#25512;&amp;#27979;&amp;#20026;&amp;#31867;&amp;#22411; &amp;#34;Int?&amp;#34;&amp;#65292; &amp;#25110;&amp;#32773;&amp;#31867;&amp;#22411; &amp;#34;optional Int&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为该构造器可能会失败，所以它返回一个可选类型（optional）&lt;code&gt;Int&lt;/code&gt;，而不是一个&lt;code&gt;Int&lt;/code&gt;。一个可选的&lt;code&gt;Int&lt;/code&gt;被写作&lt;code&gt;Int?&lt;/code&gt;而不是&lt;code&gt;Int&lt;/code&gt;。问号暗示包含的值是可选类型，也就是说可能包含&lt;code&gt;Int&lt;/code&gt;值也可能不包含值。（不能包含其他任何值比如&lt;code&gt;Bool&lt;/code&gt;值或者&lt;code&gt;String&lt;/code&gt;值。只能是    &lt;code&gt;Int&lt;/code&gt;或者什么都没有。）&lt;/p&gt;
&lt;h2 id=&quot;nil&quot;&gt;&lt;a href=&quot;#nil&quot; class=&quot;headerlink&quot; title=&quot;nil&quot;&gt;&lt;/a&gt;nil&lt;/h2&gt;&lt;p&gt;你可以给可选变量赋值为&lt;code&gt;nil&lt;/code&gt;来表示它没有值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var serverResponseCode: Int? = 404&amp;#10;// serverResponseCode &amp;#21253;&amp;#21547;&amp;#19968;&amp;#20010;&amp;#21487;&amp;#36873;&amp;#30340; Int &amp;#20540; 404&amp;#10;serverResponseCode = nil&amp;#10;// serverResponseCode &amp;#29616;&amp;#22312;&amp;#19981;&amp;#21253;&amp;#21547;&amp;#20540;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;nil&lt;/code&gt;不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为&lt;code&gt;nil&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var surveyAnswer: String?&amp;#10;// surveyAnswer &amp;#34987;&amp;#33258;&amp;#21160;&amp;#35774;&amp;#32622;&amp;#20026; nil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：Swift 的&lt;code&gt;nil&lt;/code&gt;和 Objective-C 中的&lt;code&gt;nil&lt;/code&gt;并不一样。在 Objective-C 中，&lt;code&gt;nil&lt;/code&gt;是一个指向不存在对象的指针。在 Swift 中，&lt;code&gt;nil&lt;/code&gt;不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为&lt;code&gt;nil&lt;/code&gt;，不只是对象类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;if-语句以及强制解析&quot;&gt;&lt;a href=&quot;#if-语句以及强制解析&quot; class=&quot;headerlink&quot; title=&quot;if 语句以及强制解析&quot;&gt;&lt;/a&gt;if 语句以及强制解析&lt;/h2&gt;&lt;p&gt;你可以使用&lt;code&gt;if&lt;/code&gt;语句和&lt;code&gt;nil&lt;/code&gt;比较来判断一个可选值是否包含值。你可以使用“相等”(&lt;code&gt;==&lt;/code&gt;)或“不等”(&lt;code&gt;!=&lt;/code&gt;)来执行比较。&lt;/p&gt;
&lt;p&gt;如果可选类型有值，它将不等于&lt;code&gt;nil&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if convertedNumber != nil &amp;#123;&amp;#10;    print(&amp;#34;convertedNumber contains some integer value.&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;convertedNumber contains some integer value.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（&lt;code&gt;!&lt;/code&gt;）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if convertedNumber != nil &amp;#123;&amp;#10;    print(&amp;#34;convertedNumber has an integer value of \(convertedNumber!).&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;convertedNumber has an integer value of 123.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：使用&lt;code&gt;!&lt;/code&gt;来获取一个不存在的可选值会导致运行时错误。使用&lt;code&gt;!&lt;/code&gt;来强制解析值之前，一定要确定可选包含一个非&lt;code&gt;nil&lt;/code&gt;的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可选绑定&quot;&gt;&lt;a href=&quot;#可选绑定&quot; class=&quot;headerlink&quot; title=&quot;可选绑定&quot;&gt;&lt;/a&gt;可选绑定&lt;/h2&gt;&lt;p&gt;使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;while&lt;/code&gt;语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。&lt;/p&gt;
&lt;p&gt;像下面这样在&lt;code&gt;if&lt;/code&gt;语句中写一个可选绑定：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let constantName = someOptional &amp;#123;&amp;#10;    statements&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以像上面这样使用可选绑定来重写&lt;code&gt;possibleNumber&lt;/code&gt;这个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let actualNumber = Int(possibleNumber) &amp;#123;&amp;#10;    print(&amp;#34;\&amp;#39;\(possibleNumber)\&amp;#39; has an integer value of \(actualNumber)&amp;#34;)&amp;#10;&amp;#125; else &amp;#123;&amp;#10;    print(&amp;#34;\&amp;#39;\(possibleNumber)\&amp;#39; could not be converted to an integer&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;&amp;#39;123&amp;#39; has an integer value of 123&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码可以被理解为：“如果&lt;code&gt;Int(possibleNumber)&lt;/code&gt;返回的可选&lt;code&gt;Int&lt;/code&gt;包含一个值，创建一个叫做&lt;code&gt;actualNumber&lt;/code&gt;的新常量并将可选包含的值赋给它。”&lt;/p&gt;
&lt;p&gt;如果转换成功，&lt;code&gt;actualNumber&lt;/code&gt;常量可以在&lt;code&gt;if&lt;/code&gt;语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，&lt;code&gt;actualNumber&lt;/code&gt;只被用来输出转换结果。&lt;/p&gt;
&lt;p&gt;你可以在可选绑定中使用常量和变量。如果你想在&lt;code&gt;if&lt;/code&gt;语句的第一个分支中操作&lt;code&gt;actualNumber&lt;/code&gt;的值，你可以改成&lt;code&gt;if var actualNumber&lt;/code&gt;，这样可选类型包含的值就会被赋给一个变量而非常量。&lt;/p&gt;
&lt;p&gt;你可以包含多个可选绑定在&lt;code&gt;if&lt;/code&gt;语句中，并使用&lt;code&gt;where&lt;/code&gt;子句做布尔值判断。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let firstNumber = Int(&amp;#34;4&amp;#34;), secondNumber = Int(&amp;#34;42&amp;#34;) where firstNumber &amp;#60; secondNumber &amp;#123;&amp;#10;    print(&amp;#34;\(firstNumber) &amp;#60; \(secondNumber)&amp;#34;)&amp;#10;&amp;#125;&amp;#10;// prints &amp;#34;4 &amp;#60; 42&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;隐式解析可选类型&quot;&gt;&lt;a href=&quot;#隐式解析可选类型&quot; class=&quot;headerlink&quot; title=&quot;隐式解析可选类型&quot;&gt;&lt;/a&gt;隐式解析可选类型&lt;/h2&gt;&lt;p&gt;如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过if语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。&lt;/p&gt;
&lt;p&gt;有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型&lt;em&gt;总会&lt;/em&gt;有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。&lt;/p&gt;
&lt;p&gt;这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（&lt;code&gt;String?&lt;/code&gt;）改成感叹号（&lt;code&gt;String!&lt;/code&gt;）来声明一个隐式解析可选类型。&lt;/p&gt;
&lt;p&gt;当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。&lt;/p&gt;
&lt;p&gt;一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型&lt;code&gt;String&lt;/code&gt;和隐式解析可选类型&lt;code&gt;String&lt;/code&gt;之间的区别：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let possibleString: String? = &amp;#34;An optional string.&amp;#34;&amp;#10;let forcedString: String = possibleString! // &amp;#38656;&amp;#35201;&amp;#24778;&amp;#21497;&amp;#21495;&amp;#26469;&amp;#33719;&amp;#21462;&amp;#20540;&amp;#10;&amp;#10;let assumedString: String! = &amp;#34;An implicitly unwrapped optional string.&amp;#34;&amp;#10;let implicitString: String = assumedString  // &amp;#19981;&amp;#38656;&amp;#35201;&amp;#24863;&amp;#21497;&amp;#21495;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if assumedString != nil &amp;#123;&amp;#10;    print(assumedString)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;An implicitly unwrapped optional string.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if let definiteString = assumedString &amp;#123;&amp;#10;    print(definiteString)&amp;#10;&amp;#125;&amp;#10;// &amp;#36755;&amp;#20986; &amp;#34;An implicitly unwrapped optional string.&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果一个变量之后可能变成&lt;code&gt;nil&lt;/code&gt;的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是&lt;code&gt;nil&lt;/code&gt;的话，请使用普通可选类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h2&gt;&lt;p&gt;你可以使用错误处理（error handling）来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func canThrowAnError() throws &amp;#123;&amp;#10;    // &amp;#36825;&amp;#20010;&amp;#20989;&amp;#25968;&amp;#26377;&amp;#21487;&amp;#33021;&amp;#25243;&amp;#20986;&amp;#38169;&amp;#35823;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个函数可以通过在声明中添加&lt;code&gt;throws&lt;/code&gt;关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置&lt;code&gt;try&lt;/code&gt;关键词。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;do &amp;#123;&amp;#10;    try canThrowAnError()&amp;#10;    // &amp;#27809;&amp;#26377;&amp;#38169;&amp;#35823;&amp;#28040;&amp;#24687;&amp;#25243;&amp;#20986;&amp;#10;&amp;#125; catch &amp;#123;&amp;#10;    // &amp;#26377;&amp;#19968;&amp;#20010;&amp;#38169;&amp;#35823;&amp;#28040;&amp;#24687;&amp;#25243;&amp;#20986;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;do&lt;/code&gt;语句创建了一个新的包含作用域,使得错误能被传播到一个或多个&lt;code&gt;catch&lt;/code&gt;从句。&lt;br&gt;这里有一个错误处理如何用来应对不同错误条件的例子。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func makeASandwich() throws &amp;#123;&amp;#10;    // ...&amp;#10;&amp;#125;&amp;#10;&amp;#10;do &amp;#123;&amp;#10;    try makeASandwich()&amp;#10;    eatASandwich()&amp;#10;&amp;#125; catch Error.OutOfCleanDishes &amp;#123;&amp;#10;    washDishes()&amp;#10;&amp;#125; catch Error.MissingIngredients(let ingredients) &amp;#123;&amp;#10;    buyGroceries(ingredients)&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在此例中，&lt;code&gt;makeASandwich()&lt;/code&gt;（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为&lt;code&gt;makeASandwich()&lt;/code&gt;抛出错误，函数调用被包裹在&lt;code&gt;try&lt;/code&gt;表达式中。将函数包裹在一个&lt;code&gt;do&lt;/code&gt;语句中,任何被抛出的错误会被传播到提供的&lt;code&gt;catch&lt;/code&gt;从句中。&lt;/p&gt;
&lt;p&gt;如果没有错误被抛出, &lt;code&gt;eatASandwich()&lt;/code&gt;函数会被调用。如果一个匹配&lt;code&gt;Error.OutOfCleanDishes&lt;/code&gt;的错误被抛出,&lt;code&gt;washDishes&lt;/code&gt;函数会被调用。如果一个匹配&lt;code&gt;Error.MissingIngredients&lt;/code&gt;的错误被抛出，&lt;code&gt;buyGroceries(_:)&lt;/code&gt;函数会随着被&lt;code&gt;catch&lt;/code&gt;所捕捉到的关联值[&lt;code&gt;String&lt;/code&gt;]被调用。&lt;/p&gt;
&lt;h2 id=&quot;断言&quot;&gt;&lt;a href=&quot;#断言&quot; class=&quot;headerlink&quot; title=&quot;断言&quot;&gt;&lt;/a&gt;断言&lt;/h2&gt;&lt;p&gt;可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个断言（assertion）来结束代码运行并通过调试来找到值缺失的原因。&lt;/p&gt;
&lt;h2 id=&quot;使用断言进行调试&quot;&gt;&lt;a href=&quot;#使用断言进行调试&quot; class=&quot;headerlink&quot; title=&quot;使用断言进行调试&quot;&gt;&lt;/a&gt;使用断言进行调试&lt;/h2&gt;&lt;p&gt;断言会在运行时判断一个逻辑条件是否为&lt;code&gt;true&lt;/code&gt;。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为&lt;code&gt;true&lt;/code&gt;，代码运行会继续进行；如果条件判断为&lt;code&gt;false&lt;/code&gt;，代码执行结束，你的应用被终止。&lt;/p&gt;
&lt;p&gt;如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。&lt;/p&gt;
&lt;p&gt;你可以使用全局&lt;code&gt;assert(_:_file:line:)&lt;/code&gt;函数来写一个断言。向这个函数传入一个结果为&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;的表达式以及一条信息，当表达式的结果为&lt;code&gt;false&lt;/code&gt;的时候这条信息会被显示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let age = -3&amp;#10;assert(age &amp;#62;= 0, &amp;#34;A person&amp;#39;s age cannot be less than zero&amp;#34;)&amp;#10;// &amp;#22240;&amp;#20026; age &amp;#60; 0&amp;#65292;&amp;#25152;&amp;#20197;&amp;#26029;&amp;#35328;&amp;#20250;&amp;#35302;&amp;#21457;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，只有&lt;code&gt;age &amp;gt;= 0&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;的时候，即&lt;code&gt;age&lt;/code&gt;的值非负的时候，代码才会继续执行。如果&lt;code&gt;age&lt;/code&gt;的值是负数，就像代码中那样，&lt;code&gt;age &amp;gt;= 0为false&lt;/code&gt;，断言被触发，终止应用。&lt;/p&gt;
&lt;p&gt;如果不需要断言信息，可以省略，就像这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;assert(age &amp;#62;= 0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;何时使用断言&quot;&gt;&lt;a href=&quot;#何时使用断言&quot; class=&quot;headerlink&quot; title=&quot;何时使用断言&quot;&gt;&lt;/a&gt;何时使用断言&lt;/h2&gt;&lt;p&gt;当条件可能为假时使用断言，但是最终一定要&lt;em&gt;保证&lt;/em&gt;条件为真，这样你的代码才能继续运行。断言的适用情景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。&lt;/li&gt;
&lt;li&gt;需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。&lt;/li&gt;
&lt;li&gt;一个可选值现在是&lt;code&gt;nil&lt;/code&gt;，但是后面的代码运行需要一个非&lt;code&gt;nil&lt;/code&gt;值。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所有知识都来至于网上以及官方的学习资料，本文不做任何商业用途，只是自己的一个学习笔记，如有侵权请及时告知我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言(传说以后还可以用于开始Android应用)。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的（如果没有 C 或者 Objective-C 相关开发经验也没有关系，大家都说Swift比较通俗易懂更加容易上手）。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift学习笔记" scheme="http://www.jvaeyhcd.cc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Mac基础：如何让Finder显示隐藏文件和文件夹</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/28/Mac%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9Finder%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/</id>
    <published>2016-04-28T01:43:25.000Z</published>
    <updated>2016-04-28T07:27:34.000Z</updated>
    
    <content type="html">&lt;p&gt;有些人中喜欢折腾一些奇怪的东西（比如说我），使用git已经很长一段时间了，但是最近才发现在Finder中找不到.git的文件夹。原来这个东西是被隐藏了，那么现在问题来了，我要将隐藏的文件或者文件夹显示出来应该如何做呢？&lt;/p&gt;
&lt;h2 id=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;a href=&quot;#让Finder显示隐藏文件和文件夹&quot; class=&quot;headerlink&quot; title=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;/a&gt;让Finder显示隐藏文件和文件夹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;b&gt;第一步：&lt;/b&gt;打开「终端」应用程序（我推荐使用&lt;a href=&quot;https://www.iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iTerm&lt;/a&gt;,他比Mac自带终端好用很多）。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;第二步：&lt;/b&gt;输入如下命令，如图一所示：&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/bash.png&quot; alt=&quot;图一&quot; title=&quot;图一&quot;&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles -boolean &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//OS X Mountain Lion 和早期版本命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;第三步：&lt;/b&gt;按下「Return」键确认。&lt;br&gt;现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。如图二所示：&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/finder.png&quot; alt=&quot;图二&quot; title=&quot;图二&quot;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;让Finder隐藏隐藏文件和文件夹&quot;&gt;&lt;a href=&quot;#让Finder隐藏隐藏文件和文件夹&quot; class=&quot;headerlink&quot; title=&quot;让Finder隐藏隐藏文件和文件夹&quot;&gt;&lt;/a&gt;让Finder隐藏隐藏文件和文件夹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只需要一步&lt;br&gt;如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成（图三）即可。&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/show.png&quot; alt=&quot;图三&quot; title=&quot;图三&quot;&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles -boolean &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//OS X Mountain Lion 和早期版本命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles FALSE ; killall Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后看到的效果如图四所示：&lt;/p&gt;
&lt;img src=&quot;/2016/04/28/Mac基础：如何让Finder显示隐藏文件和文件夹/hidefinder.png&quot; alt=&quot;图四&quot; title=&quot;图四&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;有些人中喜欢折腾一些奇怪的东西（比如说我），使用git已经很长一段时间了，但是最近才发现在Finder中找不到.git的文件夹。原来这个东西是被隐藏了，那么现在问题来了，我要将隐藏的文件或者文件夹显示出来应该如何做呢？&lt;/p&gt;
&lt;h2 id=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;a href=&quot;#让Finder显示隐藏文件和文件夹&quot; class=&quot;headerlink&quot; title=&quot;让Finder显示隐藏文件和文件夹&quot;&gt;&lt;/a&gt;让Finder显示隐藏文件和文件夹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;b&gt;第一步：&lt;/b&gt;打开「终端」应用程序（我推荐使用&lt;a href=&quot;https://www.iterm2.com/&quot;&gt;iTerm&lt;/a&gt;,他比Mac自带终端好用很多）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mac基础" scheme="http://www.jvaeyhcd.cc/categories/Mac%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Mac" scheme="http://www.jvaeyhcd.cc/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Failed to Locate or Generate Matchin Signing Assets</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/</id>
    <published>2016-04-18T08:58:38.000Z</published>
    <updated>2016-04-27T11:33:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;刚开始还是好好的，突然就出现了标题的提示错误，首先签名是正确的，App ID也没有被占用的，但是在导出ipa的时候一直出现“Failed to locate or generate matchin signing assets”的提示信息。我也是醉得不行，有时能成功，有时不行，不知道苹果在搞什么鬼（不管他在搞什么，出现问题，还是不要一味的去抱怨，找解决办法才是真的）。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/problem.png&quot; alt=&quot;问题详情&quot; title=&quot;问题详情&quot;&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;如何解决&quot;&gt;&lt;a href=&quot;#如何解决&quot; class=&quot;headerlink&quot; title=&quot;如何解决&quot;&gt;&lt;/a&gt;如何解决&lt;/h2&gt;&lt;p&gt;还是Google大法好，一下就找到了解决办法。&lt;/p&gt;
&lt;p&gt;以下是我在网上找到了解决办法的详细步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先创建一个文件夹，名字就叫Payload，&lt;a style=&quot;color:#4cc190&quot;&gt;一定要是Payload&lt;/a&gt;（如果你不信，可以换一个名字试试）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后在Organizer中然后把 archive 出来的那个在 finder 打开。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/export.png&quot; alt=&quot;Organizer中显示&quot; title=&quot;Organizer中显示&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后点击显示包内容。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/show_in_finder.png&quot; alt=&quot;在Finder中显示&quot; title=&quot;在Finder中显示&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把app 和 dsym 那两个文件拷贝到 Payload文件夹中。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/product.png&quot; alt=&quot;product文件目录&quot; title=&quot;product文件目录&quot;&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/dSYMs.png&quot; alt=&quot;dSYMs文件目录&quot; title=&quot;dSYMs文件目录&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后对Payload压缩&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/zip.png&quot; alt=&quot;Payload压缩&quot; title=&quot;Payload压缩&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后将Playload.zip的后缀名改成ipa即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的方法完全可以解决无法导出ipa的问题，但是导出ipa比export出来的包要大一些。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;刚开始还是好好的，突然就出现了标题的提示错误，首先签名是正确的，App ID也没有被占用的，但是在导出ipa的时候一直出现“Failed to locate or generate matchin signing assets”的提示信息。我也是醉得不行，有时能成功，有时不行，不知道苹果在搞什么鬼（不管他在搞什么，出现问题，还是不要一味的去抱怨，找解决办法才是真的）。&lt;/p&gt;
&lt;img src=&quot;/2016/04/18/Failed-to-locate-or-generate-matchin-signing-assets/problem.png&quot; alt=&quot;问题详情&quot; title=&quot;问题详情&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift开源项目汇总</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/11/Swift%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/11/Swift开源项目汇总/</id>
    <published>2016-04-11T07:06:52.000Z</published>
    <updated>2016-05-21T07:32:52.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;拥有着苹果先天生态优势的Swift自发布以来，各种优秀的开源项目便层出不穷。我站在个人的角度，将Swift开源项目做了一个甄别、筛选，从工具、存储、网络、界面、框架到Demo以及完整应用等，满满的干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然现在对Swift还停留在入门水平，但是还是觉得有必要去网上收集一些优秀的Swift开源项目。&lt;/p&gt;
&lt;h2 id=&quot;界面类&quot;&gt;&lt;a href=&quot;#界面类&quot; class=&quot;headerlink&quot; title=&quot;界面类&quot;&gt;&lt;/a&gt;界面类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/raulriera/TextFieldEffects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TextFieldEffects&lt;/a&gt;&lt;br&gt;你不觉得标准的UITextField有一点无聊吗？我也是——所以对TextFieldEffects说hello吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/FahimF/FloatLabelFields&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FloatLabelFields&lt;/a&gt;&lt;br&gt;带浮动标签的输入框&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MortimerGoro/MGSwipeTableCell&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MGSwipeTableCell&lt;/a&gt;&lt;br&gt;另一个UI组件，在很多app里都常见，苹果应该考虑在iOS标准库里加入类似的东西。可滑动的table cell，这是这个pod最好的描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/lexrus/LTMorphingLabel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LTMorphingLabel&lt;/a&gt;&lt;br&gt;有超赞特效效果的Label&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ephread/Instructions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Instructions&lt;/a&gt;&lt;br&gt;操作指引框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mamaral/Onboard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Onboard&lt;/a&gt;&lt;br&gt;启动导航界面，很方便的集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapKit&lt;/a&gt;&lt;br&gt;Swift布局框架 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;工具类&quot;&gt;&lt;a href=&quot;#工具类&quot; class=&quot;headerlink&quot; title=&quot;工具类&quot;&gt;&lt;/a&gt;工具类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nickoneill/PermissionScope&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PermissionScope&lt;/a&gt;&lt;br&gt;用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—&amp;gt;更多活跃用户-&amp;gt;更高的留存率-&amp;gt;数据更好-&amp;gt;下载率更高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Quick/Quick&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Quick&lt;/a&gt;&lt;br&gt;Swift里的单元测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/saturngod/IAPHelper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IAPHelper&lt;/a&gt;&lt;br&gt;app内购带给我们很多陈词滥调的代码，用这个库就不需要了，把最有关交易金钱的普遍的任务从iOS用户到你的（或者你的公司的）钱包简单包装起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SwiftyJSON/SwiftyJSON&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwiftyJSON&lt;/a&gt;&lt;br&gt;GitHub上最为开发者认可的JSON解析类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ankurp/Dollar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dollar&lt;/a&gt;&lt;br&gt;Swift版Lo-Dash(或underscore)函数式工具库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/DaveWoodCom/XCGLogger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XCGLogger&lt;/a&gt;&lt;br&gt;功能完整的日志管理类库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mattt/Surge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Surge&lt;/a&gt;&lt;br&gt;基于苹果Accelerate高性能计算框架封装库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/duemunk/Async&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Async&lt;/a&gt;&lt;br&gt;简洁的后台执行代码封装库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ArtSabintsev/Siren&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Siren&lt;/a&gt;&lt;br&gt;当应用更新时，通知用户并提供App Store链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Thomvis/BrightFutures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BrightFutures&lt;/a&gt;&lt;br&gt;漫长或复杂计算由独立线程异步来完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tadija/AEXML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AEXML&lt;/a&gt;&lt;br&gt;简单又易于的XML解析类及示例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/andreamazz/AMScrollingNavbar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AMScrollingNavbar&lt;/a&gt;&lt;br&gt;swift语言编写 上下滑动时动态隐藏标题栏&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;存储类&quot;&gt;&lt;a href=&quot;#存储类&quot; class=&quot;headerlink&quot; title=&quot;存储类&quot;&gt;&lt;/a&gt;存储类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stephencelis/SQLite.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SQLite.swift&lt;/a&gt;&lt;br&gt;swift版本简单、轻量，使用上最SQL的SQLite封装库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;网络类&quot;&gt;&lt;a href=&quot;#网络类&quot; class=&quot;headerlink&quot; title=&quot;网络类&quot;&gt;&lt;/a&gt;网络类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Alamofire/Alamofire&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alamofire&lt;/a&gt;&lt;br&gt;AFNetworking网络基础库Swift语言版&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/RxSwiftCommunity/RxAlamofire&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RxAlamofire&lt;/a&gt;&lt;br&gt;对 Alamofire的封装，很是强大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础工具类以及Category&quot;&gt;&lt;a href=&quot;#基础工具类以及Category&quot; class=&quot;headerlink&quot; title=&quot;基础工具类以及Category&quot;&gt;&lt;/a&gt;基础工具类以及Category&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/FabrizioBrancati/BFKit-Swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BFKit Swift版本&lt;/a&gt;&lt;br&gt;国外的一个大神写的很好用的分类，比较齐全&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;图片类&quot;&gt;&lt;a href=&quot;#图片类&quot; class=&quot;headerlink&quot; title=&quot;图片类&quot;&gt;&lt;/a&gt;图片类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Alamofire/AlamofireImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AlamofireImage&lt;/a&gt;&lt;br&gt;swift版本的SDWebImage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kaishin/ImageScout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageScout&lt;/a&gt;&lt;br&gt;最小网络代价获得图片大小及类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/indragiek/DominantColor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DominantColor&lt;/a&gt;&lt;br&gt;提取图片主色示例项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gavinbunney/Toucan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Toucan&lt;/a&gt;&lt;br&gt;小而美的图片变换及处理类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kaishin/gifu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gifu&lt;/a&gt;&lt;br&gt;高性能GIF显示类库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Haneke/HanekeSwift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HanekeSwift&lt;/a&gt;&lt;br&gt;轻量带缓存高性能图片加载组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;框架类&quot;&gt;&lt;a href=&quot;#框架类&quot; class=&quot;headerlink&quot; title=&quot;框架类&quot;&gt;&lt;/a&gt;框架类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa&lt;/a&gt;&lt;br&gt;ReactiveCocoa带给我们一种完全不同的编程方式/结构，基于值的信号和流。这是完全的头脑风暴，首先你需要忘记你曾经学习的来理解它是如何工作的。这不是一个简单的任务，但是是有回报的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MengTo/Spring&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/robb/Cartography&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cartography&lt;/a&gt;&lt;br&gt;基于代码级的自动布局封装框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mutualmobile/MMWormhole&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MMWormhole&lt;/a&gt;&lt;br&gt;iOS扩展与宿主应用的通讯框架&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;示例项目&quot;&gt;&lt;a href=&quot;#示例项目&quot; class=&quot;headerlink&quot; title=&quot;示例项目&quot;&gt;&lt;/a&gt;示例项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ochococo/Design-Patterns-In-Swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Design-Patterns-In-Swift&lt;/a&gt;&lt;br&gt;如何使用常用设计模式及示例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/robb/hamburger-button&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hamburger-button&lt;/a&gt;&lt;br&gt;无论设计还是代码，都进行了精雕细琢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;完整项目&quot;&gt;&lt;a href=&quot;#完整项目&quot; class=&quot;headerlink&quot; title=&quot;完整项目&quot;&gt;&lt;/a&gt;完整项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tnantoka/edhita&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;edhita&lt;/a&gt;&lt;br&gt;支持Markdown, HTML预览的文本编辑器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mozilla/firefox-ios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;firefox-ios&lt;/a&gt;&lt;br&gt;来自Mozilla开发团队大型纯Swift项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JakeLin/SwiftWeather&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwiftWeather&lt;/a&gt;&lt;br&gt;清新淡雅持续改进天气预报项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;拥有着苹果先天生态优势的Swift自发布以来，各种优秀的开源项目便层出不穷。我站在个人的角度，将Swift开源项目做了一个甄别、筛选，从工具、存储、网络、界面、框架到Demo以及完整应用等，满满的干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然现在对Swift还停留在入门水平，但是还是觉得有必要去网上收集一些优秀的Swift开源项目。&lt;/p&gt;
&lt;h2 id=&quot;界面类&quot;&gt;&lt;a href=&quot;#界面类&quot; class=&quot;headerlink&quot; title=&quot;界面类&quot;&gt;&lt;/a&gt;界面类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/raulriera/TextFieldEffects&quot;&gt;TextFieldEffects&lt;/a&gt;&lt;br&gt;你不觉得标准的UITextField有一点无聊吗？我也是——所以对TextFieldEffects说hello吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/FahimF/FloatLabelFields&quot;&gt;FloatLabelFields&lt;/a&gt;&lt;br&gt;带浮动标签的输入框&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://www.jvaeyhcd.cc/tags/Swift/"/>
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中造成dealloc不调用的原因</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/06/iOS%E4%B8%AD%E9%80%A0%E6%88%90dealloc%E4%B8%8D%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/06/iOS中造成dealloc不调用的原因/</id>
    <published>2016-04-06T04:18:32.000Z</published>
    <updated>2016-04-27T10:58:58.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc &amp;#123;&amp;#10;    [_mapView release];&amp;#10;    [super dealloc];&amp;#10;&amp;#125;&amp;#10;&amp;#10;//&amp;#24182;&amp;#19988;&amp;#22312;&amp;#30028;&amp;#38754;&amp;#23558;&amp;#35201;&amp;#26174;&amp;#31034;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#35774;&amp;#32622;&amp;#20195;&amp;#29702;&amp;#65292;&amp;#23558;&amp;#35201;&amp;#28040;&amp;#22833;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#21462;&amp;#28040;&amp;#20195;&amp;#29702;&amp;#10;- (void)viewWillAppear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)viewWillDisappear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = nil;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;以上给出的方法确实是对的，可以解决反复切换地图页面和地图上一级页面内存暴增造成的闪退问题。但是这里要说的不是这个问题，而是一个新的问题，我在dealloc中打了断点，但是dealloc根本就没有执行，所以mapView也就根本就没有释放，内存还是一样在暴增。为什么ViewController已经被pop了，而ViewController的dealloc方法却没有被调用？（按理说ViewController被pop的时候它的dealloc的方法应该被调用才对）。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;通过Google搜索终于在晚上找到了答案（大家就不要用百度，想要快速准确的找到自己想要的答案推荐大家用google）。造成ViewController不释放的原因可能有很多。遇到dealloc不调用的时候只需要检查您的ViewController中是否存在以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;ViewController中存在NSTimer&lt;/b&gt;&lt;/p&gt;
&lt;p&gt; 如果你的ViewController中有NSTimer，那么你就要注意了，因为当你调用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[NSTimer scheduledTimerWithTimeInterval:1.0 &amp;#10;                                 target:self &amp;#10;                               selector:@selector(updateTime:) &amp;#10;                               userInfo:nil &amp;#10;                                repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 时，这个&lt;a style=&quot;color: #FF00EE&quot;&gt;target:self&lt;/a&gt;就增加了ViewController的return count，如果你不将这个timer invalidate，将别想调用dealloc。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;ViewController中有关的代理&lt;/b&gt;&lt;/p&gt;
&lt;p&gt; 一个比较隐秘的因素，你去找找与这个类有关的代理，有没有强引用属性？比如一个代理的delegate应该是 assign 的现在是retain，(╯‵□′)╯︵┻━┻，就是这个，它会影响你不让你调用dealloc，不信，就试试吧。（这个我还没有遇到过）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;ViewController中有Block&lt;/b&gt;&lt;/p&gt;
&lt;p&gt; 这个就是我我上面不进入dealloc的真正原因，Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。&lt;br&gt; 例如你这个类叫OneViewController,有个属性是NSString *name; 如果你在block体中使用了self.name，那样子的话这个类就没法释放。&lt;br&gt; 要解决这个问题，MRC下只需&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block Viewcontroller *weakSelf = self;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; ARC下将&lt;strong&gt;block 换为 &lt;/strong&gt;weak&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前我所知道的就以上三种情况，如果有什么错误的地方或者还存在的一些情况，欢迎大家来补充。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc &amp;#123;&amp;#10;    [_mapView release];&amp;#10;    [super dealloc];&amp;#10;&amp;#125;&amp;#10;&amp;#10;//&amp;#24182;&amp;#19988;&amp;#22312;&amp;#30028;&amp;#38754;&amp;#23558;&amp;#35201;&amp;#26174;&amp;#31034;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#35774;&amp;#32622;&amp;#20195;&amp;#29702;&amp;#65292;&amp;#23558;&amp;#35201;&amp;#28040;&amp;#22833;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#21462;&amp;#28040;&amp;#20195;&amp;#29702;&amp;#10;- (void)viewWillAppear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = self;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)viewWillDisappear:(BOOL)animated &amp;#123;&amp;#10;    _mapView.delegate = nil;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于UItableView的复用</title>
    <link href="http://www.jvaeyhcd.cc/2016/04/05/%E5%85%B3%E4%BA%8EUItableView%E7%9A%84%E5%A4%8D%E7%94%A8/"/>
    <id>http://www.jvaeyhcd.cc/2016/04/05/关于UItableView的复用/</id>
    <published>2016-04-05T01:26:44.000Z</published>
    <updated>2016-04-27T11:00:19.000Z</updated>
    
    <content type="html">&lt;p&gt;UITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;关于UItableView的复用机制大概是这样的：假设一个UItableView要加载10000条数据，但是一个屏幕最大只能展示3条数据（这里屏幕最多能展示的数据条数是根据UItableViewCell的高度来定的）。然后当你向上滑动，想要查看更多的内容，那么肯定需要一个cell放在已经存在的内容下边。这个时候并不会重新去创建一个UItableViewCell放在下面，而是根据cellIdetifier去内存池中拿到与之对应的UItableViewCell。&lt;/p&gt;
&lt;h2 id=&quot;复用方式&quot;&gt;&lt;a href=&quot;#复用方式&quot; class=&quot;headerlink&quot; title=&quot;复用方式&quot;&gt;&lt;/a&gt;复用方式&lt;/h2&gt;&lt;p&gt;UItableView的复用方式有如下四种方式实现&lt;/p&gt;
&lt;p&gt;方式一:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UITableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];  &amp;#10;if (!cell) &amp;#123;&amp;#10;&amp;#9;cell=[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方式二:UItableViewCell是xib写的&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XXXTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  &amp;#10;if (nil == cell) &amp;#123;  &amp;#10;    cell = [[[NSBundle mainBundle]loadNibNamed:@&amp;#34;XXXTableViewCell&amp;#34; owner:self options:nil]lastObject];  &amp;#10;    cell.selectionStyle=UITableViewCellSelectionStyleNone;  &amp;#10;    [tableView registerNib:[UINib nibWithNibName:@&amp;#34;XXXTableViewCell&amp;#34; bundle:[NSBundle mainBundle]] forCellReuseIdentifier:cellIdentifier];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方式三:在xib中identifier属性必须写上cellIdentifier ,对应代码中的cellIdentifier&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XXTableViewCell *cell;  &amp;#10;cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  &amp;#10;if (nil == cell) &amp;#123;  &amp;#10;    cell= [[[NSBundle mainBundle] loadNibNamed:@&amp;#34;XXTableViewCell&amp;#34; owner:nil options:nil] lastObject];  &amp;#10;&amp;#125;  &amp;#10;return cell;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方式四：先register cell，然后复用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - &amp;#21021;&amp;#22987;&amp;#21270;&amp;#25511;&amp;#20214;&amp;#10;&amp;#10;- (UITableView *)tableView&amp;#10;&amp;#123;&amp;#10;    if (!_tableView) &amp;#123;&amp;#10;        _tableView = [[UITableView alloc]initWithFrame:self.frame style:UITableViewStylePlain];&amp;#10;        _tableView.backgroundColor = kMainBgColor;&amp;#10;        _tableView.dataSource = self;&amp;#10;        _tableView.delegate = self;&amp;#10;        _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;&amp;#10;        [_tableView registerClass:[XXXCell_iPhone class] forCellReuseIdentifier:kCellIdentifier_XXXCell];&amp;#10;        _tableView.tableFooterView = self.loadingFooterView;&amp;#10;    &amp;#125;&amp;#10;    return _tableView;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&amp;#10;&amp;#123;&amp;#10;&amp;#9;//&amp;#22797;&amp;#29992;&amp;#10;    XXXCell_iPhone *cell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier_XXXCell forIndexPath:indexPath];&amp;#10;    cell.type = self.type;&amp;#10;    [cell setExpressOrder:[_list safeObjectAtIndex:indexPath.row] needTopView:indexPath.row == 0];&amp;#10;    return cell;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://www.jvaeyhcd.cc/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.jvaeyhcd.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于iOS多线程小记</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/30/%E5%85%B3%E4%BA%8EiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%8F%E8%AE%B0/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/30/关于iOS多线程小记/</id>
    <published>2016-03-30T03:42:06.000Z</published>
    <updated>2016-04-27T11:12:17.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程间不能共享内存，但线程间共享内存非常容易。&lt;/li&gt;
&lt;li&gt;系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在实际开发过程中多线程是非常有用的，假如用户点击界面上某个按钮的时候，该按钮需要执行的任务需要耗时很长，如果我们直接在UI线程中完成这个任务，在该任务执行完成返回之前，UI线程被该任务阻塞，将无法再相应用户的其它操作。在这段时间内用户对界面上的任何操作将不会被相应（除非按Home键返回），这并不是我们希望看到的结果。一般这个时候我们能够想到的办法就是将耗时的操作放到非UI线程（开启一个线程）中完成，这样UI线程就不会被阻塞，应用也就不会失去相应。&lt;/p&gt;
&lt;p&gt;iOS系统大致提供了如下3种实现多线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSThread&lt;/li&gt;
&lt;li&gt;NSOperation和NSOperationQueue&lt;/li&gt;
&lt;li&gt;GCD(Grand Central Dispatch)&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程间不能共享内存，但线程间共享内存非常容易。&lt;/li&gt;
&lt;li&gt;系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://www.jvaeyhcd.cc/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.jvaeyhcd.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS上完美编译FFmpeg</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/28/iOS%E4%B8%8A%E5%AE%8C%E7%BE%8E%E7%BC%96%E8%AF%91FFmpeg/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/28/iOS上完美编译FFmpeg/</id>
    <published>2016-03-28T13:50:00.000Z</published>
    <updated>2016-04-27T11:01:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Undefined symbols for architecture arm64:&amp;#10;  &amp;#34;_avcodec_close&amp;#34;, referenced from:&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_init_packet&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_av_malloc&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CreateYUVTab_16() in H264Decoder.o&amp;#10;  &amp;#34;_av_free&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DeleteYUVTab() in H264Decoder.o&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_register_all&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_find_decoder&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_decode_video2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_open2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_context3&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_frame&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;ld: symbol(s) not found for architecture arm64&amp;#10;clang: error: linker command failed with exit code 1 (use -v to see invocation)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;解决办法，直接上图&lt;/p&gt;
&lt;img src=&quot;/2016/03/28/iOS上完美编译FFmpeg/1.png&quot; alt=&quot;解决办法&quot; title=&quot;解决办法&quot;&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Undefined symbols for architecture arm64:&amp;#10;  &amp;#34;_avcodec_close&amp;#34;, referenced from:&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_init_packet&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_av_malloc&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CreateYUVTab_16() in H264Decoder.o&amp;#10;  &amp;#34;_av_free&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DeleteYUVTab() in H264Decoder.o&amp;#10;      CH264Decoder::~CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_av_register_all&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_find_decoder&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_decode_video2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::DecoderFrame(unsigned char*, int, int&amp;#38;, int&amp;#38;) in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_open2&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_context3&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;  &amp;#34;_avcodec_alloc_frame&amp;#34;, referenced from:&amp;#10;      CH264Decoder::CH264Decoder() in H264Decoder.o&amp;#10;ld: symbol(s) not found for architecture arm64&amp;#10;clang: error: linker command failed with exit code 1 (use -v to see invocation)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS UIWebView简单使用</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/26/iOS-UIWebView%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/26/iOS-UIWebView简单使用/</id>
    <published>2016-03-26T07:44:12.000Z</published>
    <updated>2016-03-26T08:51:41.000Z</updated>
    
    <content type="html">&lt;p&gt;UIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。&lt;/p&gt;
&lt;p&gt;下面我想简单记录一下UIWebView的简单使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建UIWebView&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGRect bouds = [[UIScreen manScreen]applicationFrame];  &amp;#10;UIWebView* webView = [[UIWebView alloc]initWithFrame:bounds];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;webView.scalespageToFit = YES;&amp;#9;    //&amp;#33258;&amp;#21160;&amp;#23545;&amp;#39029;&amp;#38754;&amp;#36827;&amp;#34892;&amp;#32553;&amp;#25918;&amp;#20197;&amp;#36866;&amp;#24212;&amp;#23631;&amp;#24149;  &amp;#10;webView.detectsPhoneNumbers = YES;  //&amp;#33258;&amp;#21160;&amp;#26816;&amp;#27979;&amp;#32593;&amp;#39029;&amp;#19978;&amp;#30340;&amp;#30005;&amp;#35805;&amp;#21495;&amp;#30721;&amp;#65292;&amp;#21333;&amp;#20987;&amp;#21487;&amp;#20197;&amp;#25320;&amp;#25171;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;显示UIWebView到UIViewController上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:webView];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加载内容&lt;/p&gt;
&lt;p&gt; 加载一个完整的网页的内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL* url = [NSURL URLWithString:@&amp;#34;http://www.youku.com&amp;#34;];//&amp;#21019;&amp;#24314;URL  &amp;#10;NSURLRequest* request = [NSURLRequest requestWithURL:url]; //&amp;#21019;&amp;#24314;NSURLRequest  &amp;#10;[webView loadRequest:request];                             //&amp;#21152;&amp;#36733;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 加载本地网页资源&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL* url = [NSURL   fileURLWithPath:filePath];          //&amp;#21019;&amp;#24314;URL  &amp;#10;NSURLRequest* request = [NSURLRequest requestWithURL:url];//&amp;#21019;&amp;#24314;NSURLRequest  &amp;#10;[webView loadRequest:request];                            //&amp;#21152;&amp;#36733;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 加载带标签的htmlString，你可以提供一个基础URL,来指导UIWebView对象如何跟随链加载远程资源&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.webContentView loadHTMLString:@&amp;#34;&amp;#60;a&amp;#62;hahhaha&amp;#60;/a&amp;#62;&amp;#34; baseURL:nil];//&amp;#26174;&amp;#31034;&amp;#24102;&amp;#26631;&amp;#31614;&amp;#30340;&amp;#23383;&amp;#31526;&amp;#20018;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导航&lt;/p&gt;
&lt;p&gt; UIWebView内部会管理浏览器的导航动作，通过goForward和goBack方法你可以控制前进与后退动作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[webView goBack];          //&amp;#21518;&amp;#36864;&amp;#10;[webView goForward];       //&amp;#21069;&amp;#36827;&amp;#10;[webView reload];          //&amp;#37325;&amp;#36733;  &amp;#10;[webView stopLoading];     //&amp;#21462;&amp;#28040;&amp;#36733;&amp;#20837;&amp;#20869;&amp;#23481;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UIWebViewDelegate委托代理&lt;/p&gt;
&lt;p&gt; UIWebViewDelegate的一组代理方法在特定时间会得到通知，要使用这些方法必须先设定webView的委托&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;webView.delegate = self;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 具体的一些委托方法有&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&amp;#10; *  &amp;#24403;&amp;#32593;&amp;#39029;&amp;#35270;&amp;#22270;&amp;#34987;&amp;#25351;&amp;#31034;&amp;#36733;&amp;#20837;&amp;#20869;&amp;#23481;&amp;#32780;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290;&amp;#24212;&amp;#24403;&amp;#36820;&amp;#22238;YES&amp;#65292;&amp;#36825;&amp;#26679;&amp;#20250;&amp;#36827;&amp;#34892;&amp;#21152;&amp;#36733;&amp;#10; *  &amp;#36890;&amp;#36807;&amp;#23548;&amp;#33322;&amp;#31867;&amp;#22411;&amp;#21442;&amp;#25968;&amp;#21487;&amp;#20197;&amp;#24471;&amp;#21040;&amp;#35831;&amp;#27714;&amp;#21457;&amp;#36215;&amp;#30340;&amp;#21407;&amp;#22240;&amp;#65292;&amp;#21487;&amp;#20197;&amp;#26159;&amp;#20197;&amp;#19979;&amp;#20219;&amp;#24847;&amp;#20540;&amp;#65306;&amp;#10; *  UIWebViewNavigationTypeLinkClicked&amp;#10; *  UIWebViewNavigationTypeFormSubmitted&amp;#10; *  UIWebViewNavigationTypeBackForward&amp;#10; *  UIWebViewNavigationTypeReload&amp;#10; *  UIWebViewNavigationTypeFormResubmitted&amp;#10; *  UIWebViewNavigationTypeOther&amp;#10; */&amp;#10;-(BOOL)webView:(UIWebView*)webView &amp;#10;shouldStartLoadWithRequest:(NSURLRequest*) reuqest &amp;#10;navigationType:(UIWebViewNavigationType)navigationType;  &amp;#10;&amp;#10;//&amp;#24403;&amp;#32593;&amp;#39029;&amp;#35270;&amp;#22270;&amp;#24050;&amp;#32463;&amp;#24320;&amp;#22987;&amp;#21152;&amp;#36733;&amp;#19968;&amp;#20010;&amp;#35831;&amp;#27714;&amp;#21518;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290;&amp;#10;-(void)webViewDidStartLoad:(UIWebView*)webView;&amp;#10;&amp;#10;//&amp;#24403;&amp;#32593;&amp;#39029;&amp;#35270;&amp;#22270;&amp;#32467;&amp;#26463;&amp;#21152;&amp;#36733;&amp;#19968;&amp;#20010;&amp;#35831;&amp;#27714;&amp;#20043;&amp;#21518;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290; &amp;#10;-(void)webViewDidFinishLoad:(UIWebView*)webView;&amp;#10;&amp;#10;//&amp;#24403;&amp;#22312;&amp;#35831;&amp;#27714;&amp;#21152;&amp;#36733;&amp;#20013;&amp;#21457;&amp;#29983;&amp;#38169;&amp;#35823;&amp;#26102;&amp;#65292;&amp;#24471;&amp;#21040;&amp;#36890;&amp;#30693;&amp;#12290;&amp;#20250;&amp;#25552;&amp;#20379;&amp;#19968;&amp;#20010;NSSError&amp;#23545;&amp;#35937;&amp;#65292;&amp;#20197;&amp;#26631;&amp;#35782;&amp;#25152;&amp;#21457;&amp;#29983;&amp;#38169;&amp;#35823;&amp;#31867;&amp;#22411;&amp;#12290;&amp;#10;-(void)webView:(UIWebView*)webView  DidFailLoadWithError:(NSError*)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。&lt;/p&gt;
&lt;p&gt;下面我想简单记录一下UIWebView的简单使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建UIWebView&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGRect bouds = [[UIScreen manScreen]applicationFrame];  &amp;#10;UIWebView* webView = [[UIWebView alloc]initWithFrame:bounds];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;webView.scalespageToFit = YES;&amp;#9;    //&amp;#33258;&amp;#21160;&amp;#23545;&amp;#39029;&amp;#38754;&amp;#36827;&amp;#34892;&amp;#32553;&amp;#25918;&amp;#20197;&amp;#36866;&amp;#24212;&amp;#23631;&amp;#24149;  &amp;#10;webView.detectsPhoneNumbers = YES;  //&amp;#33258;&amp;#21160;&amp;#26816;&amp;#27979;&amp;#32593;&amp;#39029;&amp;#19978;&amp;#30340;&amp;#30005;&amp;#35805;&amp;#21495;&amp;#30721;&amp;#65292;&amp;#21333;&amp;#20987;&amp;#21487;&amp;#20197;&amp;#25320;&amp;#25171;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C常用关键字的使用与区别</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/23/Objective-C%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/23/Objective-C常用关键字的使用与区别/</id>
    <published>2016-03-23T02:17:12.000Z</published>
    <updated>2016-05-04T03:18:20.000Z</updated>
    
    <content type="html">&lt;p&gt;虽然接触iOS已经很久了，但是对于Objective-C中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@propperty (?,?) ?*!;&amp;#10;...............&amp;#10;............&amp;#10;.........&amp;#10;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。&lt;br&gt;所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。&lt;/p&gt;
&lt;p&gt;OC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。&lt;br&gt;这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;copy&lt;/strong&gt; 创建一个索引计数为1的对象,释放掉原来的对象。复制内容（深复制），如果调用copy的是数组，则为指针复制（浅复制），仅仅复制子元素的指针。copy常常用来修饰NSString，NSMutableArray和Block。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property  (nonatomic,copy) NSString  *title;&amp;#10;@property (nonatomic, copy) NSMutableArray *myArray;&amp;#10;@property (nonatomic, copy) void(^myBlock)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;assign&lt;/strong&gt; 简单的赋值，不会更改索引计数，主要是对基本数据类型使用。eg：（NSInteger，CGFloat和C语言的int,float, double,char等）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) int n;&amp;#10;@property (nonatomic, assign) BOOL isOK;&amp;#10;@property (nonatomic, assign) CGFloat width;&amp;#10;@property (nonatomic, assign) CGPoint height;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;retain&lt;/strong&gt;&lt;br&gt;释放旧的对象，将旧对象的值赋予输入对象并将输入对象的索引计数＋1，主要应用与NSObject与其子类中。 retain是指针复制（浅复制），引用计数加1，而不会导致内容被复制。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property  (nonatomic, retain) UIColor *myColor;&amp;#10;&amp;#10;- (void)setName:(NSString *)newName &amp;#123;&amp;#10;    [newName retain];&amp;#10;    [name release];  &amp;#10;    name = newName;  &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;strong&lt;/strong&gt;&lt;br&gt;相当于retain，strong在ARC环境下为默认属性类型。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,readwrite,strong) NSString *title;&amp;#10;@property (strong, nonatomic) UIViewController *viewController;&amp;#10;@property (nonatomic,  strong) id childObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;weak&lt;/strong&gt;&lt;br&gt;取代之前的assign，对象销毁之后会自动置为nil，防止野指针。&lt;br&gt;assign不能自动置为nil，需要手动置为nil。&lt;br&gt;delegate基本总是使用weak，以防止循环引用。特殊情况是，如果希望在dealloc中调用delegate的某些方法进行释放，此时如果使用weak将引起异常，因为此时已经是nil了，那么采用assign更为合适。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property  (weak, nonatomic) IBOutlet UIButton *myButton;//&amp;#22788;&amp;#20110;&amp;#26368;&amp;#39030;&amp;#23618;&amp;#30340;IBOutlet&amp;#24212;&amp;#35813;&amp;#20026;strong&amp;#10;@property (nonatomic, weak) id parentObject;&amp;#10;@property(nonatomic, readwrite, weak) id  &amp;#60;MyDelegate&amp;#62; delegate;&amp;#10;@property (nonatomic, weak) NSObject &amp;#60;SomeDelegate&amp;#62; *delegate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;readonly&lt;/strong&gt;&lt;br&gt;此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;readwrite&lt;/strong&gt;&lt;br&gt;此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用区别&quot;&gt;&lt;a href=&quot;#使用区别&quot; class=&quot;headerlink&quot; title=&quot;使用区别&quot;&gt;&lt;/a&gt;使用区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;copy和retain&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;copy其实是建立了一个相同的对象，而retain不是；&lt;/li&gt;
&lt;li&gt;copy是内容拷贝，retain是指针拷贝；&lt;/li&gt;
&lt;li&gt;copy是内容的拷贝 ,对于像NSString的确是这样，但是如果copy的是一个NSArray呢?这时只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”.&lt;/li&gt;
&lt;li&gt;copy的情况：NSString *newPt = [pt copy];&lt;br&gt;此时会在堆上重新开辟一段内存存放@”abc” 比如0X1122 内容为@”abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;assign与retain&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;assign: 简单赋值，不更改索引计数；&lt;/li&gt;
&lt;li&gt;assign的情况：NSString *newPt = [pt assing];&lt;br&gt;此时newPt和pt完全相同 地址都是0Xaaaa 内容为0X1111 即newPt只是pt的别名，对任何一个操作就等于对另一个操作， 因此retainCount不需要增加；&lt;/li&gt;
&lt;li&gt;assign就是直接赋值；&lt;/li&gt;
&lt;li&gt;retain使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收；&lt;/li&gt;
&lt;li&gt;retain的情况：NSString *newPt = [pt retain];&lt;br&gt;此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理”abc”所在的内存，因此 retainCount需要增加1；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;readonly与readwrite&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;readonly：只产生简单的getter,没有setter。&lt;/li&gt;
&lt;li&gt;readwrite：同时产生setter\getter方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nonatomic与atomic&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;nonatomic非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问；&lt;/li&gt;
&lt;li&gt;成员变量的@property属性时，默认为atomic，提供多线程安全。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果&lt;br&gt;weak and strong property (强引用和弱引用的区别)&lt;/li&gt;
&lt;li&gt;比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态，这样取到的东西会有问题，就是不完整的。当然如果不需要多线程支持的话，用nonatomic就够了，因为不涉及到线程锁的操作，所以它执行率相对快些。&lt;/li&gt;
&lt;li&gt;atomic的意思就是setter/getter这个函数，是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;weak与strong&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;weak 和 strong 属性只有在你打开ARC时才会被要求使用，这时你是不能使用retain release autorelease 操作的，因为ARC会自动为你做好这些操作，但是你需要在对象属性上使用weak 和strong,其中strong就相当于retain属性，而weak相当于assign。&lt;/li&gt;
&lt;li&gt;只有一种情况你需要使用weak（默认是strong），就是为了避免retain cycles（就是父类中含有子类{父类retain了子类}，子类中又调用了父类{子类又retain了父类}，这样都无法release）&lt;/li&gt;
&lt;li&gt;声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;虽然接触iOS已经很久了，但是对于Objective-C中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@propperty (?,?) ?*!;&amp;#10;...............&amp;#10;............&amp;#10;.........&amp;#10;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。&lt;br&gt;所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。&lt;/p&gt;
&lt;p&gt;OC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。&lt;br&gt;这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://www.jvaeyhcd.cc/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS几种不同传值方式</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/17/iOS%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/17/iOS几种不同传值方式/</id>
    <published>2016-03-17T07:17:32.000Z</published>
    <updated>2016-04-27T10:58:45.000Z</updated>
    
    <content type="html">&lt;p&gt;关于iOS的传值方式我所知道的一共有一下6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性传值&lt;/li&gt;
&lt;li&gt;代理传值&lt;/li&gt;
&lt;li&gt;block传值&lt;/li&gt;
&lt;li&gt;单例传值&lt;/li&gt;
&lt;li&gt;通知传值&lt;/li&gt;
&lt;li&gt;NSUserDefault保存数据传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h2&gt;&lt;p&gt;属性传值一般常用在页面中，从一个页面传值到另一个页面。例如从A页面跳转到B页面，如果需要将A页面中的某个值传递到B页面中，这个时候用到最简单的传值方式就是属性传值。&lt;/p&gt;
&lt;p&gt;下面是一个简单例子实现将AViewController中UItextFiled中的值传到BViewController中Label中。&lt;br&gt;AViewController.m中的代码如下：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;AViewController.h&amp;#34;&amp;#10;#import &amp;#34;BViewController.h&amp;#34;&amp;#10;&amp;#10;@interface AViewController ()&amp;#10;&amp;#10;//&amp;#23450;&amp;#20041;&amp;#36755;&amp;#20837;&amp;#26694;&amp;#10;@property (nonatomic, strong) UITextField *textField;&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation AViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;    [super viewDidLoad];&amp;#10;    // Do any additional setup after loading the view.&amp;#10;    &amp;#10;    [self.view addSubview:self.textField];&amp;#10;    //&amp;#23450;&amp;#20041;&amp;#28857;&amp;#20987;&amp;#36339;&amp;#36716;&amp;#30340;&amp;#25353;&amp;#38062;&amp;#10;    UIButton *pushBtn = [[UIButton alloc]initWithFrame:CGRectMake(20, 150, 100, 30)];&amp;#10;    pushBtn.titleLabel.font = [UIFont systemFontOfSize:12];&amp;#10;    [pushBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];&amp;#10;    [pushBtn setTitle:@&amp;#34;push&amp;#26174;&amp;#31034;&amp;#34; forState:UIControlStateNormal];&amp;#10;    [pushBtn setBackgroundColor:[UIColor yellowColor]];&amp;#10;    [pushBtn addTarget:self action:@selector(pushAction) forControlEvents:UIControlEventTouchUpInside];&amp;#10;    [self.view addSubview:pushBtn];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)pushAction &amp;#123;&amp;#10;    //&amp;#23450;&amp;#20041;&amp;#36339;&amp;#36716;&amp;#39029;&amp;#38754;&amp;#65292;&amp;#24182;&amp;#32473;B&amp;#39029;&amp;#38754;str&amp;#36171;&amp;#20540;&amp;#10;    BViewController *vc = [[BViewController alloc]init];&amp;#10;    vc.str = self.textField.text;&amp;#10;    [self.navigationController pushViewController:vc animated:YES];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;    [super didReceiveMemoryWarning];&amp;#10;    // Dispose of any resources that can be recreated.&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (UITextField *)textField &amp;#123;&amp;#10;    if (!_textField) &amp;#123;&amp;#10;        _textField = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 280, 30)];&amp;#10;        _textField.borderStyle = UITextBorderStyleRoundedRect;&amp;#10;    &amp;#125;&amp;#10;    return _textField;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;BViewController.h文件中，声明被赋值的属性&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;UIKit/UIKit.h&amp;#62;&amp;#10;&amp;#10;@interface BViewController : UIViewController&amp;#10;&amp;#10;@property (nonatomic, copy) NSString *str;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;BViewController.m中显示AViewController传递过来的属性值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#34;BViewController.h&amp;#34;&amp;#10;&amp;#10;@interface BViewController ()&amp;#10;&amp;#10;@end&amp;#10;&amp;#10;@implementation BViewController&amp;#10;&amp;#10;- (void)viewDidLoad &amp;#123;&amp;#10;    [super viewDidLoad];&amp;#10;    // Do any additional setup after loading the view.&amp;#10;    self.view.backgroundColor = [UIColor whiteColor];&amp;#10;    &amp;#10;    UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 100, 20)];&amp;#10;    label.font = [UIFont systemFontOfSize:14];&amp;#10;    label.textColor = [UIColor blackColor];&amp;#10;    //&amp;#26174;&amp;#31034;AViewController&amp;#20256;&amp;#36882;&amp;#36807;&amp;#26469;&amp;#30340;&amp;#20540;&amp;#10;    label.text = self.str;&amp;#10;    [self.view addSubview:label];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)didReceiveMemoryWarning &amp;#123;&amp;#10;    [super didReceiveMemoryWarning];&amp;#10;    // Dispose of any resources that can be recreated.&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS的传值方式我所知道的一共有一下6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性传值&lt;/li&gt;
&lt;li&gt;代理传值&lt;/li&gt;
&lt;li&gt;block传值&lt;/li&gt;
&lt;li&gt;单例传值&lt;/li&gt;
&lt;li&gt;通知传值&lt;/li&gt;
&lt;li&gt;NSUserDefault保存数据传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.jvaeyhcd.cc/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.jvaeyhcd.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>App Store上线完整流程</title>
    <link href="http://www.jvaeyhcd.cc/2016/03/05/App-Store%E4%B8%8A%E7%BA%BF%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.jvaeyhcd.cc/2016/03/05/App-Store上线完整流程/</id>
    <published>2016-03-05T09:25:33.000Z</published>
    <updated>2016-04-27T11:24:40.000Z</updated>
    
    <content type="html">&lt;p&gt;经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。&lt;/p&gt;
&lt;h2 id=&quot;预先准备&quot;&gt;&lt;a href=&quot;#预先准备&quot; class=&quot;headerlink&quot; title=&quot;预先准备&quot;&gt;&lt;/a&gt;预先准备&lt;/h2&gt;&lt;p&gt;在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Step-1-申请开发者帐号&quot;&gt;&lt;a href=&quot;#Step-1-申请开发者帐号&quot; class=&quot;headerlink&quot; title=&quot;Step 1:申请开发者帐号&quot;&gt;&lt;/a&gt;Step 1:申请开发者帐号&lt;/h3&gt;&lt;p&gt;如果您现在已有开发者帐号，那么恭喜您，您可以直接跳过此步骤直接进入下一步骤。苹果开发者帐号分为三种：个人开发者帐号、公司帐号、企业帐号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人帐号（Individual）:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：99美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：是&lt;/li&gt;
&lt;li&gt;最大uuid支持数：100&lt;/li&gt;
&lt;li&gt;协作人数：1人（开发者自己）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：“个人”开发者可以申请升级“公司”，可以通过拨打苹果公司客服电话（400 6701 855）来咨询和办理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 公司帐号（Company）: &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：99美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：是&lt;/li&gt;
&lt;li&gt;最大uuid支持数：100&lt;/li&gt;
&lt;li&gt;协作人数：多人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：允许多个开发者进行协作开发，比个人多一些帐号管理的设置，可设置多个Apple ID，分4种管理级别的权限。申请时需要填写公司的邓白氏编码（DUNS Number）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 企业帐号（Enterprise）: &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用：299美元一年&lt;/li&gt;
&lt;li&gt;App Store上架：否&lt;/li&gt;
&lt;li&gt;最大uuid支持数：不限制&lt;/li&gt;
&lt;li&gt;协作人数：多人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：需要注意的是，企业账号开发的应用不能上线App Store，适合那些不希望公开发布应用的企业。同样，申请时也需要公司的邓白氏编码（DUNS Number）。&lt;/p&gt;
&lt;h3 id=&quot;Step-2-App-ID（应用ID）&quot;&gt;&lt;a href=&quot;#Step-2-App-ID（应用ID）&quot; class=&quot;headerlink&quot; title=&quot;Step 2:App ID（应用ID）&quot;&gt;&lt;/a&gt;Step 2:App ID（应用ID）&lt;/h3&gt;&lt;p&gt;App ID是识别不同应用程序的唯一标示符。每个app都需要一个App ID或者app标识。目前有两种类型的App标识：一个是精确的App ID（explicit App ID），一个是通配符App ID（wildcard App ID）。使用通配符的App ID可以用来构建和安装多个程序。尽管通配符App ID非常方便，但是一个精确的App ID也是需要的，尤其是当App使用iCloud 或者使用其他iOS功能的时候，比如Game Center、Push Notifications或者IAP。如果你已经申请开发者帐号，接下你需要登录&lt;a href=&quot;https://developer.apple.com/membercenter/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/membercenter/。&lt;/a&gt;&lt;br&gt;登录成功后界面如下：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/developer_center.png&quot; alt=&quot;Developer页面&quot; title=&quot;Developer页面&quot;&gt;&lt;br&gt;点击“Certificates,Identifiers&amp;amp;Profiles”进入到&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/Identifiers.png&quot; alt=&quot;Identifiers&quot; title=&quot;Identifiers&quot;&gt;&lt;br&gt;选择Identifiers，然后点击“＋”注册你自己的应用的App Id&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_app_id.png&quot; alt=&quot;创建App ID&quot; title=&quot;创建App ID&quot;&gt;&lt;br&gt;以上两项设置好后，点击下一步，然后注册即可，这样一个App Id就创建好了。接下来需要设置开发证书。&lt;/p&gt;
&lt;h3 id=&quot;Step-3-Distribution-Certificate-发布证书&quot;&gt;&lt;a href=&quot;#Step-3-Distribution-Certificate-发布证书&quot; class=&quot;headerlink&quot; title=&quot;Step 3:Distribution Certificate(发布证书)&quot;&gt;&lt;/a&gt;Step 3:Distribution Certificate(发布证书)&lt;/h3&gt;&lt;p&gt;iOS应用都有一个安全证书用于验证开发者身份和签名。为了可以向App Store提交app，你需要创建一个iOS provisioning profile 。首先需要创建一个distribution certificate（发布证书），过程类似于创建一个development certificate（开发证书）。如果你已经在实体设备上测试你的App，那么你对创建development certificate就已经很熟悉了。&lt;/p&gt;
&lt;p&gt;首先选择Certificate,然后点击“＋”&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step1.png&quot; alt=&quot;创建Certificate证书第一步&quot; title=&quot;创建Certificate证书第一步&quot;&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step2.png&quot; alt=&quot;创建Certificate证书第二步&quot; title=&quot;创建Certificate证书第二步&quot;&gt;
&lt;p&gt;然后点击“下一步”来到如下界面：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certificates_step3.png&quot; alt=&quot;创建Certificate证书第三步&quot; title=&quot;创建Certificate证书第三步&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里需要上传一个.certSigningRequest文件来生成相应的证书。下面简单讲一下.certSigningRequest文件的生成方法：&lt;br&gt;首先打开“钥匙串访问”，在菜单中选择“钥匙串访问”-&amp;gt;“证书助理”-&amp;gt;“从证书颁发机构请求证书…”。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certSigningRequest_step1.png&quot; alt=&quot;创建.certSigningRequest文件&quot; title=&quot;创建.certSigningRequest文件&quot;&gt;&lt;br&gt;然后填写好相应的信息，注意：选择保存到磁盘。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_certSigningRequest_step2.png&quot; alt=&quot;填写.certSigningRequest文件信息&quot; title=&quot;填写.certSigningRequest文件信息&quot;&gt;&lt;br&gt;点击继续，然后会生成一个.certSigningRequest文件。&lt;br&gt;然后选择生成的.certSigningRequest文件，点击下一步即可生成相应的证书。&lt;/p&gt;
&lt;h3 id=&quot;Step-4-Provisioning-Profile-配置文件&quot;&gt;&lt;a href=&quot;#Step-4-Provisioning-Profile-配置文件&quot; class=&quot;headerlink&quot; title=&quot;Step 4:Provisioning Profile(配置文件)&quot;&gt;&lt;/a&gt;Step 4:Provisioning Profile(配置文件)&lt;/h3&gt;&lt;p&gt;一旦你创建了App ID和distribution certificate，你可以创建一个iOS provisioning profile以方便在App Store中销售你的App。Provisioning Profile主要分为开发配置文件和发布配置文件，发布配置文件中又分App Store配置文件和Ad Hoc配置文件。App Store类型的Provisioning Profile顾名思义是用于发布到App Store的配置文件。Ad Hoc的Provisioning Profile配置文件是用于发布应用内的测试包的，在应用还没有上线的时候需要发ipa给客户安装的时候需要用到，只需要获取到客户手机的UDID然后生成相应的Ad Hoc类型的Provisioning Profile文件然后打包发布即可。&lt;br&gt;同样Provisioning Profile的创建方式如下：&lt;br&gt;选择“Provisioning Profiles”，然后点击“➕”创建Provisioning Profiles文件&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step1.png&quot; alt=&quot;创建Provisioning Profiles文件&quot; title=&quot;创建Provisioning Profiles文件&quot;&gt;
&lt;p&gt;选择相应的Provisioning Profiles文件类型&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step2.png&quot; alt=&quot;选择Provisioning Profiles文件类型&quot; title=&quot;选择Provisioning Profiles文件类型&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择您需要生成Provisioning Profiles文件的App ID&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step3.png&quot; alt=&quot;选择Provisioning Profiles文件的App ID&quot; title=&quot;选择Provisioning Profiles文件的App ID&quot;&gt;&lt;br&gt;选择相应的证书&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step4.png&quot; alt=&quot;选择相应的证书&quot; title=&quot;选择相应的证书&quot;&gt;&lt;br&gt;选择已注册的设备&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/create_pp_step5.png&quot; alt=&quot;选择已注册的设备&quot; title=&quot;选择已注册的设备&quot;&gt;&lt;br&gt;然后点击下一步即可生成Provisioning Profiles文件，点击下载，然后双击打开。&lt;/p&gt;
&lt;h3 id=&quot;Step-5-Build-Settings-生成设置&quot;&gt;&lt;a href=&quot;#Step-5-Build-Settings-生成设置&quot; class=&quot;headerlink&quot; title=&quot;Step 5:Build Settings(生成设置)&quot;&gt;&lt;/a&gt;Step 5:Build Settings(生成设置)&lt;/h3&gt;&lt;p&gt;配置App ID、distribution certificate 和provisioning profile已经完成，是时候配置Xcode中target的build settings了。在Xcode Project  Navigator的targets列表中选择一个target，打开顶部的Build Settings选项，然后更新一下Code Signing来跟之前创建的distribution provisioning profile相匹配。最近添加的provisioning profiles有时候不会立马就在build settings的Code Signing中看到，重启一下Xcode就可以解决这个问题。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/build_setting.png&quot; alt=&quot;Build Setting配置&quot; title=&quot;Build Setting配置&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Step-6-Deployment-Target-部署目标&quot;&gt;&lt;a href=&quot;#Step-6-Deployment-Target-部署目标&quot; class=&quot;headerlink&quot; title=&quot;Step 6:Deployment Target(部署目标)&quot;&gt;&lt;/a&gt;Step 6:Deployment Target(部署目标)&lt;/h3&gt;&lt;p&gt;所有配置都已配好后，就可以开始打包了生成ipa了。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/archive.png&quot; alt=&quot;开始打包&quot; title=&quot;开始打包&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;iTunes-Connect相关配置&quot;&gt;&lt;a href=&quot;#iTunes-Connect相关配置&quot; class=&quot;headerlink&quot; title=&quot;iTunes Connect相关配置&quot;&gt;&lt;/a&gt;iTunes Connect相关配置&lt;/h2&gt;&lt;h3 id=&quot;Step-1-创建“我的App”&quot;&gt;&lt;a href=&quot;#Step-1-创建“我的App”&quot; class=&quot;headerlink&quot; title=&quot;Step 1:创建“我的App”&quot;&gt;&lt;/a&gt;Step 1:创建“我的App”&lt;/h3&gt;&lt;p&gt;首先用你自己的开发者帐号登录到&lt;a href=&quot;https://itunesconnect.apple.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iTunes Connect&lt;/a&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step1.png&quot; alt=&quot;iTunes Connect&quot; title=&quot;iTunes Connect&quot;&gt;
&lt;p&gt;登录成功后点击“我的App”，然后点击“＋”-&amp;gt;“新建App”&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step2.png&quot; alt=&quot;在iTunes Connect上新建App&quot; title=&quot;在iTunes Connect上新建App&quot;&gt;&lt;br&gt;其中平台选择iOS，名称为你的app的名词，主要语言为你的app的主要语言，套装ID为之前创建的App ID，也就是Xcode工程中的Bundle ID。&lt;br&gt;点击下一步，创建成功后，选择你刚创建成功的应用，进行相关的设置。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step3.png&quot; alt=&quot;填写相关信息&quot; title=&quot;填写相关信息&quot;&gt;&lt;/p&gt;
&lt;p&gt;相关设置比较简单就不再多说。&lt;/p&gt;
&lt;h3 id=&quot;Step-2-打包上传到iTunes-Connect&quot;&gt;&lt;a href=&quot;#Step-2-打包上传到iTunes-Connect&quot; class=&quot;headerlink&quot; title=&quot;Step 2:打包上传到iTunes Connect&quot;&gt;&lt;/a&gt;Step 2:打包上传到iTunes Connect&lt;/h3&gt;&lt;p&gt;配置好了iTunes Connect的相关配置后，就可以将我们生成的ipa包上传到iTunes Connect上了。Xcode中配置完成后archive成功后Xcode会弹出如下界面：&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/upload_itunes_connect.png&quot; alt=&quot;上传到iTunes Connect&quot; title=&quot;上传到iTunes Connect&quot;&gt;&lt;br&gt; 上传到iTunes Connect有两种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法一 &lt;/strong&gt;&lt;br&gt;直接点击上图的“Upload to App Store”按钮直接上传到App Store。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 方法二 &lt;/strong&gt;&lt;br&gt;先导出ipa，然后使用Application Loader上传到App Store。&lt;br&gt;点击“Export”，会弹出如下界面，选择导出的类型，这里要上传App Store，所以选择第一种。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/archive_step_1.png&quot; alt=&quot;导出ipa文件&quot; title=&quot;导出ipa文件&quot;&gt;&lt;br&gt;点击“下一步”，默认回去检查你的证书，如果没有什么问题一直下一步，最后会在桌面生成一个ipa的包。然后在Xcode中打开Application Loader。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_1.png&quot; alt=&quot;Application Loader&quot; title=&quot;Application Loader&quot;&gt;&lt;br&gt;用你自己的开发者帐号登录Application Loader，&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_login.png&quot; alt=&quot;Application Loader登录&quot; title=&quot;Application Loader登录&quot;&gt;&lt;br&gt;登录成功后选取你刚刚生成的ipa&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/application_loader_step2.png&quot; alt=&quot;Application Loader上传&quot; title=&quot;Application Loader上传&quot;&gt;&lt;br&gt;然后上传提交到App Store。&lt;/p&gt;
&lt;h3 id=&quot;Step-3-提交给苹果审核&quot;&gt;&lt;a href=&quot;#Step-3-提交给苹果审核&quot; class=&quot;headerlink&quot; title=&quot;Step 3:提交给苹果审核&quot;&gt;&lt;/a&gt;Step 3:提交给苹果审核&lt;/h3&gt;&lt;p&gt;完成上面的步骤后，返回到iTunes Connect界面，选择你先前创建的App，在它的活动页面下可以看到所有已上传过的ipa版本。&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step4.png&quot; alt=&quot;上传成功后&quot; title=&quot;上传成功后&quot;&gt;&lt;br&gt;选择App信息配置界面，找到“构建版本”，然后选择你刚刚上传的构建版本，然后提交审核即可&lt;br&gt;&lt;img src=&quot;/2016/03/05/App-Store上线完整流程/itunes_connect_step5.png&quot; alt=&quot;提交审核&quot; title=&quot;提交审核&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。&lt;/p&gt;
&lt;h2 id=&quot;预先准备&quot;&gt;&lt;a href=&quot;#预先准备&quot; class=&quot;headerlink&quot; title=&quot;预先准备&quot;&gt;&lt;/a&gt;预先准备&lt;/h2&gt;&lt;p&gt;在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://www.jvaeyhcd.cc/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App Store" scheme="http://www.jvaeyhcd.cc/tags/App-Store/"/>
    
  </entry>
  
</feed>
